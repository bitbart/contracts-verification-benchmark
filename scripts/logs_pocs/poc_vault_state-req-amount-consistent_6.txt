You are an expert in Solidity smart contracts and formal verification. 

You will be given: 
1. A Solidity smart contract. 
2. A property on the contract, expressed in natural language, that is violated. 
3. An explanation of why the property is violated.
4. A counterexample written in natural language that consists in a trace that violates the property.

Your task: 
- Carefully analyze the contract and understand in depth why the given counterexample violates the property.
- Encode the counterexample to a JavaScript file (using HardHat 2.14.0, Mocha, and Chai) to produce a Proof of Concept that shows a concrete trace that violates the property. You will be provided with an example of proof of concept (for a different contract) at the end of the prompt. 

Think step by step internally about how to translate the counterexample into an Hardhat Proof of Concept. Make sure that the code you produce works correctly. Do not include your reasoning in the output. 

Your answer must consist of ONLY the code of the Hardhat Proof of Concept.
---
Smart Contract:
// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >= 0.8.2;

contract Vault {
    enum States{IDLE, REQ}

    address owner;
    address recovery;
    uint wait_time;

    address receiver;
    uint request_time;
    uint amount;
    States state;
    
    constructor (address payable recovery_, uint wait_time_) payable {
    	require(msg.sender != recovery_);
        require(wait_time_ > 0);
        owner = msg.sender;
        recovery = recovery_;
        wait_time = wait_time_;
        state = States.IDLE;
    }

    receive() external payable { }

    function withdraw(address receiver_, uint amount_) public {
        require(state == States.IDLE);
        require(msg.sender == owner);

        request_time = block.number;
        amount = amount_;
        receiver = receiver_;
        state = States.REQ;
    }

    function finalize() public {
        require(state == States.REQ);
        require(block.number >= request_time + wait_time);
        require(msg.sender == owner);

        state = States.IDLE;	
        (bool succ,) = receiver.call{value: amount}("");
        require(succ);
    }

    function cancel() public {
        require(state == States.REQ);
        require(msg.sender == recovery);

        state = States.IDLE;
    }
}

Property:
if the state is REQ, then `amount` is less than or equal to the contract balance.
Explanation:
In withdraw(), when state == REQ is set, there is no check that amount_ <= address(this).balance; the function simply assigns amount = amount_ and sets state = States.REQ. Thus the contract can be in REQ with amount exceeding the current balance. finalize() would later revert if balance is insufficient, but that does not enforce the property while in REQ.
Counterexample:
- Deploy the contract with recovery = R (R != deployer), wait_time = 1, and send 0 ether.
- As owner, call withdraw(receiver = A, amount = 1 wei).
- Now state == REQ, amount == 1 wei, but contract balance == 0 wei. Property is violated.
---
Example of proof of concept:
Contract: 
```
pragma solidity ^0.8.25;

contract Reentrancy {
	uint x;
	function s(uint _x) public {
		x = _x;
	}
	function f(address a) public {
		require(x == 0);
		(bool s, bytes memory data) = a.call("");
	}
	function getX() public view returns (uint) {
		return x;
	}
}
```
Counterexample:
```
- Deploy Reentrancy (x is initially 0).
- Deploy ReentrancyAttack with a fallback that executes Reentrancy.s(5).
- Call Reentrancy.f(reentrancyAttackAddress). The require passes. The external call invokes ReentrancyAttackâ€™s fallback which calls s(5), setting x = 5. After f returns, x == 5.
```
HardHat proof of concept:
```
const {
  loadFixture,
} = require("@nomicfoundation/hardhat-toolbox/network-helpers");
const { expect } = require("chai");

beforeEach(async function () {
  this.Reentrancy = await ethers.deployContract("Reentrancy");
  this.ReentrancyAttack = await ethers.deployContract("ReentrancyAttack");
});

describe("Reentrancy", function() {
  async function deployContract() {
    const [owner] = await ethers.getSigners();

    const Reentrancy = await ethers.deployContract("Reentrancy");
    const ReentrancyAttack = await ethers.deployContract("ReentrancyAttack");

    return { Reentrancy, ReentrancyAttack};
  }
  it("The value of x is not 0 after the call to `f`", async function(){
    const { Reentrancy, ReentrancyAttack } = await loadFixture(deployContract);
    let reentrancyAttackAddress = ReentrancyAttack.getAddress();
    await Reentrancy.f(reentrancyAttackAddress);
    expect(await Reentrancy.getX()).not.to.equal(0);
  })
})
```
