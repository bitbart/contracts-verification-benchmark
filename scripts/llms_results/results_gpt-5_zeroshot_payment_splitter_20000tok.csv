"contract_id","property_id","ground_truth","llm_answer","llm_explanation","llm_counterexample","time","tokens","raw_output"
"1","fair-split-geq","False","TRUE","The contract enforces released[a] ≤ (address(this).balance + totalReleased) * shares[a] / totalShares at all times. Specifically:\n- totalReceived is defined as address(this).balance + totalReleased (releasable).\n- pendingPayment(account, totalReceived, released[account]) = (totalReceived * shares[account]) / totalShares - released[account].\n- release() increases released[account] exactly by releasable(account), i.e., by the non-negative difference between the allocation and alreadyReleased, and then transfers that amount. Thus after release, released[account] equals floor(totalReceived * shares[account] / totalShares).\n- On release, address(this).balance decreases by the payment while totalReleased increases by the same amount, keeping totalReceived constant; deposits only increase totalReceived. Therefore, released[account] can never exceed the computed allocation.\nRelevant code: releasable(), pendingPayment(), and release().","N/A","116.45584058761597","20000","ANSWER: TRUE\nEXPLANATION: The contract enforces released[a] ≤ (address(this).balance + totalReleased) * shares[a] / totalShares at all times. Specifically:\n- totalReceived is defined as address(this).balance + totalReleased (releasable).\n- pendingPayment(account, totalReceived, released[account]) = (totalReceived * shares[account]) / totalShares - released[account].\n- release() increases released[account] exactly by releasable(account), i.e., by the non-negative difference between the allocation and alreadyReleased, and then transfers that amount. Thus after release, released[account] equals floor(totalReceived * shares[account] / totalShares).\n- On release, address(this).balance decreases by the payment while totalReleased increases by the same amount, keeping totalReceived constant; deposits only increase totalReceived. Therefore, released[account] can never exceed the computed allocation.\nRelevant code: releasable(), pendingPayment(), and release().\nCOUNTEREXAMPLE: N/A"
"1","fair-split-geq-no-overflow","True","TRUE","The contract defines totalReceived as address(this).balance + totalReleased (releasable). For each payee a, pendingPayment computes ((totalReceived * shares[a]) / totalShares) - released[a]. The only way to increase released[a] is via release, which sets payment = pendingPayment and then updates released[a] += payment and totalReleased += payment. Since payment is never more than the computed due, released[a] never exceeds (totalReceived * shares[a]) / totalShares. Moreover, during a release, totalReceived remains constant (balance decreases by payment while totalReleased increases by the same payment), preserving the invariant.","N/A","125.50065541267395","20000","ANSWER: TRUE\nEXPLANATION: The contract defines totalReceived as address(this).balance + totalReleased (releasable). For each payee a, pendingPayment computes ((totalReceived * shares[a]) / totalShares) - released[a]. The only way to increase released[a] is via release, which sets payment = pendingPayment and then updates released[a] += payment and totalReleased += payment. Since payment is never more than the computed due, released[a] never exceeds (totalReceived * shares[a]) / totalShares. Moreover, during a release, totalReceived remains constant (balance decreases by payment while totalReleased increases by the same payment), preserving the invariant.\nCOUNTEREXAMPLE: N/A"
"1","non-zero-payees","True","TRUE","The only way entries are added to the payees array is via addPayee, called from the constructor. addPayee enforces account != ZERO_ADDRESS (require in addPayee), preventing the zero address from ever being pushed into payees. There are no other functions that modify payees after deployment.","N/A","14.69156527519226","20000","ANSWER: TRUE\nEXPLANATION: The only way entries are added to the payees array is via addPayee, called from the constructor. addPayee enforces account != ZERO_ADDRESS (require in addPayee), preventing the zero address from ever being pushed into payees. There are no other functions that modify payees after deployment.\nCOUNTEREXAMPLE: N/A"
"2","non-zero-payees","True","TRUE","The only way to insert into the payees array is via addPayee, which requires account != ZERO_ADDRESS ("PaymentSplitter: account is the zero address"). The constructor populates the three payees exclusively through addPayee, and there are no functions to modify payees afterward.","N/A","13.73404049873352","20000","ANSWER: TRUE\nEXPLANATION: The only way to insert into the payees array is via addPayee, which requires account != ZERO_ADDRESS ("PaymentSplitter: account is the zero address"). The constructor populates the three payees exclusively through addPayee, and there are no functions to modify payees afterward.\nCOUNTEREXAMPLE: N/A"
"3","non-zero-payees","True","TRUE","The constructor requires each of the three payees to be non-zero before adding them to the payees array (three separate require checks: payee1 != ZERO_ADDRESS, payee2 != ZERO_ADDRESS, payee3 != ZERO_ADDRESS). After construction, there are no functions that modify the payees array. Therefore, all addresses in payees are always non-zero.","N/A","17.48133873939514","20000","ANSWER: TRUE\nEXPLANATION: The constructor requires each of the three payees to be non-zero before adding them to the payees array (three separate require checks: payee1 != ZERO_ADDRESS, payee2 != ZERO_ADDRESS, payee3 != ZERO_ADDRESS). After construction, there are no functions that modify the payees array. Therefore, all addresses in payees are always non-zero.\nCOUNTEREXAMPLE: N/A"
"4","non-zero-payees","True","TRUE","The only way entries are added to the payees array is via addPayee, which enforces account != ZERO_ADDRESS. The constructor iterates over the provided payees_ and calls addPayee for each; there are no functions to add or modify payees afterward. Therefore, any deployed instance must have all payees non-zero.","N/A","18.12173581123352","20000","ANSWER: TRUE\nEXPLANATION: The only way entries are added to the payees array is via addPayee, which enforces account != ZERO_ADDRESS. The constructor iterates over the provided payees_ and calls addPayee for each; there are no functions to add or modify payees afterward. Therefore, any deployed instance must have all payees non-zero.\nCOUNTEREXAMPLE: N/A"
"5","non-zero-payees","True","TRUE","The only way payees are added is via the private addPayee function, which is called exclusively from the constructor. addPayee enforces that account != ZERO_ADDRESS via require (addPayee). Therefore, every element pushed into the payees array is non-zero and no other function can later modify payees.","N/A","10.349046230316162","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via the private addPayee function, which is called exclusively from the constructor. addPayee enforces that account != ZERO_ADDRESS via require (addPayee). Therefore, every element pushed into the payees array is non-zero and no other function can later modify payees.\nCOUNTEREXAMPLE: N/A"
"6","non-zero-payees","False","FALSE","The constructor calls addPayee for each provided payee. In addPayee, the zero-address check compares against a mis-set constant ZERO_ADDRESS = 0x...80 (not the true 0x0), via require(account != ZERO_ADDRESS, ...). This allows address(0) to be added to payees. See ZERO_ADDRESS definition and addPayee.","Deploy the contract with payees_ = [address(0x0)] and shares_ = [1]. The require(account != ZERO_ADDRESS) passes since ZERO_ADDRESS != address(0), so payees will contain address(0), violating the property.","14.94186282157898","20000","ANSWER: FALSE\nEXPLANATION: The constructor calls addPayee for each provided payee. In addPayee, the zero-address check compares against a mis-set constant ZERO_ADDRESS = 0x...80 (not the true 0x0), via require(account != ZERO_ADDRESS, ...). This allows address(0) to be added to payees. See ZERO_ADDRESS definition and addPayee.\nCOUNTEREXAMPLE: Deploy the contract with payees_ = [address(0x0)] and shares_ = [1]. The require(account != ZERO_ADDRESS) passes since ZERO_ADDRESS != address(0), so payees will contain address(0), violating the property."
"1","positive-shares","True","TRUE","The only way to populate the payees array is via addPayee, which is called from the constructor. addPayee enforces shares_ > 0 and pushes the account to payees only after this check. There are no functions that later modify shares or add payees (addPayee is private), so every address in payees always has shares[addr] > 0.","N/A","10.853040933609009","20000","ANSWER: TRUE\nEXPLANATION: The only way to populate the payees array is via addPayee, which is called from the constructor. addPayee enforces shares_ > 0 and pushes the account to payees only after this check. There are no functions that later modify shares or add payees (addPayee is private), so every address in payees always has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"2","positive-shares","True","TRUE","The only way payees are added is via addPayee, which is called exactly three times in the constructor. addPayee requires shares_ > 0 and sets shares[account] = shares_. No other function modifies shares or payees thereafter. Therefore every address in payees has shares[addr] > 0.","N/A","18.533000230789185","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via addPayee, which is called exactly three times in the constructor. addPayee requires shares_ > 0 and sets shares[account] = shares_. No other function modifies shares or payees thereafter. Therefore every address in payees has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"3","positive-shares","True","TRUE","In the constructor, each of the three payees is pushed into the payees array and assigned shares[payee] = 1. Duplicate or zero addresses are rejected. There are no functions that modify the payees array or the shares mapping after deployment. Therefore, for every address in payees, shares[address] remains > 0.","N/A","9.316549301147461","20000","ANSWER: TRUE\nEXPLANATION: In the constructor, each of the three payees is pushed into the payees array and assigned shares[payee] = 1. Duplicate or zero addresses are rejected. There are no functions that modify the payees array or the shares mapping after deployment. Therefore, for every address in payees, shares[address] remains > 0.\nCOUNTEREXAMPLE: N/A"
"4","positive-shares","True","TRUE","The only way to populate the payees array is via addPayee, which is called exclusively in the constructor. addPayee enforces shares_ > 0 and prevents duplicates (shares[account] == 0) and zero address. No function later modifies payees or shares. Therefore, every address in payees has shares[addr] > 0 and this remains invariant.","N/A","20.28274703025818","20000","ANSWER: TRUE\nEXPLANATION: The only way to populate the payees array is via addPayee, which is called exclusively in the constructor. addPayee enforces shares_ > 0 and prevents duplicates (shares[account] == 0) and zero address. No function later modifies payees or shares. Therefore, every address in payees has shares[addr] > 0 and this remains invariant.\nCOUNTEREXAMPLE: N/A"
"5","positive-shares","True","TRUE","The only way payees are added is via the constructor, which calls addPayee(account, shares_). In addPayee, there is a require(shares_ > 0, ...) and then shares[account] = shares_; payees.push(account). There are no functions that later modify payees or set shares to zero. Therefore, every address stored in payees has shares[addr] > 0.","N/A","10.74180006980896","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via the constructor, which calls addPayee(account, shares_). In addPayee, there is a require(shares_ > 0, ...) and then shares[account] = shares_; payees.push(account). There are no functions that later modify payees or set shares to zero. Therefore, every address stored in payees has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"8","tx-transfer-balance-receive","True","TRUE","Function release(address) either sends the due payment to the payee if releasable(account) > 0, or, if the computed payment is 0, it still sends 1 wei to the owner (see release: the if(payment != 0) branch sends payment; the else branch sends 1 wei to owner). With all payees EOAs, these calls succeed. Since the contract balance is non-zero, there exists at least one payee for whom releasable() does not underflow; calling release for such a payee will decrease the balance either by the payment or by 1 wei (owner drain).","N/A","172.0350935459137","20000","ANSWER: TRUE\nEXPLANATION: Function release(address) either sends the due payment to the payee if releasable(account) > 0, or, if the computed payment is 0, it still sends 1 wei to the owner (see release: the if(payment != 0) branch sends payment; the else branch sends 1 wei to owner). With all payees EOAs, these calls succeed. Since the contract balance is non-zero, there exists at least one payee for whom releasable() does not underflow; calling release for such a payee will decrease the balance either by the payment or by 1 wei (owner drain).\nCOUNTEREXAMPLE: N/A"
"1","tx-transfer-balance-receive","False","FALSE","The only function that can decrease the contract balance is release, which requires payment != 0 (release: “PaymentSplitter: account is not due payment”). The payment is computed as (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (pendingPayment). Due to integer division, when balance is small relative to totalShares, every payee’s computed payment can be 0, making release impossible and leaving a non-zero “dust” balance forever.","- Deploy with two EOA payees A and B, shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (balance = 1).\n- For each payee, releasable = (1 * 1 / 2) - 0 = 0.\n- Calling release(A) or release(B) reverts with "PaymentSplitter: account is not due payment".\n- No other function decreases the balance, so the non-zero balance cannot be reduced.","42.00898599624634","20000","ANSWER: FALSE\nEXPLANATION: The only function that can decrease the contract balance is release, which requires payment != 0 (release: “PaymentSplitter: account is not due payment”). The payment is computed as (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (pendingPayment). Due to integer division, when balance is small relative to totalShares, every payee’s computed payment can be 0, making release impossible and leaving a non-zero “dust” balance forever.\nCOUNTEREXAMPLE: \n- Deploy with two EOA payees A and B, shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (balance = 1).\n- For each payee, releasable = (1 * 1 / 2) - 0 = 0.\n- Calling release(A) or release(B) reverts with "PaymentSplitter: account is not due payment".\n- No other function decreases the balance, so the non-zero balance cannot be reduced."
"6","tx-transfer-releasable-receive","True","TRUE","The public function release(address payable account) allows anyone to trigger a payment to account if releasable(account) > 0. It requires shares[account] > 0 and payment != 0, then performs (bool success, ) = account.call{value: payment}("") and requires success. If a’s receive accepts ETH, this call succeeds, transferring ETH. See functions releasable (computes due payment) and release (performs the transfer and requires success).","N/A","38.00345492362976","20000","ANSWER: TRUE\nEXPLANATION: The public function release(address payable account) allows anyone to trigger a payment to account if releasable(account) > 0. It requires shares[account] > 0 and payment != 0, then performs (bool success, ) = account.call{value: payment}("") and requires success. If a’s receive accepts ETH, this call succeeds, transferring ETH. See functions releasable (computes due payment) and release (performs the transfer and requires success).\nCOUNTEREXAMPLE: N/A"
"7","tx-transfer-releasable-receive","False","TRUE","If releasable(a) > 0, release(a) can be called, but only by a itself due to require(msg.sender == account) in release (lines requiring caller equals account). The function computes the due payment, updates accounting, and sends ETH via account.call{value: payment}("") (which will succeed if a’s receive accepts ETH). Thus a can perform a transaction that transfers ETH from the contract to a.","N/A","54.55776929855347","20000","ANSWER: TRUE\nEXPLANATION: If releasable(a) > 0, release(a) can be called, but only by a itself due to require(msg.sender == account) in release (lines requiring caller equals account). The function computes the due payment, updates accounting, and sends ETH via account.call{value: payment}("") (which will succeed if a’s receive accepts ETH). Thus a can perform a transaction that transfers ETH from the contract to a.\nCOUNTEREXAMPLE: N/A"
"9","tx-transfer-balance-receive","True","FALSE","The constructor does not require any payee to have a non-zero share (addPayee only checks for non-duplication and non-zero address). The release function requires shares[account] > 0 to proceed, so if all shares are zero, no release can ever succeed, and no other function decreases the balance. Thus, with non-zero balance and all payees being EOAs but having zero shares, the balance cannot be decreased. Relevant: constructor/addPayee (no check for shares_ > 0), release requires shares[account] > 0; else-branch (sending 1 wei to owner) is unreachable without passing this require.","1) Deploy PaymentSplitter with payees_ = [A] where A = msg.sender (EOA), shares_ = [0], and send 1 ether in the constructor call (contract balance = 1 ether).\n2) All payees are EOAs, but shares[A] = 0 and totalShares = 0.\n3) Any call to release(A) reverts at require(shares[account] > 0).\n4) No other function can decrease the balance. Therefore, despite non-zero balance and all payees being EOAs, no transaction can reduce the contract balance.","52.10583448410034","20000","ANSWER: FALSE\nEXPLANATION: The constructor does not require any payee to have a non-zero share (addPayee only checks for non-duplication and non-zero address). The release function requires shares[account] > 0 to proceed, so if all shares are zero, no release can ever succeed, and no other function decreases the balance. Thus, with non-zero balance and all payees being EOAs but having zero shares, the balance cannot be decreased. Relevant: constructor/addPayee (no check for shares_ > 0), release requires shares[account] > 0; else-branch (sending 1 wei to owner) is unreachable without passing this require.\nCOUNTEREXAMPLE: \n1) Deploy PaymentSplitter with payees_ = [A] where A = msg.sender (EOA), shares_ = [0], and send 1 ether in the constructor call (contract balance = 1 ether).\n2) All payees are EOAs, but shares[A] = 0 and totalShares = 0.\n3) Any call to release(A) reverts at require(shares[account] > 0).\n4) No other function can decrease the balance. Therefore, despite non-zero balance and all payees being EOAs, no transaction can reduce the contract balance."
