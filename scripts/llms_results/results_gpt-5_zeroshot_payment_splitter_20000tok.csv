"contract_id","property_id","ground_truth","llm_answer","llm_explanation","llm_counterexample","time","tokens","raw_output"
"1","fair-split-geq","False","TRUE","The contract enforces released[a] ≤ (address(this).balance + totalReleased) * shares[a] / totalShares at all times. Specifically:\n- totalReceived is defined as address(this).balance + totalReleased (releasable).\n- pendingPayment(account, totalReceived, released[account]) = (totalReceived * shares[account]) / totalShares - released[account].\n- release() increases released[account] exactly by releasable(account), i.e., by the non-negative difference between the allocation and alreadyReleased, and then transfers that amount. Thus after release, released[account] equals floor(totalReceived * shares[account] / totalShares).\n- On release, address(this).balance decreases by the payment while totalReleased increases by the same amount, keeping totalReceived constant; deposits only increase totalReceived. Therefore, released[account] can never exceed the computed allocation.\nRelevant code: releasable(), pendingPayment(), and release().","N/A","116.45584058761597","20000","ANSWER: TRUE\nEXPLANATION: The contract enforces released[a] ≤ (address(this).balance + totalReleased) * shares[a] / totalShares at all times. Specifically:\n- totalReceived is defined as address(this).balance + totalReleased (releasable).\n- pendingPayment(account, totalReceived, released[account]) = (totalReceived * shares[account]) / totalShares - released[account].\n- release() increases released[account] exactly by releasable(account), i.e., by the non-negative difference between the allocation and alreadyReleased, and then transfers that amount. Thus after release, released[account] equals floor(totalReceived * shares[account] / totalShares).\n- On release, address(this).balance decreases by the payment while totalReleased increases by the same amount, keeping totalReceived constant; deposits only increase totalReceived. Therefore, released[account] can never exceed the computed allocation.\nRelevant code: releasable(), pendingPayment(), and release().\nCOUNTEREXAMPLE: N/A"
"1","fair-split-geq-no-overflow","True","TRUE","The contract defines totalReceived as address(this).balance + totalReleased (releasable). For each payee a, pendingPayment computes ((totalReceived * shares[a]) / totalShares) - released[a]. The only way to increase released[a] is via release, which sets payment = pendingPayment and then updates released[a] += payment and totalReleased += payment. Since payment is never more than the computed due, released[a] never exceeds (totalReceived * shares[a]) / totalShares. Moreover, during a release, totalReceived remains constant (balance decreases by payment while totalReleased increases by the same payment), preserving the invariant.","N/A","125.50065541267395","20000","ANSWER: TRUE\nEXPLANATION: The contract defines totalReceived as address(this).balance + totalReleased (releasable). For each payee a, pendingPayment computes ((totalReceived * shares[a]) / totalShares) - released[a]. The only way to increase released[a] is via release, which sets payment = pendingPayment and then updates released[a] += payment and totalReleased += payment. Since payment is never more than the computed due, released[a] never exceeds (totalReceived * shares[a]) / totalShares. Moreover, during a release, totalReceived remains constant (balance decreases by payment while totalReleased increases by the same payment), preserving the invariant.\nCOUNTEREXAMPLE: N/A"
"1","non-zero-payees","True","TRUE","The only way entries are added to the payees array is via addPayee, called from the constructor. addPayee enforces account != ZERO_ADDRESS (require in addPayee), preventing the zero address from ever being pushed into payees. There are no other functions that modify payees after deployment.","N/A","14.69156527519226","20000","ANSWER: TRUE\nEXPLANATION: The only way entries are added to the payees array is via addPayee, called from the constructor. addPayee enforces account != ZERO_ADDRESS (require in addPayee), preventing the zero address from ever being pushed into payees. There are no other functions that modify payees after deployment.\nCOUNTEREXAMPLE: N/A"
"2","non-zero-payees","True","TRUE","The only way to insert into the payees array is via addPayee, which requires account != ZERO_ADDRESS (""""""""PaymentSplitter: account is the zero address""""""""). The constructor populates the three payees exclusively through addPayee, and there are no functions to modify payees afterward.","N/A","13.73404049873352","20000","ANSWER: TRUE\nEXPLANATION: The only way to insert into the payees array is via addPayee, which requires account != ZERO_ADDRESS (""""""""PaymentSplitter: account is the zero address""""""""). The constructor populates the three payees exclusively through addPayee, and there are no functions to modify payees afterward.\nCOUNTEREXAMPLE: N/A"
"3","non-zero-payees","True","TRUE","The constructor requires each of the three payees to be non-zero before adding them to the payees array (three separate require checks: payee1 != ZERO_ADDRESS, payee2 != ZERO_ADDRESS, payee3 != ZERO_ADDRESS). After construction, there are no functions that modify the payees array. Therefore, all addresses in payees are always non-zero.","N/A","17.48133873939514","20000","ANSWER: TRUE\nEXPLANATION: The constructor requires each of the three payees to be non-zero before adding them to the payees array (three separate require checks: payee1 != ZERO_ADDRESS, payee2 != ZERO_ADDRESS, payee3 != ZERO_ADDRESS). After construction, there are no functions that modify the payees array. Therefore, all addresses in payees are always non-zero.\nCOUNTEREXAMPLE: N/A"
"4","non-zero-payees","True","TRUE","The only way entries are added to the payees array is via addPayee, which enforces account != ZERO_ADDRESS. The constructor iterates over the provided payees_ and calls addPayee for each; there are no functions to add or modify payees afterward. Therefore, any deployed instance must have all payees non-zero.","N/A","18.12173581123352","20000","ANSWER: TRUE\nEXPLANATION: The only way entries are added to the payees array is via addPayee, which enforces account != ZERO_ADDRESS. The constructor iterates over the provided payees_ and calls addPayee for each; there are no functions to add or modify payees afterward. Therefore, any deployed instance must have all payees non-zero.\nCOUNTEREXAMPLE: N/A"
"5","non-zero-payees","True","TRUE","The only way payees are added is via the private addPayee function, which is called exclusively from the constructor. addPayee enforces that account != ZERO_ADDRESS via require (addPayee). Therefore, every element pushed into the payees array is non-zero and no other function can later modify payees.","N/A","10.349046230316162","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via the private addPayee function, which is called exclusively from the constructor. addPayee enforces that account != ZERO_ADDRESS via require (addPayee). Therefore, every element pushed into the payees array is non-zero and no other function can later modify payees.\nCOUNTEREXAMPLE: N/A"
"6","non-zero-payees","False","FALSE","The constructor calls addPayee for each provided payee. In addPayee, the zero-address check compares against a mis-set constant ZERO_ADDRESS = 0x...80 (not the true 0x0), via require(account != ZERO_ADDRESS, ...). This allows address(0) to be added to payees. See ZERO_ADDRESS definition and addPayee.","Deploy the contract with payees_ = [address(0x0)] and shares_ = [1]. The require(account != ZERO_ADDRESS) passes since ZERO_ADDRESS != address(0), so payees will contain address(0), violating the property.","14.94186282157898","20000","ANSWER: FALSE\nEXPLANATION: The constructor calls addPayee for each provided payee. In addPayee, the zero-address check compares against a mis-set constant ZERO_ADDRESS = 0x...80 (not the true 0x0), via require(account != ZERO_ADDRESS, ...). This allows address(0) to be added to payees. See ZERO_ADDRESS definition and addPayee.\nCOUNTEREXAMPLE: Deploy the contract with payees_ = [address(0x0)] and shares_ = [1]. The require(account != ZERO_ADDRESS) passes since ZERO_ADDRESS != address(0), so payees will contain address(0), violating the property."
"1","positive-shares","True","TRUE","The only way to populate the payees array is via addPayee, which is called from the constructor. addPayee enforces shares_ > 0 and pushes the account to payees only after this check. There are no functions that later modify shares or add payees (addPayee is private), so every address in payees always has shares[addr] > 0.","N/A","10.853040933609009","20000","ANSWER: TRUE\nEXPLANATION: The only way to populate the payees array is via addPayee, which is called from the constructor. addPayee enforces shares_ > 0 and pushes the account to payees only after this check. There are no functions that later modify shares or add payees (addPayee is private), so every address in payees always has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"2","positive-shares","True","TRUE","The only way payees are added is via addPayee, which is called exactly three times in the constructor. addPayee requires shares_ > 0 and sets shares[account] = shares_. No other function modifies shares or payees thereafter. Therefore every address in payees has shares[addr] > 0.","N/A","18.533000230789185","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via addPayee, which is called exactly three times in the constructor. addPayee requires shares_ > 0 and sets shares[account] = shares_. No other function modifies shares or payees thereafter. Therefore every address in payees has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"3","positive-shares","True","TRUE","In the constructor, each of the three payees is pushed into the payees array and assigned shares[payee] = 1. Duplicate or zero addresses are rejected. There are no functions that modify the payees array or the shares mapping after deployment. Therefore, for every address in payees, shares[address] remains > 0.","N/A","9.316549301147461","20000","ANSWER: TRUE\nEXPLANATION: In the constructor, each of the three payees is pushed into the payees array and assigned shares[payee] = 1. Duplicate or zero addresses are rejected. There are no functions that modify the payees array or the shares mapping after deployment. Therefore, for every address in payees, shares[address] remains > 0.\nCOUNTEREXAMPLE: N/A"
"4","positive-shares","True","TRUE","The only way to populate the payees array is via addPayee, which is called exclusively in the constructor. addPayee enforces shares_ > 0 and prevents duplicates (shares[account] == 0) and zero address. No function later modifies payees or shares. Therefore, every address in payees has shares[addr] > 0 and this remains invariant.","N/A","20.28274703025818","20000","ANSWER: TRUE\nEXPLANATION: The only way to populate the payees array is via addPayee, which is called exclusively in the constructor. addPayee enforces shares_ > 0 and prevents duplicates (shares[account] == 0) and zero address. No function later modifies payees or shares. Therefore, every address in payees has shares[addr] > 0 and this remains invariant.\nCOUNTEREXAMPLE: N/A"
"5","positive-shares","True","TRUE","The only way payees are added is via the constructor, which calls addPayee(account, shares_). In addPayee, there is a require(shares_ > 0, ...) and then shares[account] = shares_; payees.push(account). There are no functions that later modify payees or set shares to zero. Therefore, every address stored in payees has shares[addr] > 0.","N/A","10.74180006980896","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via the constructor, which calls addPayee(account, shares_). In addPayee, there is a require(shares_ > 0, ...) and then shares[account] = shares_; payees.push(account). There are no functions that later modify payees or set shares to zero. Therefore, every address stored in payees has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"8","tx-transfer-balance-receive","True","TRUE","Function release(address) either sends the due payment to the payee if releasable(account) > 0, or, if the computed payment is 0, it still sends 1 wei to the owner (see release: the if(payment != 0) branch sends payment; the else branch sends 1 wei to owner). With all payees EOAs, these calls succeed. Since the contract balance is non-zero, there exists at least one payee for whom releasable() does not underflow; calling release for such a payee will decrease the balance either by the payment or by 1 wei (owner drain).","N/A","172.0350935459137","20000","ANSWER: TRUE\nEXPLANATION: Function release(address) either sends the due payment to the payee if releasable(account) > 0, or, if the computed payment is 0, it still sends 1 wei to the owner (see release: the if(payment != 0) branch sends payment; the else branch sends 1 wei to owner). With all payees EOAs, these calls succeed. Since the contract balance is non-zero, there exists at least one payee for whom releasable() does not underflow; calling release for such a payee will decrease the balance either by the payment or by 1 wei (owner drain).\nCOUNTEREXAMPLE: N/A"
"1","tx-transfer-balance-receive","False","FALSE","The only function that can decrease the contract balance is release, which requires payment != 0 (release: “PaymentSplitter: account is not due payment”). The payment is computed as (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (pendingPayment). Due to integer division, when balance is small relative to totalShares, every payee’s computed payment can be 0, making release impossible and leaving a non-zero “dust” balance forever.","- Deploy with two EOA payees A and B, shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (balance = 1).\n- For each payee, releasable = (1 * 1 / 2) - 0 = 0.\n- Calling release(A) or release(B) reverts with """"""""PaymentSplitter: account is not due payment"""""""".\n- No other function decreases the balance, so the non-zero balance cannot be reduced.","42.00898599624634","20000","ANSWER: FALSE\nEXPLANATION: The only function that can decrease the contract balance is release, which requires payment != 0 (release: “PaymentSplitter: account is not due payment”). The payment is computed as (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (pendingPayment). Due to integer division, when balance is small relative to totalShares, every payee’s computed payment can be 0, making release impossible and leaving a non-zero “dust” balance forever.\nCOUNTEREXAMPLE: \n- Deploy with two EOA payees A and B, shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (balance = 1).\n- For each payee, releasable = (1 * 1 / 2) - 0 = 0.\n- Calling release(A) or release(B) reverts with """"""""PaymentSplitter: account is not due payment"""""""".\n- No other function decreases the balance, so the non-zero balance cannot be reduced."
"6","tx-transfer-releasable-receive","True","TRUE","The public function release(address payable account) allows anyone to trigger a payment to account if releasable(account) > 0. It requires shares[account] > 0 and payment != 0, then performs (bool success, ) = account.call{value: payment}("""""""") and requires success. If a’s receive accepts ETH, this call succeeds, transferring ETH. See functions releasable (computes due payment) and release (performs the transfer and requires success).","N/A","38.00345492362976","20000","ANSWER: TRUE\nEXPLANATION: The public function release(address payable account) allows anyone to trigger a payment to account if releasable(account) > 0. It requires shares[account] > 0 and payment != 0, then performs (bool success, ) = account.call{value: payment}("""""""") and requires success. If a’s receive accepts ETH, this call succeeds, transferring ETH. See functions releasable (computes due payment) and release (performs the transfer and requires success).\nCOUNTEREXAMPLE: N/A"
"7","tx-transfer-releasable-receive","False","TRUE","If releasable(a) > 0, release(a) can be called, but only by a itself due to require(msg.sender == account) in release (lines requiring caller equals account). The function computes the due payment, updates accounting, and sends ETH via account.call{value: payment}("""""""") (which will succeed if a’s receive accepts ETH). Thus a can perform a transaction that transfers ETH from the contract to a.","N/A","54.55776929855347","20000","ANSWER: TRUE\nEXPLANATION: If releasable(a) > 0, release(a) can be called, but only by a itself due to require(msg.sender == account) in release (lines requiring caller equals account). The function computes the due payment, updates accounting, and sends ETH via account.call{value: payment}("""""""") (which will succeed if a’s receive accepts ETH). Thus a can perform a transaction that transfers ETH from the contract to a.\nCOUNTEREXAMPLE: N/A"
"9","tx-transfer-balance-receive","True","FALSE","The constructor does not require any payee to have a non-zero share (addPayee only checks for non-duplication and non-zero address). The release function requires shares[account] > 0 to proceed, so if all shares are zero, no release can ever succeed, and no other function decreases the balance. Thus, with non-zero balance and all payees being EOAs but having zero shares, the balance cannot be decreased. Relevant: constructor/addPayee (no check for shares_ > 0), release requires shares[account] > 0; else-branch (sending 1 wei to owner) is unreachable without passing this require.","1) Deploy PaymentSplitter with payees_ = [A] where A = msg.sender (EOA), shares_ = [0], and send 1 ether in the constructor call (contract balance = 1 ether).\n2) All payees are EOAs, but shares[A] = 0 and totalShares = 0.\n3) Any call to release(A) reverts at require(shares[account] > 0).\n4) No other function can decrease the balance. Therefore, despite non-zero balance and all payees being EOAs, no transaction can reduce the contract balance.","52.10583448410034","20000","ANSWER: FALSE\nEXPLANATION: The constructor does not require any payee to have a non-zero share (addPayee only checks for non-duplication and non-zero address). The release function requires shares[account] > 0 to proceed, so if all shares are zero, no release can ever succeed, and no other function decreases the balance. Thus, with non-zero balance and all payees being EOAs but having zero shares, the balance cannot be decreased. Relevant: constructor/addPayee (no check for shares_ > 0), release requires shares[account] > 0; else-branch (sending 1 wei to owner) is unreachable without passing this require.\nCOUNTEREXAMPLE: \n1) Deploy PaymentSplitter with payees_ = [A] where A = msg.sender (EOA), shares_ = [0], and send 1 ether in the constructor call (contract balance = 1 ether).\n2) All payees are EOAs, but shares[A] = 0 and totalShares = 0.\n3) Any call to release(A) reverts at require(shares[account] > 0).\n4) No other function can decrease the balance. Therefore, despite non-zero balance and all payees being EOAs, no transaction can reduce the contract balance."
"10","fair-split-eq","True","TRUE","For any payee a (added via addPayee with shares[a] > 0 and totalShares > 0), releasable(a) computes pendingPayment(a, totalReceived, released[a]) where totalReceived = address(this).balance + totalReleased (releasable). pendingPayment returns (totalReceived * shares[a]) / totalShares - released[a]. Therefore released[a] + releasable(a) = released[a] + ((totalReceived * shares[a]) / totalShares - released[a]) = (totalReceived * shares[a]) / totalShares. This holds in all callable states due to the definitions in releasable and pendingPayment.","N/A","101.82665729522705","20000","ANSWER: TRUE\nEXPLANATION: For any payee a (added via addPayee with shares[a] > 0 and totalShares > 0), releasable(a) computes pendingPayment(a, totalReceived, released[a]) where totalReceived = address(this).balance + totalReleased (releasable). pendingPayment returns (totalReceived * shares[a]) / totalShares - released[a]. Therefore released[a] + releasable(a) = released[a] + ((totalReceived * shares[a]) / totalShares - released[a]) = (totalReceived * shares[a]) / totalShares. This holds in all callable states due to the definitions in releasable and pendingPayment.\nCOUNTEREXAMPLE: N/A"
"1","fair-split-eq","False","TRUE","By definition, releasable(account) calls pendingPayment(account, totalReceived, released[account]) with totalReceived = address(this).balance + totalReleased (see releasable and pendingPayment). pendingPayment returns (totalReceived * shares[account]) / totalShares - released[account]. Therefore, for any payee a, released[a] + releasable(a) equals (totalReceived * shares[a]) / totalShares. Constructor guarantees totalShares > 0 and shares[a] > 0 for payees.","N/A","87.59235644340515","20000","ANSWER: TRUE\nEXPLANATION: By definition, releasable(account) calls pendingPayment(account, totalReceived, released[account]) with totalReceived = address(this).balance + totalReleased (see releasable and pendingPayment). pendingPayment returns (totalReceived * shares[account]) / totalShares - released[account]. Therefore, for any payee a, released[a] + releasable(a) equals (totalReceived * shares[a]) / totalShares. Constructor guarantees totalShares > 0 and shares[a] > 0 for payees.\nCOUNTEREXAMPLE: N/A"
"2","fair-split-eq","False","TRUE","By definition, releasable(account) computes pendingPayment(account, totalReceived, released[account]) where totalReceived = address(this).balance + totalReleased (see releasable). pendingPayment returns (totalReceived * shares[account]) / totalShares - alreadyReleased (see pendingPayment). Therefore, for any payee a, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares holds algebraically. The constructor enforces payees have nonzero shares and nonzero address via addPayee, so division by totalShares is valid.","N/A","78.96849131584167","20000","ANSWER: TRUE\nEXPLANATION: By definition, releasable(account) computes pendingPayment(account, totalReceived, released[account]) where totalReceived = address(this).balance + totalReleased (see releasable). pendingPayment returns (totalReceived * shares[account]) / totalShares - alreadyReleased (see pendingPayment). Therefore, for any payee a, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares holds algebraically. The constructor enforces payees have nonzero shares and nonzero address via addPayee, so division by totalShares is valid.\nCOUNTEREXAMPLE: N/A"
"3","fair-split-eq","False","TRUE","For each payee, shares[a] is set to 1 in the constructor and totalShares becomes 3 (three payees). The function releasable(a) computes (address(this).balance + totalReleased)/3 - released[a] (via pendingPayment using PAYEES=3). Therefore, for any payee a, released[a] + releasable(a) = (address(this).balance + totalReleased)/3 = (totalReceived * shares[a]) / totalShares.","N/A","65.70598530769348","20000","ANSWER: TRUE\nEXPLANATION: For each payee, shares[a] is set to 1 in the constructor and totalShares becomes 3 (three payees). The function releasable(a) computes (address(this).balance + totalReleased)/3 - released[a] (via pendingPayment using PAYEES=3). Therefore, for any payee a, released[a] + releasable(a) = (address(this).balance + totalReleased)/3 = (totalReceived * shares[a]) / totalShares.\nCOUNTEREXAMPLE: N/A"
"4","fair-split-eq","False","TRUE","By definition in releasable (function releasable), totalReceived is computed as address(this).balance + totalReleased. Then releasable(a) returns pendingPayment(a, totalReceived, released[a]) (function pendingPayment), which is (totalReceived * shares[a]) / totalShares - released[a]. Therefore released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares for any address a (including all payees). Preconditions ensuring totalShares > 0 are enforced in the constructor/addPayee (nonzero shares).","N/A","77.37825965881348","20000","ANSWER: TRUE\nEXPLANATION: By definition in releasable (function releasable), totalReceived is computed as address(this).balance + totalReleased. Then releasable(a) returns pendingPayment(a, totalReceived, released[a]) (function pendingPayment), which is (totalReceived * shares[a]) / totalShares - released[a]. Therefore released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares for any address a (including all payees). Preconditions ensuring totalShares > 0 are enforced in the constructor/addPayee (nonzero shares).\nCOUNTEREXAMPLE: N/A"
"5","fair-split-eq","False","FALSE","The function pendingPayment divides shares by totalShares before multiplying (pendingPayment), causing integer truncation: totalReceived * (shares[a] / totalShares) - released[a]. Thus released[a] + releasable(a) equals totalReceived * (shares[a] / totalShares), not (totalReceived * shares[a]) / totalShares as in the property. See releasable (computes totalReceived as balance + totalReleased) and pendingPayment (uses the incorrect order of operations).","Deploy with two payees A and B, shares [1, 1] (totalShares = 2). Send 100 wei to the contract. For A:\n- totalReceived = 100\n- shares[A] / totalShares = 1/2 = 0 (integer division)\n- releasable(A) = 100 * 0 - 0 = 0; released[A] = 0\nLeft-hand side: released[A] + releasable(A) = 0\nRight-hand side: (totalReceived * shares[A]) / totalShares = (100 * 1) / 2 = 50\nThus 0 != 50, violating the property.","24.92226481437683","20000","ANSWER: FALSE\nEXPLANATION: The function pendingPayment divides shares by totalShares before multiplying (pendingPayment), causing integer truncation: totalReceived * (shares[a] / totalShares) - released[a]. Thus released[a] + releasable(a) equals totalReceived * (shares[a] / totalShares), not (totalReceived * shares[a]) / totalShares as in the property. See releasable (computes totalReceived as balance + totalReleased) and pendingPayment (uses the incorrect order of operations).\nCOUNTEREXAMPLE: Deploy with two payees A and B, shares [1, 1] (totalShares = 2). Send 100 wei to the contract. For A:\n- totalReceived = 100\n- shares[A] / totalShares = 1/2 = 0 (integer division)\n- releasable(A) = 100 * 0 - 0 = 0; released[A] = 0\nLeft-hand side: released[A] + releasable(A) = 0\nRight-hand side: (totalReceived * shares[A]) / totalShares = (100 * 1) / 2 = 50\nThus 0 != 50, violating the property."
"6","fair-split-eq","False","FALSE","The equality relies on releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] (pendingPayment). However, addPayee allows arbitrarily large shares. In Solidity ^0.8, the multiplication totalReceived * shares[a] in pendingPayment is performed before division and can overflow, causing releasable(a) to revert. Thus, there exist reachable states where releasable(a) is undefined, so the stated equality does not always hold for every payee.","- Deploy with payees = [A], shares = [type(uint256).max] (allowed by addPayee).\n- Send 2 wei to the contract (so totalReceived = address(this).balance + totalReleased = 2).\n- For A: totalShares = type(uint256).max, shares[A] = type(uint256).max, released[A] = 0.\n- Calling releasable(A) computes (2 * type(uint256).max) / type(uint256).max - 0 in pendingPayment, which overflows on the multiplication and reverts.\n- Hence released[A] + releasable(A) cannot be evaluated, violating the “always” property.","160.44053864479065","20000","ANSWER: FALSE\nEXPLANATION: The equality relies on releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] (pendingPayment). However, addPayee allows arbitrarily large shares. In Solidity ^0.8, the multiplication totalReceived * shares[a] in pendingPayment is performed before division and can overflow, causing releasable(a) to revert. Thus, there exist reachable states where releasable(a) is undefined, so the stated equality does not always hold for every payee.\nCOUNTEREXAMPLE: \n- Deploy with payees = [A], shares = [type(uint256).max] (allowed by addPayee).\n- Send 2 wei to the contract (so totalReceived = address(this).balance + totalReleased = 2).\n- For A: totalShares = type(uint256).max, shares[A] = type(uint256).max, released[A] = 0.\n- Calling releasable(A) computes (2 * type(uint256).max) / type(uint256).max - 0 in pendingPayment, which overflows on the multiplication and reverts.\n- Hence released[A] + releasable(A) cannot be evaluated, violating the “always” property."
"7","fair-split-eq","False","FALSE","The identity holds algebraically by construction of releasable, but it is not guaranteed to be computable for all payees. In pendingPayment (called by releasable), the multiplication (totalReceived * shares[account]) can overflow and revert (Solidity 0.8+ checked arithmetic), see pendingPayment and releasable. The constructor/addPayee imposes no upper bound on shares (addPayee only checks shares_ > 0), so a payee can have an extremely large shares value, making the product overflow once totalReceived ≥ 2, causing releasable to revert. Thus the stated equality does not always hold (the left-hand side cannot even be evaluated for that payee).","- Deploy with payees_ = [A], shares_ = [type(uint256).max].\n- Send 2 wei to the contract (totalReceived = address(this).balance + totalReleased = 2).\n- For a = A, calling releasable(A) triggers pendingPayment which computes (2 * type(uint256).max) / totalShares - released[A]; the multiplication overflows and reverts.\n- Therefore released[A] + releasable(A) cannot be evaluated, violating the “always” property.","116.87277412414551","20000","ANSWER: FALSE\nEXPLANATION: The identity holds algebraically by construction of releasable, but it is not guaranteed to be computable for all payees. In pendingPayment (called by releasable), the multiplication (totalReceived * shares[account]) can overflow and revert (Solidity 0.8+ checked arithmetic), see pendingPayment and releasable. The constructor/addPayee imposes no upper bound on shares (addPayee only checks shares_ > 0), so a payee can have an extremely large shares value, making the product overflow once totalReceived ≥ 2, causing releasable to revert. Thus the stated equality does not always hold (the left-hand side cannot even be evaluated for that payee).\nCOUNTEREXAMPLE: \n- Deploy with payees_ = [A], shares_ = [type(uint256).max].\n- Send 2 wei to the contract (totalReceived = address(this).balance + totalReleased = 2).\n- For a = A, calling releasable(A) triggers pendingPayment which computes (2 * type(uint256).max) / totalShares - released[A]; the multiplication overflows and reverts.\n- Therefore released[A] + releasable(A) cannot be evaluated, violating the “always” property."
"8","fair-split-eq","False","FALSE","The equality holds only as long as releasable(account) can be computed as (totalReceived * shares[account]) / totalShares - released[account]. However, in release(), when payment == 0 the contract sends 1 wei to owner without updating totalReleased or released (else branch), reducing address(this).balance and hence totalReceived by 1 while leaving released unchanged. This can make released[account] > floor(totalReceived * shares[account] / totalShares), so releasable(account) underflows and reverts. Thus the stated equality does not always hold for all payees. See functions releasable(), pendingPayment(), and the else branch in release().","- Deploy with payees [Owner O, Alice A], shares [1, 2] (totalShares = 3).\n- Send 3 wei to the contract.\n- Call release(O): pays 1 wei to O.\n- Call release(A): pays 2 wei to A. Now totalReleased = 3, balance = 0, released[O]=1, released[A]=2, totalReceived = 3.\n- Send 2 wei to the contract (balance = 2, totalReleased = 3, totalReceived = 5).\n- Call release(A): payment = floor(5*2/3) - 2 = 1; pays 1 wei; totalReleased = 4; balance = 1; released[A] = 3; totalReceived remains 5.\n- Call release(O): payment = floor(5*1/3) - 1 = 0; else-branch executes and transfers 1 wei to owner; totalReleased stays 4; balance becomes 0; totalReceived becomes 4.\n- Now for A: RHS = floor(4*2/3) = 2, but released[A] = 3 and releasable(A) = floor(4*2/3) - 3 = -1 (underflow → revert). Hence the property “released[A] + releasable(A) == (totalReceived * shares[A]) / totalShares” is violated (releasable(A) cannot be computed).","231.560688495636","20000","ANSWER: FALSE\nEXPLANATION: The equality holds only as long as releasable(account) can be computed as (totalReceived * shares[account]) / totalShares - released[account]. However, in release(), when payment == 0 the contract sends 1 wei to owner without updating totalReleased or released (else branch), reducing address(this).balance and hence totalReceived by 1 while leaving released unchanged. This can make released[account] > floor(totalReceived * shares[account] / totalShares), so releasable(account) underflows and reverts. Thus the stated equality does not always hold for all payees. See functions releasable(), pendingPayment(), and the else branch in release().\nCOUNTEREXAMPLE: \n- Deploy with payees [Owner O, Alice A], shares [1, 2] (totalShares = 3).\n- Send 3 wei to the contract.\n- Call release(O): pays 1 wei to O.\n- Call release(A): pays 2 wei to A. Now totalReleased = 3, balance = 0, released[O]=1, released[A]=2, totalReceived = 3.\n- Send 2 wei to the contract (balance = 2, totalReleased = 3, totalReceived = 5).\n- Call release(A): payment = floor(5*2/3) - 2 = 1; pays 1 wei; totalReleased = 4; balance = 1; released[A] = 3; totalReceived remains 5.\n- Call release(O): payment = floor(5*1/3) - 1 = 0; else-branch executes and transfers 1 wei to owner; totalReleased stays 4; balance becomes 0; totalReceived becomes 4.\n- Now for A: RHS = floor(4*2/3) = 2, but released[A] = 3 and releasable(A) = floor(4*2/3) - 3 = -1 (underflow → revert). Hence the property “released[A] + releasable(A) == (totalReceived * shares[A]) / totalShares” is violated (releasable(A) cannot be computed)."
"9","fair-split-eq","False","FALSE","The invariant relies on totalReceived = address(this).balance + totalReleased staying consistent when distributions happen. However, in release(), if payment == 0 the contract sends 1 wei to owner without updating totalReleased (see the else branch in release). This decreases address(this).balance and thus totalReceived, potentially making released[a] exceed (totalReceived * shares[a]) / totalShares. Then releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] underflows and reverts, so released[a] + releasable(a) cannot equal the right-hand side.","- Deploy with payees [owner, Bob], shares [1, 1].\n- Send 2 wei to the contract.\n- Call release(Bob): payment = (2*1)/2 - 0 = 1; after: released[Bob] = 1, totalReleased = 1, balance = 1.\n- Call release(Charlie) where Charlie has 0 shares (not a payee): payment = 0, so the else branch sends 1 wei to owner; after: balance = 0, totalReleased = 1.\n- Now for a = Bob: RHS = ((balance + totalReleased) * shares[a]) / totalShares = (0 + 1) * 1 / 2 = 0, but released[Bob] = 1. releasable(Bob) would be (1*1)/2 - 1 = 0 - 1, which underflows and reverts. Hence released[Bob] + releasable(Bob) ≠ 0, violating the property.","52.38512301445007","20000","ANSWER: FALSE\nEXPLANATION: The invariant relies on totalReceived = address(this).balance + totalReleased staying consistent when distributions happen. However, in release(), if payment == 0 the contract sends 1 wei to owner without updating totalReleased (see the else branch in release). This decreases address(this).balance and thus totalReceived, potentially making released[a] exceed (totalReceived * shares[a]) / totalShares. Then releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] underflows and reverts, so released[a] + releasable(a) cannot equal the right-hand side.\nCOUNTEREXAMPLE:\n- Deploy with payees [owner, Bob], shares [1, 1].\n- Send 2 wei to the contract.\n- Call release(Bob): payment = (2*1)/2 - 0 = 1; after: released[Bob] = 1, totalReleased = 1, balance = 1.\n- Call release(Charlie) where Charlie has 0 shares (not a payee): payment = 0, so the else branch sends 1 wei to owner; after: balance = 0, totalReleased = 1.\n- Now for a = Bob: RHS = ((balance + totalReleased) * shares[a]) / totalShares = (0 + 1) * 1 / 2 = 0, but released[Bob] = 1. releasable(Bob) would be (1*1)/2 - 1 = 0 - 1, which underflows and reverts. Hence released[Bob] + releasable(Bob) ≠ 0, violating the property."
"1","fair-split-eq-no-overflow","True","TRUE","The function releasable(account) sets totalReceived = address(this).balance + totalReleased and returns pendingPayment(account, totalReceived, released[account]) (function releasable). pendingPayment computes (totalReceived * shares[account]) / totalShares - alreadyReleased (function pendingPayment). Therefore, for any payee a: released[a] + releasable(a) = released[a] + ((totalReceived * shares[a]) / totalShares - released[a]) = (totalReceived * shares[a]) / totalShares. The release logic preserves totalReceived (address(this).balance decreases by payment while totalReleased increases by the same payment), keeping the identity valid after payouts. This holds whenever the multiplication does not overflow.","N/A","46.674492597579956","20000","ANSWER: TRUE\nEXPLANATION: The function releasable(account) sets totalReceived = address(this).balance + totalReleased and returns pendingPayment(account, totalReceived, released[account]) (function releasable). pendingPayment computes (totalReceived * shares[account]) / totalShares - alreadyReleased (function pendingPayment). Therefore, for any payee a: released[a] + releasable(a) = released[a] + ((totalReceived * shares[a]) / totalShares - released[a]) = (totalReceived * shares[a]) / totalShares. The release logic preserves totalReceived (address(this).balance decreases by payment while totalReleased increases by the same payment), keeping the identity valid after payouts. This holds whenever the multiplication does not overflow.\nCOUNTEREXAMPLE: N/A"
"2","fair-split-eq-no-overflow","True","TRUE","By definition, releasable(a) is computed as pendingPayment(account, totalReceived, released[account]) where totalReceived = address(this).balance + totalReleased (function releasable). pendingPayment returns (totalReceived * shares[account]) / totalShares - alreadyReleased. Hence, for any payee a, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares. The constructor/addPayee ensure totalShares > 0 and shares[a] > 0 for payees, and the property conditions exclude overflow.","N/A","28.70275354385376","20000","ANSWER: TRUE\nEXPLANATION: By definition, releasable(a) is computed as pendingPayment(account, totalReceived, released[account]) where totalReceived = address(this).balance + totalReleased (function releasable). pendingPayment returns (totalReceived * shares[account]) / totalShares - alreadyReleased. Hence, for any payee a, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares. The constructor/addPayee ensure totalShares > 0 and shares[a] > 0 for payees, and the property conditions exclude overflow.\nCOUNTEREXAMPLE: N/A"
"3","fair-split-eq-no-overflow","True","TRUE","Each payee gets exactly 1 share (constructor sets shares[payeeX] = 1 and increments totalShares to 3). releasable(a) computes totalReceived = address(this).balance + totalReleased and returns (totalReceived / PAYEES) - released[a] (pendingPayment). Thus, for any payee a: released[a] + releasable(a) = released[a] + (totalReceived/3 - released[a]) = totalReceived/3. Since shares[a] = 1 and totalShares = 3, (totalReceived * shares[a]) / totalShares = totalReceived/3. See: PAYEES=3, shares set in constructor, releasable(a), pendingPayment, and totalShares updates in constructor.","N/A","90.45831513404846","20000","ANSWER: TRUE\nEXPLANATION: Each payee gets exactly 1 share (constructor sets shares[payeeX] = 1 and increments totalShares to 3). releasable(a) computes totalReceived = address(this).balance + totalReleased and returns (totalReceived / PAYEES) - released[a] (pendingPayment). Thus, for any payee a: released[a] + releasable(a) = released[a] + (totalReceived/3 - released[a]) = totalReceived/3. Since shares[a] = 1 and totalShares = 3, (totalReceived * shares[a]) / totalShares = totalReceived/3. See: PAYEES=3, shares set in constructor, releasable(a), pendingPayment, and totalShares updates in constructor.\nCOUNTEREXAMPLE: N/A"
"5","fair-split-eq-no-overflow","True","FALSE","The function pendingPayment divides before multiplying: totalReceived * (shares[account] / totalShares) - alreadyReleased (see pendingPayment). This causes integer truncation, so released[a] + releasable(a) equals totalReceived * (shares[a] / totalShares), which can differ from (totalReceived * shares[a]) / totalShares.","- Deploy with payees = [A, B], shares = [1, 99].\n- Send 100 wei to the contract.\n- totalReceived = address(this).balance + totalReleased = 100 + 0 = 100.\n- For A: shares[A] = 1, totalShares = 100.\n  - Contract computes: releasable(A) = 100 * (1/100) - 0 = 0 (since 1/100 = 0 by integer division). So released[A] + releasable(A) = 0.\n  - Property RHS: (100 * 1) / 100 = 1.\n- Hence 0 != 1, violating the property without overflow.","24.443004846572876","20000","ANSWER: FALSE\nEXPLANATION: The function pendingPayment divides before multiplying: totalReceived * (shares[account] / totalShares) - alreadyReleased (see pendingPayment). This causes integer truncation, so released[a] + releasable(a) equals totalReceived * (shares[a] / totalShares), which can differ from (totalReceived * shares[a]) / totalShares.\nCOUNTEREXAMPLE: \n- Deploy with payees = [A, B], shares = [1, 99].\n- Send 100 wei to the contract.\n- totalReceived = address(this).balance + totalReleased = 100 + 0 = 100.\n- For A: shares[A] = 1, totalShares = 100.\n  - Contract computes: releasable(A) = 100 * (1/100) - 0 = 0 (since 1/100 = 0 by integer division). So released[A] + releasable(A) = 0.\n  - Property RHS: (100 * 1) / 100 = 1.\n- Hence 0 != 1, violating the property without overflow."
"6","fair-split-eq-no-overflow","True","TRUE","By definition in releasable(account), totalReceived is computed as address(this).balance + totalReleased, and pendingPayment returns (totalReceived * shares[account]) / totalShares - released[account]. Therefore, for any payee a, released[a] + releasable(a) equals (totalReceived * shares[a]) / totalShares whenever the multiplication does not overflow. See releasable and pendingPayment.","N/A","97.7842710018158","20000","ANSWER: TRUE\nEXPLANATION: By definition in releasable(account), totalReceived is computed as address(this).balance + totalReleased, and pendingPayment returns (totalReceived * shares[account]) / totalShares - released[account]. Therefore, for any payee a, released[a] + releasable(a) equals (totalReceived * shares[a]) / totalShares whenever the multiplication does not overflow. See releasable and pendingPayment.\nCOUNTEREXAMPLE: N/A"
"7","fair-split-eq-no-overflow","True","TRUE","By definition, releasable(account) computes totalReceived = address(this).balance + totalReleased and returns pendingPayment(account, totalReceived, released[account]) which equals (totalReceived * shares[account]) / totalShares - released[account] (see releasable and pendingPayment). Thus, for any payee, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares. The constructor and addPayee ensure totalShares > 0, and the property is conditioned on no overflow.","N/A","37.71979284286499","20000","ANSWER: TRUE\nEXPLANATION: By definition, releasable(account) computes totalReceived = address(this).balance + totalReleased and returns pendingPayment(account, totalReceived, released[account]) which equals (totalReceived * shares[account]) / totalShares - released[account] (see releasable and pendingPayment). Thus, for any payee, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares. The constructor and addPayee ensure totalShares > 0, and the property is conditioned on no overflow.\nCOUNTEREXAMPLE: N/A"
"10","fair-split-eq-no-overflow","True","FALSE","The equality is defined via releasable(account) = (totalReceived * shares[account]) / totalShares - released[account]. However, releasable() (and pendingPayment()) both require stateCheck() (see releasable and pendingPayment), which enforces address(this).balance + totalReleased <= MAX_RECEIVED (see stateCheck). If ETH is force-sent via selfdestruct so that address(this).balance + totalReleased > MAX_RECEIVED, releasable() reverts even though the arithmetic on the RHS does not overflow. Thus the stated equality cannot hold in all reachable states.","- Deploy PaymentSplitter with payees [A, B] and shares [1, 1].\n- Deploy an attacker contract:\n  contract Force {\n      function boom(address payable target) external payable { selfdestruct(target); }\n  }\n- Call Force.boom{value: MAX_RECEIVED + 1}(payable(address(splitter))) to force-send ETH.\n- Now totalReceived = address(splitter).balance + totalReleased = MAX_RECEIVED + 1, which does not overflow.\n- Call splitter.releasable(A) -> it reverts due to require(stateCheck()) in releasable, so released[A] + releasable(A) cannot equal (totalReceived * shares[A]) / totalShares.","82.80192160606384","20000","ANSWER: FALSE\nEXPLANATION: The equality is defined via releasable(account) = (totalReceived * shares[account]) / totalShares - released[account]. However, releasable() (and pendingPayment()) both require stateCheck() (see releasable and pendingPayment), which enforces address(this).balance + totalReleased <= MAX_RECEIVED (see stateCheck). If ETH is force-sent via selfdestruct so that address(this).balance + totalReleased > MAX_RECEIVED, releasable() reverts even though the arithmetic on the RHS does not overflow. Thus the stated equality cannot hold in all reachable states.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with payees [A, B] and shares [1, 1].\n- Deploy an attacker contract:\n  contract Force {\n      function boom(address payable target) external payable { selfdestruct(target); }\n  }\n- Call Force.boom{value: MAX_RECEIVED + 1}(payable(address(splitter))) to force-send ETH.\n- Now totalReceived = address(splitter).balance + totalReleased = MAX_RECEIVED + 1, which does not overflow.\n- Call splitter.releasable(A) -> it reverts due to require(stateCheck()) in releasable, so released[A] + releasable(A) cannot equal (totalReceived * shares[A]) / totalShares."
"4","fair-split-eq-no-overflow","False","TRUE","In releasable(account), totalReceived is defined as address(this).balance + totalReleased, and the function returns pendingPayment(account, totalReceived, released[account]) which is (totalReceived * shares[account]) / totalShares - released[account] (see releasable and pendingPayment). Therefore, for any payee (shares[a] > 0), released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares, matching the stated property whenever the arithmetic does not overflow.","N/A","51.69570755958557","20000","ANSWER: TRUE\nEXPLANATION: In releasable(account), totalReceived is defined as address(this).balance + totalReleased, and the function returns pendingPayment(account, totalReceived, released[account]) which is (totalReceived * shares[account]) / totalShares - released[account] (see releasable and pendingPayment). Therefore, for any payee (shares[a] > 0), released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares, matching the stated property whenever the arithmetic does not overflow.\nCOUNTEREXAMPLE: N/A"
"8","fair-split-eq-no-overflow","False","FALSE","The function releasable(account) defines totalReceived as address(this).balance + totalReleased and computes pendingPayment as (totalReceived * shares[account]) / totalShares - released[account]. However, the release function’s else-branch sends 1 wei to owner when payment == 0 without updating totalReleased. This decreases address(this).balance (hence totalReceived) while keeping released unchanged, breaking the invariant. Consequently, there exist reachable states where released[a] > (totalReceived * shares[a]) / totalShares, making the equality fail and releasable(a) underflow/revert. See release (else branch sending 1 wei to owner) and pendingPayment.","- Deploy with payees [A (owner), B] and shares [2, 1] (totalShares = 3).\n- Send 2 wei to the contract.\n- Call release(A): totalReceived = 2; payment = floor(2*2/3) - 0 = 1. State after: released[A] = 1, totalReleased = 1, balance = 1.\n- Call release(B): totalReceived = balance + totalReleased = 1 + 1 = 2; payment = floor(2*1/3) - 0 = 0 ⇒ else-branch sends 1 wei to owner. State after: balance = 0, totalReleased = 1, released[B] = 0.\n- Now for a = A: totalReceived = 0 + 1 = 1; RHS = floor(1*2/3) = 0, but released[A] = 1. Therefore released[A] + releasable(A) cannot equal 0; in fact releasable(A) attempts to compute floor(1*2/3) - 1 = -1 and reverts. Hence the stated equality does not hold.","192.28954434394836","20000","ANSWER: FALSE\nEXPLANATION: The function releasable(account) defines totalReceived as address(this).balance + totalReleased and computes pendingPayment as (totalReceived * shares[account]) / totalShares - released[account]. However, the release function’s else-branch sends 1 wei to owner when payment == 0 without updating totalReleased. This decreases address(this).balance (hence totalReceived) while keeping released unchanged, breaking the invariant. Consequently, there exist reachable states where released[a] > (totalReceived * shares[a]) / totalShares, making the equality fail and releasable(a) underflow/revert. See release (else branch sending 1 wei to owner) and pendingPayment.\nCOUNTEREXAMPLE: \n- Deploy with payees [A (owner), B] and shares [2, 1] (totalShares = 3).\n- Send 2 wei to the contract.\n- Call release(A): totalReceived = 2; payment = floor(2*2/3) - 0 = 1. State after: released[A] = 1, totalReleased = 1, balance = 1.\n- Call release(B): totalReceived = balance + totalReleased = 1 + 1 = 2; payment = floor(2*1/3) - 0 = 0 ⇒ else-branch sends 1 wei to owner. State after: balance = 0, totalReleased = 1, released[B] = 0.\n- Now for a = A: totalReceived = 0 + 1 = 1; RHS = floor(1*2/3) = 0, but released[A] = 1. Therefore released[A] + releasable(A) cannot equal 0; in fact releasable(A) attempts to compute floor(1*2/3) - 1 = -1 and reverts. Hence the stated equality does not hold."
"9","fair-split-eq-no-overflow","False","FALSE","The equality is algebraically enforced by releasable() (which computes (balance + totalReleased) * shares[a] / totalShares − released[a]), but release() has a nonstandard else branch that, when payment == 0, sends 1 wei to owner without updating totalReleased (see release()’s else branch). This reduces totalReceived = balance + totalReleased and can make released[a] exceed (totalReceived * shares[a]) / totalShares. Then pendingPayment underflows and releasable(a) reverts, so released[a] + releasable(a) is undefined while the RHS is well-defined, violating the property. Relevant code: releasable(), pendingPayment(), and the else branch in release().","- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract. Now balance = 2, totalReleased = 0, totalReceived = 2.\n- Call release(A): payment = (2*1)/2 − 0 = 1. After: released[A] = 1, totalReleased = 1, balance = 1, totalReceived = 2.\n- Call release(A) again: payment = (2*1)/2 − 1 = 0, so the else branch sends 1 wei to owner. After: released[A] = 1, totalReleased = 1, balance = 0, totalReceived = 1.\n- Now for A: RHS = (1*1)/2 = 0 (no overflow). But releasable(A) = (1*1)/2 − 1 underflows and reverts, so released[A] + releasable(A) is not a value. Hence the stated equality does not hold for every payee.","153.98778700828552","20000","ANSWER: FALSE\nEXPLANATION: The equality is algebraically enforced by releasable() (which computes (balance + totalReleased) * shares[a] / totalShares − released[a]), but release() has a nonstandard else branch that, when payment == 0, sends 1 wei to owner without updating totalReleased (see release()’s else branch). This reduces totalReceived = balance + totalReleased and can make released[a] exceed (totalReceived * shares[a]) / totalShares. Then pendingPayment underflows and releasable(a) reverts, so released[a] + releasable(a) is undefined while the RHS is well-defined, violating the property. Relevant code: releasable(), pendingPayment(), and the else branch in release().\nCOUNTEREXAMPLE:\n- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract. Now balance = 2, totalReleased = 0, totalReceived = 2.\n- Call release(A): payment = (2*1)/2 − 0 = 1. After: released[A] = 1, totalReleased = 1, balance = 1, totalReceived = 2.\n- Call release(A) again: payment = (2*1)/2 − 1 = 0, so the else branch sends 1 wei to owner. After: released[A] = 1, totalReleased = 1, balance = 0, totalReceived = 1.\n- Now for A: RHS = (1*1)/2 = 0 (no overflow). But releasable(A) = (1*1)/2 − 1 underflows and reverts, so released[A] + releasable(A) is not a value. Hence the stated equality does not hold for every payee."
"10","fair-split-geq","True","TRUE","The only way released[a] increases is via release(account), which sets payment = (address(this).balance + totalReleased) * shares[a] / totalShares - released[a] (via releasable -> pendingPayment) and then does released[a] += payment and totalReleased += payment. A release preserves address(this).balance + totalReleased, so released[a] becomes exactly the current floor entitlement and never exceeds it. Since totalReceived can only stay the same (on releases) or increase (on deposits), the invariant (totalReceived * shares[a]) / totalShares >= released[a] always holds for every payee. Relevant functions: release, releasable, pendingPayment.","N/A","76.6989266872406","20000","ANSWER: TRUE\nEXPLANATION: The only way released[a] increases is via release(account), which sets payment = (address(this).balance + totalReleased) * shares[a] / totalShares - released[a] (via releasable -> pendingPayment) and then does released[a] += payment and totalReleased += payment. A release preserves address(this).balance + totalReleased, so released[a] becomes exactly the current floor entitlement and never exceeds it. Since totalReceived can only stay the same (on releases) or increase (on deposits), the invariant (totalReceived * shares[a]) / totalShares >= released[a] always holds for every payee. Relevant functions: release, releasable, pendingPayment.\nCOUNTEREXAMPLE: N/A"
"2","fair-split-geq","False","TRUE","The only way released[a] changes is via release(), which increases released[a] by releasable(a). releasable(a) is defined as pendingPayment(a, totalReceived, released[a]) where totalReceived = address(this).balance + totalReleased and pendingPayment returns (totalReceived * shares[a]) / totalShares - released[a]. Thus after any call to release(), released[a] becomes at most floor((totalReceived * shares[a]) / totalShares). No other function modifies released[a] or totalShares/shares[a]. Reentrancy cannot violate this because the increase in totalReleased is exactly offset by the decrease in balance during value transfer, keeping totalReceived consistent.","N/A","112.17759108543396","20000","ANSWER: TRUE\nEXPLANATION: The only way released[a] changes is via release(), which increases released[a] by releasable(a). releasable(a) is defined as pendingPayment(a, totalReceived, released[a]) where totalReceived = address(this).balance + totalReleased and pendingPayment returns (totalReceived * shares[a]) / totalShares - released[a]. Thus after any call to release(), released[a] becomes at most floor((totalReceived * shares[a]) / totalShares). No other function modifies released[a] or totalShares/shares[a]. Reentrancy cannot violate this because the increase in totalReleased is exactly offset by the decrease in balance during value transfer, keeping totalReceived consistent.\nCOUNTEREXAMPLE: N/A"
"3","fair-split-geq","False","TRUE","Each payee gets exactly 1 share and totalShares is set to 3 in the constructor. releasable(account) computes payment as (address(this).balance + totalReleased)/3 - released[account] (see releasable and pendingPayment), and release updates released[account] by at most this amount. Thus, after any sequence of operations, released[a] ≤ floor((address(this).balance + totalReleased)/3) = floor(totalReceived/3). Since shares[a] = 1 and totalShares = 3, the property (totalReceived * shares[a]) / totalShares ≥ released[a] holds for every payee at all times. Moreover, totalReceived = balance + totalReleased is non-decreasing (sending ETH increases totalReleased while decreasing balance by the same amount), preserving the invariant.","N/A","91.07583022117615","20000","ANSWER: TRUE\nEXPLANATION: Each payee gets exactly 1 share and totalShares is set to 3 in the constructor. releasable(account) computes payment as (address(this).balance + totalReleased)/3 - released[account] (see releasable and pendingPayment), and release updates released[account] by at most this amount. Thus, after any sequence of operations, released[a] ≤ floor((address(this).balance + totalReleased)/3) = floor(totalReceived/3). Since shares[a] = 1 and totalShares = 3, the property (totalReceived * shares[a]) / totalShares ≥ released[a] holds for every payee at all times. Moreover, totalReceived = balance + totalReleased is non-decreasing (sending ETH increases totalReleased while decreasing balance by the same amount), preserving the invariant.\nCOUNTEREXAMPLE: N/A"
"4","fair-split-geq","False","FALSE","The invariant relies on totalReceived = address(this).balance + totalReleased (releasable) and on released[account] being increased by at most the account’s pro-rata share. However, in release the contract:\n- updates totalReleased and released[account] in an unchecked block (unchecked { totalReleased += payment; released[account] += payment; })\n- ignores the result of the value transfer (account.call{value: payment}(""""""""))\nThis lets an attacker repeatedly call release for a payee whose fallback reverts, so the transfer always fails but totalReleased and released[payee] still increase while balance stays unchanged. Repeating this can grow totalReleased without bound and, due to unchecked addition, eventually overflow uint256. When totalReleased overflows, totalReceived wraps to a small value while some other payee’s released remains large, violating (totalReceived * shares[a]) / totalShares >= released[a].","- Setup: Deploy with payees [A, B], shares [1, 1], and initial ETH (e.g., 2 wei). Let A be a contract whose fallback reverts on receiving ETH.\n- Step 1: Call release(A) repeatedly. Each time, payment = (address(this).balance + totalReleased)/2 - released[A]. The external call to A fails, but unchecked { totalReleased += payment; released[A] += payment; } executes, so totalReleased grows while balance stays constant. Repeat until totalReleased is just below 2^256 (no overflow yet).\n- Step 2: Call release(B) once. This sets released[B] to X = floor((address(this).balance + totalReleased)/2), a very large number, and increases totalReleased accordingly (still below 2^256 because of the choice in Step 1).\n- Step 3: Call release(A) once more. The unchecked addition totalReleased += payment overflows, wrapping totalReleased to a small value Y. The call again fails, so balance remains unchanged.\n- Result: Now totalReceived = address(this).balance + totalReleased ≈ address(this).balance + Y is small, hence (totalReceived * shares[B]) / totalShares = floor(totalReceived / 2) is small, but released[B] = X is huge from Step 2. Therefore, (totalReceived * shares[B]) / totalShares < released[B], violating the property.","235.2142789363861","20000","ANSWER: FALSE\nEXPLANATION: The invariant relies on totalReceived = address(this).balance + totalReleased (releasable) and on released[account] being increased by at most the account’s pro-rata share. However, in release the contract:\n- updates totalReleased and released[account] in an unchecked block (unchecked { totalReleased += payment; released[account] += payment; })\n- ignores the result of the value transfer (account.call{value: payment}(""""""""))\nThis lets an attacker repeatedly call release for a payee whose fallback reverts, so the transfer always fails but totalReleased and released[payee] still increase while balance stays unchanged. Repeating this can grow totalReleased without bound and, due to unchecked addition, eventually overflow uint256. When totalReleased overflows, totalReceived wraps to a small value while some other payee’s released remains large, violating (totalReceived * shares[a]) / totalShares >= released[a].\nCOUNTEREXAMPLE: \n- Setup: Deploy with payees [A, B], shares [1, 1], and initial ETH (e.g., 2 wei). Let A be a contract whose fallback reverts on receiving ETH.\n- Step 1: Call release(A) repeatedly. Each time, payment = (address(this).balance + totalReleased)/2 - released[A]. The external call to A fails, but unchecked { totalReleased += payment; released[A] += payment; } executes, so totalReleased grows while balance stays constant. Repeat until totalReleased is just below 2^256 (no overflow yet).\n- Step 2: Call release(B) once. This sets released[B] to X = floor((address(this).balance + totalReleased)/2), a very large number, and increases totalReleased accordingly (still below 2^256 because of the choice in Step 1).\n- Step 3: Call release(A) once more. The unchecked addition totalReleased += payment overflows, wrapping totalReleased to a small value Y. The call again fails, so balance remains unchanged.\n- Result: Now totalReceived = address(this).balance + totalReleased ≈ address(this).balance + Y is small, hence (totalReceived * shares[B]) / totalShares = floor(totalReceived / 2) is small, but released[B] = X is huge from Step 2. Therefore, (totalReceived * shares[B]) / totalShares < released[B], violating the property."
"5","fair-split-geq","False","TRUE","totalReceived is computed as address(this).balance + totalReleased (releasable). The only way released[a] can increase is via release, which uses payment = releasable(account) and pendingPayment. Because pendingPayment divides first (totalReceived * (shares[a] / totalShares) - released[a]), when there are multiple payees shares[a] / totalShares = 0, so payment is 0 and released[a] stays 0, trivially satisfying (totalReceived * shares[a]) / totalShares ≥ released[a]. With a single payee, shares[a] = totalShares so payment = totalReceived - released[a], ensuring released[a] ≤ totalReceived. State is updated before the external call and reverts on failure, keeping the invariant intact.","N/A","84.29706168174744","20000","ANSWER: TRUE\nEXPLANATION: totalReceived is computed as address(this).balance + totalReleased (releasable). The only way released[a] can increase is via release, which uses payment = releasable(account) and pendingPayment. Because pendingPayment divides first (totalReceived * (shares[a] / totalShares) - released[a]), when there are multiple payees shares[a] / totalShares = 0, so payment is 0 and released[a] stays 0, trivially satisfying (totalReceived * shares[a]) / totalShares ≥ released[a]. With a single payee, shares[a] = totalShares so payment = totalReceived - released[a], ensuring released[a] ≤ totalReceived. State is updated before the external call and reverts on failure, keeping the invariant intact.\nCOUNTEREXAMPLE: N/A"
"6","fair-split-geq","False","TRUE","The invariant follows directly from how payments are computed and recorded. In releasable(account) the contract computes pendingPayment as (totalReceived * shares[account]) / totalShares - released[account] (functions releasable and pendingPayment). In release, it then increases released[account] by exactly this amount and increases totalReleased by the same amount, so after any release we have released[account] = floor(totalReceived * shares[account] / totalShares) at that moment, and never more. Since totalReceived is defined as address(this).balance + totalReleased, releasing funds keeps totalReceived constant (balance decreases while totalReleased increases by the same amount), preserving the inequality at all times, including under reentrancy.","N/A","71.37700653076172","20000","ANSWER: TRUE\nEXPLANATION: The invariant follows directly from how payments are computed and recorded. In releasable(account) the contract computes pendingPayment as (totalReceived * shares[account]) / totalShares - released[account] (functions releasable and pendingPayment). In release, it then increases released[account] by exactly this amount and increases totalReleased by the same amount, so after any release we have released[account] = floor(totalReceived * shares[account] / totalShares) at that moment, and never more. Since totalReceived is defined as address(this).balance + totalReleased, releasing funds keeps totalReceived constant (balance decreases while totalReleased increases by the same amount), preserving the inequality at all times, including under reentrancy.\nCOUNTEREXAMPLE: N/A"
"7","fair-split-geq","False","TRUE","The invariant follows from how payments are computed and state is updated. pendingPayment(account, R, released[a]) returns (R * shares[a]) / totalShares − released[a], where R = address(this).balance + totalReleased (releasable). release only pays when this value is > 0 and then does:\n- totalReleased += payment and released[a] += payment (release),\n- sends exactly payment out, so address(this).balance decreases by payment.\nThus R remains unchanged during a release, making released[a] become exactly floor(R * shares[a] / totalShares). Deposits only increase R, so the LHS cannot decrease below released[a]. Constructor/addPayee ensure totalShares > 0 and shares[a] > 0, preventing division by zero and non-payees receiving shares.","N/A","48.05093789100647","20000","ANSWER: TRUE\nEXPLANATION: The invariant follows from how payments are computed and state is updated. pendingPayment(account, R, released[a]) returns (R * shares[a]) / totalShares − released[a], where R = address(this).balance + totalReleased (releasable). release only pays when this value is > 0 and then does:\n- totalReleased += payment and released[a] += payment (release),\n- sends exactly payment out, so address(this).balance decreases by payment.\nThus R remains unchanged during a release, making released[a] become exactly floor(R * shares[a] / totalShares). Deposits only increase R, so the LHS cannot decrease below released[a]. Constructor/addPayee ensure totalShares > 0 and shares[a] > 0, preventing division by zero and non-payees receiving shares.\nCOUNTEREXAMPLE: N/A"
"8","fair-split-geq","False","FALSE","The property depends on totalReceived = address(this).balance + totalReleased (releasable). In release, when payment == 0, the contract transfers 1 wei to owner without updating released[...] or totalReleased. This reduces address(this).balance and thus totalReceived, potentially making released[a] exceed (totalReceived * shares[a]) / totalShares.","- Setup: Deploy with payees [owner (msg.sender), Bob] and shares [1, 1]. totalShares = 2.\n- Fund: Send 2 wei to the contract.\n- Step 1: Call release(Bob). Payment = ( (2) * 1 ) / 2 - 0 = 1 wei. After execution: released[Bob] = 1, totalReleased = 1, contract balance = 1.\n- Step 2: Call release(Bob) again. Now payment = ( (balance + totalReleased) * 1 ) / 2 - released[Bob] = ( (1 + 1) * 1 ) / 2 - 1 = 0, so the else branch executes and sends 1 wei to owner. After this: contract balance = 0, totalReleased = 1 (unchanged), totalReceived = balance + totalReleased = 1.\n- Check: Bob’s entitlement = (1 * 1) / 2 = 0, but released[Bob] = 1. Thus (totalReceived * shares[Bob]) / totalShares < released[Bob], violating the property.","38.07414674758911","20000","ANSWER: FALSE\nEXPLANATION: The property depends on totalReceived = address(this).balance + totalReleased (releasable). In release, when payment == 0, the contract transfers 1 wei to owner without updating released[...] or totalReleased. This reduces address(this).balance and thus totalReceived, potentially making released[a] exceed (totalReceived * shares[a]) / totalShares.\nCOUNTEREXAMPLE: \n- Setup: Deploy with payees [owner (msg.sender), Bob] and shares [1, 1]. totalShares = 2.\n- Fund: Send 2 wei to the contract.\n- Step 1: Call release(Bob). Payment = ( (2) * 1 ) / 2 - 0 = 1 wei. After execution: released[Bob] = 1, totalReleased = 1, contract balance = 1.\n- Step 2: Call release(Bob) again. Now payment = ( (balance + totalReleased) * 1 ) / 2 - released[Bob] = ( (1 + 1) * 1 ) / 2 - 1 = 0, so the else branch executes and sends 1 wei to owner. After this: contract balance = 0, totalReleased = 1 (unchanged), totalReceived = balance + totalReleased = 1.\n- Check: Bob’s entitlement = (1 * 1) / 2 = 0, but released[Bob] = 1. Thus (totalReceived * shares[Bob]) / totalShares < released[Bob], violating the property."
"9","fair-split-geq","False","FALSE","The function release has an else branch that, when payment == 0, sends 1 wei to owner without increasing totalReleased (see release: the else branch with owner.call{value: 1}(""""""""). This decreases address(this).balance while leaving totalReleased unchanged, so totalReceived = balance + totalReleased decreases. Since released[a] does not decrease, the ratio (totalReceived * shares[a]) / totalShares can become less than released[a], violating the property. releasable defines totalReceived as address(this).balance + totalReleased and pendingPayment computes the ratio used in the property.","- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract.\n- Call release(A): payment = floor((2 * 1)/2) - 0 = 1. After execution: totalReleased = 1, released[A] = 1, balance = 1, totalReceived = 1 + 1 = 2.\n- Call release(C) where C is not a payee (shares[C] = 0): payment = 0, so the else branch executes and transfers 1 wei to owner. Now balance = 0, totalReleased = 1, hence totalReceived = 0 + 1 = 1.\n- For payee A: (totalReceived * shares[A]) / totalShares = floor(1 * 1 / 2) = 0 < released[A] = 1. Property violated.","41.51250600814819","20000","ANSWER: FALSE\nEXPLANATION: The function release has an else branch that, when payment == 0, sends 1 wei to owner without increasing totalReleased (see release: the else branch with owner.call{value: 1}(""""""""). This decreases address(this).balance while leaving totalReleased unchanged, so totalReceived = balance + totalReleased decreases. Since released[a] does not decrease, the ratio (totalReceived * shares[a]) / totalShares can become less than released[a], violating the property. releasable defines totalReceived as address(this).balance + totalReleased and pendingPayment computes the ratio used in the property.\nCOUNTEREXAMPLE: \n- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract.\n- Call release(A): payment = floor((2 * 1)/2) - 0 = 1. After execution: totalReleased = 1, released[A] = 1, balance = 1, totalReceived = 1 + 1 = 2.\n- Call release(C) where C is not a payee (shares[C] = 0): payment = 0, so the else branch executes and transfers 1 wei to owner. Now balance = 0, totalReleased = 1, hence totalReceived = 0 + 1 = 1.\n- For payee A: (totalReceived * shares[A]) / totalShares = floor(1 * 1 / 2) = 0 < released[A] = 1. Property violated."
"2","fair-split-geq-no-overflow","True","TRUE","The invariant released[a] <= (address(this).balance + totalReleased) * shares[a] / totalShares holds:\n- totalShares > 0 is guaranteed by the constructor calling addPayee three times with shares_ > 0 (constructor, addPayee).\n- releasable(account) = ((balance + totalReleased) * shares[account]) / totalShares - released[account] (releasable, pendingPayment).\n- release updates totalReleased and released[account] by exactly “payment = releasable(account)” before transferring, so after release we have released[account] equal to its due share, not exceeding it (release).\n- The only way released[...] changes is via release, hence released never exceeds the due amount. Reentrancy cannot break this because state is updated before the external call, and balance reduction is offset by the increase in totalReleased, keeping totalReceived constant during the call.","N/A","60.96653866767883","20000","ANSWER: TRUE\nEXPLANATION: The invariant released[a] <= (address(this).balance + totalReleased) * shares[a] / totalShares holds:\n- totalShares > 0 is guaranteed by the constructor calling addPayee three times with shares_ > 0 (constructor, addPayee).\n- releasable(account) = ((balance + totalReleased) * shares[account]) / totalShares - released[account] (releasable, pendingPayment).\n- release updates totalReleased and released[account] by exactly “payment = releasable(account)” before transferring, so after release we have released[account] equal to its due share, not exceeding it (release).\n- The only way released[...] changes is via release, hence released never exceeds the due amount. Reentrancy cannot break this because state is updated before the external call, and balance reduction is offset by the increase in totalReleased, keeping totalReceived constant during the call.\nCOUNTEREXAMPLE: N/A"
"3","fair-split-geq-no-overflow","True","TRUE","Each payee gets exactly 1 share out of 3 (constructor sets shares[payeeX] = 1 and totalShares += 1 three times). releasable(account) = (address(this).balance + totalReleased)/3 - released[account] (releasable and pendingPayment), and release only increases released[account] by that non-negative amount (release). Thus at all times released[a] ≤ floor((address(this).balance + totalReleased) / 3) = (totalReceived * shares[a]) / totalShares. During a payout, totalReceived remains constant (balance decreases, totalReleased increases by the same amount), preventing over-release.","N/A","44.101539850234985","20000","ANSWER: TRUE\nEXPLANATION: Each payee gets exactly 1 share out of 3 (constructor sets shares[payeeX] = 1 and totalShares += 1 three times). releasable(account) = (address(this).balance + totalReleased)/3 - released[account] (releasable and pendingPayment), and release only increases released[account] by that non-negative amount (release). Thus at all times released[a] ≤ floor((address(this).balance + totalReleased) / 3) = (totalReceived * shares[a]) / totalShares. During a payout, totalReceived remains constant (balance decreases, totalReleased increases by the same amount), preventing over-release.\nCOUNTEREXAMPLE: N/A"
"5","fair-split-geq-no-overflow","True","TRUE","The only way released[a] increases is via release(), which pays exactly releasable(a). Due to the bug in pendingPayment (totalReceived * (shares[a] / totalShares) - alreadyReleased), for any payee with shares[a] < totalShares the quotient is 0, so releasable(a) is 0 and release() cannot increase released[a] (require(payment != 0) in release). Thus released[a] stays 0 ≤ (totalReceived * shares[a]) / totalShares. In the only case where shares[a] == totalShares (single payee), releasable(a) equals totalReceived - released[a], so released[a] can grow at most to totalReceived, i.e., equals (totalReceived * shares[a]) / totalShares. Therefore, for every payee a, (totalReceived * shares[a]) / totalShares ≥ released[a] always holds.","N/A","59.812567472457886","20000","ANSWER: TRUE\nEXPLANATION: The only way released[a] increases is via release(), which pays exactly releasable(a). Due to the bug in pendingPayment (totalReceived * (shares[a] / totalShares) - alreadyReleased), for any payee with shares[a] < totalShares the quotient is 0, so releasable(a) is 0 and release() cannot increase released[a] (require(payment != 0) in release). Thus released[a] stays 0 ≤ (totalReceived * shares[a]) / totalShares. In the only case where shares[a] == totalShares (single payee), releasable(a) equals totalReceived - released[a], so released[a] can grow at most to totalReceived, i.e., equals (totalReceived * shares[a]) / totalShares. Therefore, for every payee a, (totalReceived * shares[a]) / totalShares ≥ released[a] always holds.\nCOUNTEREXAMPLE: N/A"
"6","fair-split-geq-no-overflow","True","TRUE","The contract maintains the invariant via releasable and release. releasable(account) sets totalReceived = address(this).balance + totalReleased and computes pendingPayment(account, totalReceived, released[account]) (see releasable and pendingPayment). release then sets totalReleased += payment and released[account] += payment before transferring (see release). Because the transfer decreases balance by exactly payment while totalReleased increases by payment, totalReceived remains constant during a release, making released[account] become exactly floor((totalReceived * shares[account]) / totalShares). Deposits only increase totalReceived and never decrease released[account], so for every payee a, released[a] ≤ (totalReceived * shares[a]) / totalShares whenever the expression does not overflow. totalShares > 0 is guaranteed by the constructor/addPayee checks.","N/A","53.5813353061676","20000","ANSWER: TRUE\nEXPLANATION: The contract maintains the invariant via releasable and release. releasable(account) sets totalReceived = address(this).balance + totalReleased and computes pendingPayment(account, totalReceived, released[account]) (see releasable and pendingPayment). release then sets totalReleased += payment and released[account] += payment before transferring (see release). Because the transfer decreases balance by exactly payment while totalReleased increases by payment, totalReceived remains constant during a release, making released[account] become exactly floor((totalReceived * shares[account]) / totalShares). Deposits only increase totalReceived and never decrease released[account], so for every payee a, released[a] ≤ (totalReceived * shares[a]) / totalShares whenever the expression does not overflow. totalShares > 0 is guaranteed by the constructor/addPayee checks.\nCOUNTEREXAMPLE: N/A"
"7","fair-split-geq-no-overflow","True","TRUE","The function releasable(account) computes entitlement as (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (releasable and pendingPayment). The release function requires releasable(account) > 0, then sets released[account] += payment and totalReleased += payment before making the external call, ensuring released[account] never exceeds (address(this).balance + totalReleased) * shares[account] / totalShares. Because Solidity 0.8 reverts on overflow, the multiplication in pendingPayment cannot silently overflow; thus the inequality holds whenever the expression does not overflow.","N/A","90.86666536331177","20000","ANSWER: TRUE\nEXPLANATION: The function releasable(account) computes entitlement as (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (releasable and pendingPayment). The release function requires releasable(account) > 0, then sets released[account] += payment and totalReleased += payment before making the external call, ensuring released[account] never exceeds (address(this).balance + totalReleased) * shares[account] / totalShares. Because Solidity 0.8 reverts on overflow, the multiplication in pendingPayment cannot silently overflow; thus the inequality holds whenever the expression does not overflow.\nCOUNTEREXAMPLE: N/A"
"10","fair-split-geq-no-overflow","True","TRUE","The contract maintains the invariant that for each payee a, released[a] never exceeds floor((address(this).balance + totalReleased) * shares[a] / totalShares). Specifically, release() computes payment = releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] (via pendingPayment), then updates totalReleased and released[a] by exactly payment before transferring funds. Thus released[a] becomes at most floor(totalReceived * shares[a] / totalShares). Reentrancy does not violate this because totalReceived is defined as balance + totalReleased and remains consistent across the value transfer. MAX_RECEIVED and the shares bound ensure the expression does not overflow in reachable states.","N/A","112.63163590431213","20000","ANSWER: TRUE\nEXPLANATION: The contract maintains the invariant that for each payee a, released[a] never exceeds floor((address(this).balance + totalReleased) * shares[a] / totalShares). Specifically, release() computes payment = releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] (via pendingPayment), then updates totalReleased and released[a] by exactly payment before transferring funds. Thus released[a] becomes at most floor(totalReceived * shares[a] / totalShares). Reentrancy does not violate this because totalReceived is defined as balance + totalReleased and remains consistent across the value transfer. MAX_RECEIVED and the shares bound ensure the expression does not overflow in reachable states.\nCOUNTEREXAMPLE: N/A"
"4","fair-split-geq-no-overflow","False","PARSE_ERROR","","N/A","284.85920333862305","20000",""
"8","fair-split-geq-no-overflow","False","FALSE","The function release has an else branch that, when releasable(account) == 0, sends 1 wei to owner without updating totalReleased or any released[payee]. See release: when payment == 0 it executes owner.call{value: 1}(""""""""). Since totalReceived is defined as address(this).balance + totalReleased (see releasable), this decreases totalReceived while leaving released[a] unchanged, allowing released[a] to become greater than (totalReceived * shares[a]) / totalShares.","- Deploy with payees [A, B] and shares [1, 2], where A is the owner (payees_[0] == msg.sender).\n- Send 2 wei to the contract.\n- Call release(B): payment = floor((2 * 2) / 3) = 1; released[B] = 1; totalReleased = 1; balance becomes 1; totalReceived stays 2.\n- Call release(A): payment = floor((2 * 1) / 3) - released[A] = 0 - 0 = 0, so the else branch sends 1 wei to owner. Now balance = 0, totalReleased = 1, released[A] = 0, released[B] = 1, so totalReceived = 0 + 1 = 1.\n- For B: (totalReceived * shares[B]) / totalShares = floor((1 * 2) / 3) = 0, but released[B] = 1. Thus 0 >= 1 is false, violating the property.","124.22651267051697","20000","ANSWER: FALSE\nEXPLANATION: The function release has an else branch that, when releasable(account) == 0, sends 1 wei to owner without updating totalReleased or any released[payee]. See release: when payment == 0 it executes owner.call{value: 1}(""""""""). Since totalReceived is defined as address(this).balance + totalReleased (see releasable), this decreases totalReceived while leaving released[a] unchanged, allowing released[a] to become greater than (totalReceived * shares[a]) / totalShares.\nCOUNTEREXAMPLE: \n- Deploy with payees [A, B] and shares [1, 2], where A is the owner (payees_[0] == msg.sender).\n- Send 2 wei to the contract.\n- Call release(B): payment = floor((2 * 2) / 3) = 1; released[B] = 1; totalReleased = 1; balance becomes 1; totalReceived stays 2.\n- Call release(A): payment = floor((2 * 1) / 3) - released[A] = 0 - 0 = 0, so the else branch sends 1 wei to owner. Now balance = 0, totalReleased = 1, released[A] = 0, released[B] = 1, so totalReceived = 0 + 1 = 1.\n- For B: (totalReceived * shares[B]) / totalShares = floor((1 * 2) / 3) = 0, but released[B] = 1. Thus 0 >= 1 is false, violating the property."
"9","fair-split-geq-no-overflow","False","FALSE","The invariant relies on totalReceived = address(this).balance + totalReleased and released[a] being bounded by (totalReceived * shares[a]) / totalShares (pendingPayment). However, in release(), when payment == 0 the else-branch transfers 1 wei to owner without increasing totalReleased or released[account], thereby decreasing totalReceived by 1 (since balance decreases) while keeping released[a] unchanged. This can make (totalReceived * shares[a]) / totalShares < released[a]. See release() else-branch and pendingPayment().","- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract (balance = 2, totalReleased = 0).\n- Call release(A): payment = floor((2)*1/2) - 0 = 1. Transfers 1 wei to A; totalReleased = 1; released[A] = 1; balance = 1.\n- Call release(C) with C not in payees (shares[C] = 0): releasable(C) = 0, so else-branch runs and transfers 1 wei to owner; balance = 0; totalReleased remains 1.\n- Now for a = A: totalReceived = balance + totalReleased = 0 + 1 = 1; (totalReceived * shares[A]) / totalShares = floor(1*1/2) = 0, but released[A] = 1. Hence 0 >= 1 is false.","66.34063339233398","20000","ANSWER: FALSE\nEXPLANATION: The invariant relies on totalReceived = address(this).balance + totalReleased and released[a] being bounded by (totalReceived * shares[a]) / totalShares (pendingPayment). However, in release(), when payment == 0 the else-branch transfers 1 wei to owner without increasing totalReleased or released[account], thereby decreasing totalReceived by 1 (since balance decreases) while keeping released[a] unchanged. This can make (totalReceived * shares[a]) / totalShares < released[a]. See release() else-branch and pendingPayment().\nCOUNTEREXAMPLE: \n- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract (balance = 2, totalReleased = 0).\n- Call release(A): payment = floor((2)*1/2) - 0 = 1. Transfers 1 wei to A; totalReleased = 1; released[A] = 1; balance = 1.\n- Call release(C) with C not in payees (shares[C] = 0): releasable(C) = 0, so else-branch runs and transfers 1 wei to owner; balance = 0; totalReleased remains 1.\n- Now for a = A: totalReceived = balance + totalReleased = 0 + 1 = 1; (totalReceived * shares[A]) / totalShares = floor(1*1/2) = 0, but released[A] = 1. Hence 0 >= 1 is false."
"7","non-zero-payees","True","TRUE","The only way addresses are added to the payees array is via addPayee, which enforces require(account != ZERO_ADDRESS, """"""""PaymentSplitter: account is the zero address""""""""). The constructor exclusively populates payees by calling addPayee for each provided address, and there are no other functions that modify payees. Therefore, zero addresses cannot be added.","N/A","10.001925945281982","20000","ANSWER: TRUE\nEXPLANATION: The only way addresses are added to the payees array is via addPayee, which enforces require(account != ZERO_ADDRESS, """"""""PaymentSplitter: account is the zero address""""""""). The constructor exclusively populates payees by calling addPayee for each provided address, and there are no other functions that modify payees. Therefore, zero addresses cannot be added.\nCOUNTEREXAMPLE: N/A"
"8","non-zero-payees","True","TRUE","The only way entries are added to the payees array is via addPayee, which is called from the constructor for each provided payee (constructor loop). addPayee enforces require(account != ZERO_ADDRESS, """"""""PaymentSplitter: account is the zero address""""""""). No other function modifies payees, so address(0) cannot be present.","N/A","8.696268796920776","20000","ANSWER: TRUE\nEXPLANATION: The only way entries are added to the payees array is via addPayee, which is called from the constructor for each provided payee (constructor loop). addPayee enforces require(account != ZERO_ADDRESS, """"""""PaymentSplitter: account is the zero address""""""""). No other function modifies payees, so address(0) cannot be present.\nCOUNTEREXAMPLE: N/A"
"9","non-zero-payees","True","TRUE","The only place where addresses are added to the payees array is in addPayee, which enforces require(account != ZERO_ADDRESS, """"""""PaymentSplitter: account is the zero address""""""""). This function is called exclusively by the constructor for each provided payee (constructor loop over payees_), and there are no public/external functions that modify payees afterwards. Therefore, any address stored in payees must be non-zero.","N/A","12.945064067840576","20000","ANSWER: TRUE\nEXPLANATION: The only place where addresses are added to the payees array is in addPayee, which enforces require(account != ZERO_ADDRESS, """"""""PaymentSplitter: account is the zero address""""""""). This function is called exclusively by the constructor for each provided payee (constructor loop over payees_), and there are no public/external functions that modify payees afterwards. Therefore, any address stored in payees must be non-zero.\nCOUNTEREXAMPLE: N/A"
"10","non-zero-payees","True","TRUE","The only way entries are added to the payees array is via addPayee, which is invoked solely from the constructor. addPayee enforces require(account != ZERO_ADDRESS, """"""""PaymentSplitter: account is the zero address""""""""), preventing zero-address entries. There are no other functions that modify payees after deployment.","N/A","17.023176670074463","20000","ANSWER: TRUE\nEXPLANATION: The only way entries are added to the payees array is via addPayee, which is invoked solely from the constructor. addPayee enforces require(account != ZERO_ADDRESS, """"""""PaymentSplitter: account is the zero address""""""""), preventing zero-address entries. There are no other functions that modify payees after deployment.\nCOUNTEREXAMPLE: N/A"
"6","positive-shares","True","TRUE","The only way payees are added is via addPayee, called solely from the constructor. addPayee enforces shares_ > 0 and then pushes the account into payees and sets shares[account] = shares_ (function addPayee). There are no functions that later modify shares to zero or remove payees. Although the ZERO_ADDRESS check is incorrect, it does not affect this property because any added address (including the zero address) must have shares_ > 0.","N/A","18.636403560638428","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via addPayee, called solely from the constructor. addPayee enforces shares_ > 0 and then pushes the account into payees and sets shares[account] = shares_ (function addPayee). There are no functions that later modify shares to zero or remove payees. Although the ZERO_ADDRESS check is incorrect, it does not affect this property because any added address (including the zero address) must have shares_ > 0.\nCOUNTEREXAMPLE: N/A"
"7","positive-shares","True","TRUE","payees are only added via addPayee (constructor calls addPayee for each entry). addPayee enforces shares_ > 0 and that the account does not already have shares, then sets shares[account] = shares_ and pushes to payees (addPayee). No other function modifies payees or shares. Therefore every address in payees has shares[addr] > 0.","N/A","9.11735486984253","20000","ANSWER: TRUE\nEXPLANATION: payees are only added via addPayee (constructor calls addPayee for each entry). addPayee enforces shares_ > 0 and that the account does not already have shares, then sets shares[account] = shares_ and pushes to payees (addPayee). No other function modifies payees or shares. Therefore every address in payees has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"8","positive-shares","True","TRUE","The only way to add entries to the payees array is via the private function addPayee, which enforces shares_ > 0 and sets shares[account] = shares_ (see addPayee: require(shares_ > 0, ...); then payees.push(account); shares[account] = shares_;). addPayee is only called in the constructor for initialization, and there is no function that later modifies shares or payees. Therefore, every address in payees always has shares[addr] > 0.","N/A","9.96677279472351","20000","ANSWER: TRUE\nEXPLANATION: The only way to add entries to the payees array is via the private function addPayee, which enforces shares_ > 0 and sets shares[account] = shares_ (see addPayee: require(shares_ > 0, ...); then payees.push(account); shares[account] = shares_;). addPayee is only called in the constructor for initialization, and there is no function that later modifies shares or payees. Therefore, every address in payees always has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"10","positive-shares","True","TRUE","payees are only ever added via addPayee in the constructor, which enforces shares_ > 0 and that the account is not the zero address and not already present (addPayee). There are no functions that can later modify shares[addr] or the payees array. Thus, every address in payees has shares[addr] > 0.","N/A","17.215591192245483","20000","ANSWER: TRUE\nEXPLANATION: payees are only ever added via addPayee in the constructor, which enforces shares_ > 0 and that the account is not the zero address and not already present (addPayee). There are no functions that can later modify shares[addr] or the payees array. Thus, every address in payees has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"9","positive-shares","False","FALSE","The constructor adds each payee via addPayee without requiring shares_ > 0. The only checks are that the account is non-zero and not already a payee. The commented-out require in release further indicates zero-share payees are allowed. Thus, a payee can be added with zero shares.","Deploy the contract with payees_ = [msg.sender] and shares_ = [0]. The constructor calls addPayee(msg.sender, 0), pushing msg.sender into payees and setting shares[msg.sender] = 0. Therefore, there exists an addr in payees with shares[addr] = 0, violating the property.","12.649726867675781","20000","ANSWER: FALSE\nEXPLANATION: The constructor adds each payee via addPayee without requiring shares_ > 0. The only checks are that the account is non-zero and not already a payee. The commented-out require in release further indicates zero-share payees are allowed. Thus, a payee can be added with zero shares.\nCOUNTEREXAMPLE: Deploy the contract with payees_ = [msg.sender] and shares_ = [0]. The constructor calls addPayee(msg.sender, 0), pushing msg.sender into payees and setting shares[msg.sender] = 0. Therefore, there exists an addr in payees with shares[addr] = 0, violating the property."
"1","releasable-leq-balance","True","TRUE","releasable(addr) = (address(this).balance + totalReleased) * shares[addr] / totalShares - released[addr] (functions releasable and pendingPayment). For all payees, released[addr] is maintained so it never exceeds their pro-rata of totalReceived (updated in release before the transfer), hence each releasable(addr) is non-negative. Summing over all payees gives Σ releasable = Σ floor(totalReceived * share/totalShares) - Σ released ≤ totalReceived - totalReleased = address(this).balance. Since each releasable is ≥ 0 and their sum ≤ balance, each individual releasable(addr) ≤ address(this).balance.","N/A","84.15029692649841","20000","ANSWER: TRUE\nEXPLANATION: releasable(addr) = (address(this).balance + totalReleased) * shares[addr] / totalShares - released[addr] (functions releasable and pendingPayment). For all payees, released[addr] is maintained so it never exceeds their pro-rata of totalReceived (updated in release before the transfer), hence each releasable(addr) is non-negative. Summing over all payees gives Σ releasable = Σ floor(totalReceived * share/totalShares) - Σ released ≤ totalReceived - totalReleased = address(this).balance. Since each releasable is ≥ 0 and their sum ≤ balance, each individual releasable(addr) ≤ address(this).balance.\nCOUNTEREXAMPLE: N/A"
"2","releasable-leq-balance","True","TRUE","releasable(addr) computes a payee’s due as (address(this).balance + totalReleased) * shares[addr] / totalShares - released[addr] (functions releasable and pendingPayment). Summing this over all payees is ≤ address(this).balance, because totalReleased = sum(released) and sum(shares) = totalShares. Since each payee’s releasable is non-negative and the sum of all payees’ releasables is ≤ the contract balance, each individual payee’s releasable is ≤ the contract balance.","N/A","74.13241267204285","20000","ANSWER: TRUE\nEXPLANATION: releasable(addr) computes a payee’s due as (address(this).balance + totalReleased) * shares[addr] / totalShares - released[addr] (functions releasable and pendingPayment). Summing this over all payees is ≤ address(this).balance, because totalReleased = sum(released) and sum(shares) = totalShares. Since each payee’s releasable is non-negative and the sum of all payees’ releasables is ≤ the contract balance, each individual payee’s releasable is ≤ the contract balance.\nCOUNTEREXAMPLE: N/A"
"3","releasable-leq-balance","True","TRUE","releasable(addr) = (address(this).balance + totalReleased)/3 - released[addr] (functions releasable and pendingPayment). Only payees can increase released[addr] via release (which requires isPayee and shares>0), ensuring released[addr] ≤ floor((balance + totalReleased)/3), so each releasable(addr) is nonnegative. Summing over all three payees gives sum(releasable) = 3*floor((balance + totalReleased)/3) - totalReleased = balance - ((balance + totalReleased) % 3) ≤ balance. Since each releasable is ≥ 0 and their sum ≤ balance, each individual releasable(addr) ≤ balance.","N/A","68.04155802726746","20000","ANSWER: TRUE\nEXPLANATION: releasable(addr) = (address(this).balance + totalReleased)/3 - released[addr] (functions releasable and pendingPayment). Only payees can increase released[addr] via release (which requires isPayee and shares>0), ensuring released[addr] ≤ floor((balance + totalReleased)/3), so each releasable(addr) is nonnegative. Summing over all three payees gives sum(releasable) = 3*floor((balance + totalReleased)/3) - totalReleased = balance - ((balance + totalReleased) % 3) ≤ balance. Since each releasable is ≥ 0 and their sum ≤ balance, each individual releasable(addr) ≤ balance.\nCOUNTEREXAMPLE: N/A"
"4","releasable-leq-balance","True","TRUE","releasable(account) = (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (functions releasable and pendingPayment). Since addPayee ensures totalShares equals the sum of all payees’ shares and shares > 0, summing releasable over all payees yields at most address(this).balance (the division truncates, so the sum is ≤ balance). Each individual releasable is non-negative and cannot exceed the sum, hence cannot exceed the contract balance.","N/A","98.22040319442749","20000","ANSWER: TRUE\nEXPLANATION: releasable(account) = (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (functions releasable and pendingPayment). Since addPayee ensures totalShares equals the sum of all payees’ shares and shares > 0, summing releasable over all payees yields at most address(this).balance (the division truncates, so the sum is ≤ balance). Each individual releasable is non-negative and cannot exceed the sum, hence cannot exceed the contract balance.\nCOUNTEREXAMPLE: N/A"
"5","releasable-leq-balance","True","TRUE","releasable(addr) = pendingPayment(addr, address(this).balance + totalReleased, released[addr]) (function releasable). Due to the bug in pendingPayment (it divides shares[addr] by totalShares first), for any payee with shares[addr] < totalShares, shares[addr] / totalShares = 0, so releasable(addr) = 0, which is <= the contract balance. The only case where shares[addr] / totalShares = 1 is when there is exactly one payee with all the shares; then releasable(addr) = address(this).balance + totalReleased − released[addr] = address(this).balance because totalReleased equals released[addr] for the sole payee. Thus, for all payees in all reachable states, releasable(addr) ≤ contract balance.","N/A","48.34790754318237","20000","ANSWER: TRUE\nEXPLANATION: releasable(addr) = pendingPayment(addr, address(this).balance + totalReleased, released[addr]) (function releasable). Due to the bug in pendingPayment (it divides shares[addr] by totalShares first), for any payee with shares[addr] < totalShares, shares[addr] / totalShares = 0, so releasable(addr) = 0, which is <= the contract balance. The only case where shares[addr] / totalShares = 1 is when there is exactly one payee with all the shares; then releasable(addr) = address(this).balance + totalReleased − released[addr] = address(this).balance because totalReleased equals released[addr] for the sole payee. Thus, for all payees in all reachable states, releasable(addr) ≤ contract balance.\nCOUNTEREXAMPLE: N/A"
"6","releasable-leq-balance","True","TRUE","releasable(account) = (totalReceived * shares[account]) / totalShares - released[account], with totalReceived = address(this).balance + totalReleased (functions releasable and pendingPayment). Since totalReleased = sum(released[payee]) and integer division floors, we have sum_over_payees(releasable) ≤ address(this).balance. As each releasable is non-negative, each individual releasable(payee) ≤ address(this).balance.","N/A","49.9597327709198","20000","ANSWER: TRUE\nEXPLANATION: releasable(account) = (totalReceived * shares[account]) / totalShares - released[account], with totalReceived = address(this).balance + totalReleased (functions releasable and pendingPayment). Since totalReleased = sum(released[payee]) and integer division floors, we have sum_over_payees(releasable) ≤ address(this).balance. As each releasable is non-negative, each individual releasable(payee) ≤ address(this).balance.\nCOUNTEREXAMPLE: N/A"
"7","releasable-leq-balance","True","TRUE","For any payee account, releasable(account) = ( (address(this).balance + totalReleased) * shares[account] / totalShares ) - released[account] (functions releasable and pendingPayment). Summing releasable over all payees yields sum_i floor(R * s_i / S) - totalReleased, where R = address(this).balance + totalReleased, s_i are their shares, and S = totalShares. Because sum_i floor(R * s_i / S) <= R and sum_i released = totalReleased (release), the total releasable across all payees is <= address(this).balance. Since each payee’s releasable is nonnegative, each individual releasable(addr) must be <= the contract balance. addPayee ensures S > 0 and shares > 0, avoiding division by zero.","N/A","32.85706353187561","20000","ANSWER: TRUE\nEXPLANATION: For any payee account, releasable(account) = ( (address(this).balance + totalReleased) * shares[account] / totalShares ) - released[account] (functions releasable and pendingPayment). Summing releasable over all payees yields sum_i floor(R * s_i / S) - totalReleased, where R = address(this).balance + totalReleased, s_i are their shares, and S = totalShares. Because sum_i floor(R * s_i / S) <= R and sum_i released = totalReleased (release), the total releasable across all payees is <= address(this).balance. Since each payee’s releasable is nonnegative, each individual releasable(addr) must be <= the contract balance. addPayee ensures S > 0 and shares > 0, avoiding division by zero.\nCOUNTEREXAMPLE: N/A"
"8","releasable-leq-balance","True","PARSE_ERROR","","N/A","176.81255769729614","20000",""
"9","releasable-leq-balance","True","FALSE","The function releasable(account) computes based on totalReceived = address(this).balance + totalReleased (releasable/pendingPayment). In release(), when payment == 0 it sends 1 wei to owner without updating totalReleased or released (else-branch), and the check that the account has shares is commented out, allowing this path to be triggered for any zero-share address. This allows draining the contract balance without adjusting totalReleased, so releasable for a payee can exceed the current balance.","- Deploy with payees [A (owner), B], shares [50, 50].\n- Send 2000 wei to the contract.\n- Call release(B): payment = 1000 wei to B; totalReleased = 1000; released[B] = 1000; balance = 1000.\n- Repeatedly call release(C) for some non-payee C (shares[C] = 0) so payment == 0 and the else-branch executes, sending 1 wei to owner each time. Do this 1000 times to drain the balance to 0. Note: totalReleased stays 1000 throughout.\n- Now, releasable(A) = ((balance + totalReleased) * 50 / 100) - released[A] = ((0 + 1000) * 50 / 100) - 0 = 500 > balance (0).","171.4907591342926","20000","ANSWER: FALSE\nEXPLANATION: The function releasable(account) computes based on totalReceived = address(this).balance + totalReleased (releasable/pendingPayment). In release(), when payment == 0 it sends 1 wei to owner without updating totalReleased or released (else-branch), and the check that the account has shares is commented out, allowing this path to be triggered for any zero-share address. This allows draining the contract balance without adjusting totalReleased, so releasable for a payee can exceed the current balance.\nCOUNTEREXAMPLE: \n- Deploy with payees [A (owner), B], shares [50, 50].\n- Send 2000 wei to the contract.\n- Call release(B): payment = 1000 wei to B; totalReleased = 1000; released[B] = 1000; balance = 1000.\n- Repeatedly call release(C) for some non-payee C (shares[C] = 0) so payment == 0 and the else-branch executes, sending 1 wei to owner each time. Do this 1000 times to drain the balance to 0. Note: totalReleased stays 1000 throughout.\n- Now, releasable(A) = ((balance + totalReleased) * 50 / 100) - released[A] = ((0 + 1000) * 50 / 100) - 0 = 500 > balance (0)."
"10","releasable-leq-balance","True","TRUE","releasable(account) = (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (releasable and pendingPayment). For all payees, released[account] is only increased via release() up to their current pro‑rata entitlement and totalReceived is non-decreasing, so released[account] never exceeds the owed amount. Hence each releasable(account) ≥ 0. Summing over all payees, Σ releasable(account) = Σ floor(totalReceived * shares / totalShares) − totalReleased ≤ totalReceived − totalReleased = address(this).balance. Therefore, each individual releasable(account) ≤ address(this).balance.","N/A","59.19227313995361","20000","ANSWER: TRUE\nEXPLANATION: releasable(account) = (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (releasable and pendingPayment). For all payees, released[account] is only increased via release() up to their current pro‑rata entitlement and totalReceived is non-decreasing, so released[account] never exceeds the owed amount. Hence each releasable(account) ≥ 0. Summing over all payees, Σ releasable(account) = Σ floor(totalReceived * shares / totalShares) − totalReleased ≤ totalReceived − totalReleased = address(this).balance. Therefore, each individual releasable(account) ≤ address(this).balance.\nCOUNTEREXAMPLE: N/A"
"1","releasable-sum-balance","False","FALSE","The function releasable(account) computes (balance + totalReleased) * shares[account] / totalShares - released[account] using integer division in pendingPayment(), which truncates. getTotalReleasable() sums these per-payee truncated amounts, so the sum can be strictly less than address(this).balance due to rounding remainders.","- Deploy with payees [A, B, C] and shares [1, 1, 1] (totalShares = 3).\n- Send 1 wei to the contract (balance = 1, totalReleased = 0).\n- For each payee, releasable = floor((1 * 1) / 3) - 0 = 0.\n- Sum of releasables = 0, while contract balance = 1.","26.073612213134766","20000","ANSWER: FALSE\nEXPLANATION: The function releasable(account) computes (balance + totalReleased) * shares[account] / totalShares - released[account] using integer division in pendingPayment(), which truncates. getTotalReleasable() sums these per-payee truncated amounts, so the sum can be strictly less than address(this).balance due to rounding remainders.\nCOUNTEREXAMPLE: \n- Deploy with payees [A, B, C] and shares [1, 1, 1] (totalShares = 3).\n- Send 1 wei to the contract (balance = 1, totalReleased = 0).\n- For each payee, releasable = floor((1 * 1) / 3) - 0 = 0.\n- Sum of releasables = 0, while contract balance = 1."
"2","releasable-sum-balance","False","FALSE","The calculation of releasable uses integer division per payee: pendingPayment(account, totalReceived, alreadyReleased) = (totalReceived * shares[account]) / totalShares - alreadyReleased (function pendingPayment). Due to rounding down, the sum over all payees can be strictly less than address(this).balance. releasable() sets totalReceived = address(this).balance + totalReleased, but sum_i floor((totalReceived * shares_i) / totalShares) - released_i ≤ address(this).balance, with strict inequality possible.","- Deploy with payees A, B, C and shares 1, 1, 1 (constructor).\n- Send 1 wei to the contract (receive()).\n- totalShares = 3, totalReleased = 0, balance = 1.\n- For each payee X ∈ {A,B,C}: releasable(X) = floor((1 * 1)/3) - 0 = 0.\n- Sum of releasable = 0, while contract balance = 1. Property violated.","20.99575710296631","20000","ANSWER: FALSE\nEXPLANATION: The calculation of releasable uses integer division per payee: pendingPayment(account, totalReceived, alreadyReleased) = (totalReceived * shares[account]) / totalShares - alreadyReleased (function pendingPayment). Due to rounding down, the sum over all payees can be strictly less than address(this).balance. releasable() sets totalReceived = address(this).balance + totalReleased, but sum_i floor((totalReceived * shares_i) / totalShares) - released_i ≤ address(this).balance, with strict inequality possible.\nCOUNTEREXAMPLE: \n- Deploy with payees A, B, C and shares 1, 1, 1 (constructor).\n- Send 1 wei to the contract (receive()).\n- totalShares = 3, totalReleased = 0, balance = 1.\n- For each payee X ∈ {A,B,C}: releasable(X) = floor((1 * 1)/3) - 0 = 0.\n- Sum of releasable = 0, while contract balance = 1. Property violated."
"3","releasable-sum-balance","False","FALSE","The contract computes each payee’s releasable as (address(this).balance + totalReleased) / 3 - released[account] (see releasable() and pendingPayment()). Due to integer division, the sum over the three payees is balance - ((balance + totalReleased) mod 3), which is not always equal to the contract balance.","- Deploy with any three distinct non-zero addresses.\n- Send 1 wei to the contract.\n- Then for each payee i, releasable(payees[i]) = floor((1 + 0)/3) - 0 = 0.\n- Sum of releasables = 0, while getBalance() = 1.","32.638922691345215","20000","ANSWER: FALSE\nEXPLANATION: The contract computes each payee’s releasable as (address(this).balance + totalReleased) / 3 - released[account] (see releasable() and pendingPayment()). Due to integer division, the sum over the three payees is balance - ((balance + totalReleased) mod 3), which is not always equal to the contract balance.\nCOUNTEREXAMPLE: \n- Deploy with any three distinct non-zero addresses.\n- Send 1 wei to the contract.\n- Then for each payee i, releasable(payees[i]) = floor((1 + 0)/3) - 0 = 0.\n- Sum of releasables = 0, while getBalance() = 1."
"4","releasable-sum-balance","False","FALSE","The per-payee releasable amount is computed with integer division in pendingPayment: (totalReceived * shares[account]) / totalShares - released[account]. This truncation causes rounding “dust,” so the sum of per-payee releasables (as in getTotalReleasable) can be strictly less than the contract balance.","- Deploy with payees [A, B] and shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (receive()) so address(this).balance = 1, totalReleased = 0.\n- For each payee: releasable = floor((1 + 0) * 1 / 2) - 0 = 0.\n- Sum of releasables = 0, but contract balance = 1.","26.476398468017578","20000","ANSWER: FALSE\nEXPLANATION: The per-payee releasable amount is computed with integer division in pendingPayment: (totalReceived * shares[account]) / totalShares - released[account]. This truncation causes rounding “dust,” so the sum of per-payee releasables (as in getTotalReleasable) can be strictly less than the contract balance.\nCOUNTEREXAMPLE: \n- Deploy with payees [A, B] and shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (receive()) so address(this).balance = 1, totalReleased = 0.\n- For each payee: releasable = floor((1 + 0) * 1 / 2) - 0 = 0.\n- Sum of releasables = 0, but contract balance = 1."
"5","releasable-sum-balance","False","FALSE","The pendingPayment function divides before multiplying: totalReceived * (shares[account] / totalShares) - alreadyReleased (see pendingPayment). Due to integer truncation, shares[account] / totalShares is 0 for any payee whose shares are less than totalShares (i.e., any setup with at least two payees). Thus releasable for each payee becomes 0 (unless a single payee has all shares), so the sum of releasables can be strictly less than the contract balance. The comment in pendingPayment even notes this is incorrect.","- Deploy with two payees: payees = [Alice, Bob], shares = [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (balance = 1).\n- For Alice: releasable(Alice) = 1 * (1/2) - 0 = 0 (truncated).\n- For Bob: releasable(Bob) = 1 * (1/2) - 0 = 0 (truncated).\n- Sum of releasables = 0, while contract balance = 1 wei.","33.302321910858154","20000","ANSWER: FALSE\nEXPLANATION: The pendingPayment function divides before multiplying: totalReceived * (shares[account] / totalShares) - alreadyReleased (see pendingPayment). Due to integer truncation, shares[account] / totalShares is 0 for any payee whose shares are less than totalShares (i.e., any setup with at least two payees). Thus releasable for each payee becomes 0 (unless a single payee has all shares), so the sum of releasables can be strictly less than the contract balance. The comment in pendingPayment even notes this is incorrect.\nCOUNTEREXAMPLE: \n- Deploy with two payees: payees = [Alice, Bob], shares = [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (balance = 1).\n- For Alice: releasable(Alice) = 1 * (1/2) - 0 = 0 (truncated).\n- For Bob: releasable(Bob) = 1 * (1/2) - 0 = 0 (truncated).\n- Sum of releasables = 0, while contract balance = 1 wei."
"6","releasable-sum-balance","False","FALSE","In pendingPayment(), each payee’s entitlement uses integer division: (totalReceived * shares[account]) / totalShares - alreadyReleased. Summing these per-payee floors can be strictly less than totalReceived - totalReleased (the contract balance). getTotalReleasable() simply sums releasable() over payees, so it can be less than address(this).balance when totalReceived is not divisible by totalShares.","- Deploy with payees [A, B] and shares [1, 1].\n- Send 1 wei to the contract.\n- Then totalReceived = 1, totalShares = 2, totalReleased = 0.\n- releasable(A) = floor(1*1/2) - 0 = 0; releasable(B) = 0.\n- Sum of releasables = 0, but contract balance = 1 wei.","20.077577590942383","20000","ANSWER: FALSE\nEXPLANATION: In pendingPayment(), each payee’s entitlement uses integer division: (totalReceived * shares[account]) / totalShares - alreadyReleased. Summing these per-payee floors can be strictly less than totalReceived - totalReleased (the contract balance). getTotalReleasable() simply sums releasable() over payees, so it can be less than address(this).balance when totalReceived is not divisible by totalShares.\nCOUNTEREXAMPLE: \n- Deploy with payees [A, B] and shares [1, 1].\n- Send 1 wei to the contract.\n- Then totalReceived = 1, totalShares = 2, totalReleased = 0.\n- releasable(A) = floor(1*1/2) - 0 = 0; releasable(B) = 0.\n- Sum of releasables = 0, but contract balance = 1 wei."
"7","releasable-sum-balance","False","FALSE","releasable() computes pendingPayment() as (totalReceived * shares[account]) / totalShares - released[account] (integer division, see pendingPayment). Due to truncation, the sum of all payees’ releasables can be strictly less than address(this).balance. getTotalReleasable() sums releasable() over payees, so it can be less than the contract balance.","- Deploy with two payees P1 and P2, shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract.\n- totalReceived = balance + totalReleased = 1.\n- releasable(P1) = floor(1*1/2) - 0 = 0; releasable(P2) = 0. Sum = 0.\n- Contract balance = 1 wei.\nTherefore, sum of releasable funds (0) != contract balance (1).","29.49110984802246","20000","ANSWER: FALSE\nEXPLANATION: releasable() computes pendingPayment() as (totalReceived * shares[account]) / totalShares - released[account] (integer division, see pendingPayment). Due to truncation, the sum of all payees’ releasables can be strictly less than address(this).balance. getTotalReleasable() sums releasable() over payees, so it can be less than the contract balance.\nCOUNTEREXAMPLE: \n- Deploy with two payees P1 and P2, shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract.\n- totalReceived = balance + totalReleased = 1.\n- releasable(P1) = floor(1*1/2) - 0 = 0; releasable(P2) = 0. Sum = 0.\n- Contract balance = 1 wei.\nTherefore, sum of releasable funds (0) != contract balance (1)."
"8","releasable-sum-balance","False","FALSE","The computation of releasable funds uses integer division in pendingPayment: (totalReceived * shares[account]) / totalShares - alreadyReleased. Due to truncation, the sum of all releasable amounts across payees can be strictly less than address(this).balance. See functions releasable() and pendingPayment().","- Deploy with payees [owner, Bob] and shares [1, 1].\n- Send 1 wei to the contract.\n- totalReceived = balance + totalReleased = 1 + 0 = 1.\n- releasable(owner) = floor(1*1/2) - 0 = 0; releasable(Bob) = 0.\n- Sum of releasables = 0, while contract balance = 1.\nThus, the property is violated.","29.85412049293518","20000","ANSWER: FALSE\nEXPLANATION: The computation of releasable funds uses integer division in pendingPayment: (totalReceived * shares[account]) / totalShares - alreadyReleased. Due to truncation, the sum of all releasable amounts across payees can be strictly less than address(this).balance. See functions releasable() and pendingPayment().\nCOUNTEREXAMPLE: \n- Deploy with payees [owner, Bob] and shares [1, 1].\n- Send 1 wei to the contract.\n- totalReceived = balance + totalReleased = 1 + 0 = 1.\n- releasable(owner) = floor(1*1/2) - 0 = 0; releasable(Bob) = 0.\n- Sum of releasables = 0, while contract balance = 1.\nThus, the property is violated."
"9","releasable-sum-balance","False","FALSE","The function pendingPayment uses integer division (totalReceived * shares[account]) / totalShares, which rounds down (see pendingPayment). getTotalReleasable sums these per-payee rounded values (see getTotalReleasable). Therefore, there can be leftover “dust” in the contract balance that is not counted as releasable to any payee, so the sum of releasable funds can be strictly less than the contract balance.","- Deploy with two payees: [A, B] and shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract.\n- totalReceived = balance + totalReleased = 1.\n- releasable(A) = floor(1 * 1 / 2) - 0 = 0; releasable(B) = 0.\n- Sum of releasable = 0, but contract balance = 1 wei.\nThus, the property is violated.","23.674463033676147","20000","ANSWER: FALSE\nEXPLANATION: The function pendingPayment uses integer division (totalReceived * shares[account]) / totalShares, which rounds down (see pendingPayment). getTotalReleasable sums these per-payee rounded values (see getTotalReleasable). Therefore, there can be leftover “dust” in the contract balance that is not counted as releasable to any payee, so the sum of releasable funds can be strictly less than the contract balance.\nCOUNTEREXAMPLE: \n- Deploy with two payees: [A, B] and shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract.\n- totalReceived = balance + totalReleased = 1.\n- releasable(A) = floor(1 * 1 / 2) - 0 = 0; releasable(B) = 0.\n- Sum of releasable = 0, but contract balance = 1 wei.\nThus, the property is violated."
"10","releasable-sum-balance","False","FALSE","The sum of releasable amounts across payees can be less than the contract balance due to per-payee integer division truncation in pendingPayment: (totalReceived * shares[account]) / totalShares - alreadyReleased. getTotalReleasable() sums releasable(payees[i]), which uses this truncated value, while getBalance() returns the exact balance. When totalReceived is not divisible by totalShares, """"""""dust"""""""" remains in the contract.","- Deploy with payees [A,B,C] and shares [1,1,1] (totalShares = 3).\n- Send 1 wei to the contract.\n- For each payee, releasable = floor((1 wei + 0) * 1 / 3) - 0 = 0; sum of releasable = 0.\n- Contract balance = 1 wei.\n- Hence, sum of releasable funds (0) != contract balance (1 wei).","32.390756130218506","20000","ANSWER: FALSE\nEXPLANATION: The sum of releasable amounts across payees can be less than the contract balance due to per-payee integer division truncation in pendingPayment: (totalReceived * shares[account]) / totalShares - alreadyReleased. getTotalReleasable() sums releasable(payees[i]), which uses this truncated value, while getBalance() returns the exact balance. When totalReceived is not divisible by totalShares, """"""""dust"""""""" remains in the contract.\nCOUNTEREXAMPLE: \n- Deploy with payees [A,B,C] and shares [1,1,1] (totalShares = 3).\n- Send 1 wei to the contract.\n- For each payee, releasable = floor((1 wei + 0) * 1 / 3) - 0 = 0; sum of releasable = 0.\n- Contract balance = 1 wei.\n- Hence, sum of releasable funds (0) != contract balance (1 wei)."
"1","release-balance-payee","True","FALSE","In release, the contract computes payment = releasable(account) and then sends ETH via a low-level call to the payee (account.call{value: payment}("""""""")). Because this external call executes the payee’s fallback/receive function, the payee can immediately forward or spend the received ETH. Thus, after release returns, the payee’s balance need not have increased by releasable(account), even though that amount was sent.","- Create a payee contract Drainer with a payable receive() that forwards all received ETH to an external EOA sink:\n  receive() external payable { (bool ok,) = sink.call{value: address(this).balance}(""""""""); require(ok); }\n- Deploy PaymentSplitter with payees = [Drainer] and shares = [1].\n- Send 1 ether to PaymentSplitter.\n- Before calling release, releasable(Drainer) = 1 ether.\n- Call release(Drainer). PaymentSplitter sends 1 ether to Drainer; Drainer’s receive() immediately forwards the 1 ether to sink and does not revert; release returns successfully.\n- After the call, Drainer’s balance increased by 0, not by releasable(Drainer) (1 ether).","54.006550788879395","20000","ANSWER: FALSE\nEXPLANATION: In release, the contract computes payment = releasable(account) and then sends ETH via a low-level call to the payee (account.call{value: payment}("""""""")). Because this external call executes the payee’s fallback/receive function, the payee can immediately forward or spend the received ETH. Thus, after release returns, the payee’s balance need not have increased by releasable(account), even though that amount was sent.\nCOUNTEREXAMPLE: \n- Create a payee contract Drainer with a payable receive() that forwards all received ETH to an external EOA sink:\n  receive() external payable { (bool ok,) = sink.call{value: address(this).balance}(""""""""); require(ok); }\n- Deploy PaymentSplitter with payees = [Drainer] and shares = [1].\n- Send 1 ether to PaymentSplitter.\n- Before calling release, releasable(Drainer) = 1 ether.\n- Call release(Drainer). PaymentSplitter sends 1 ether to Drainer; Drainer’s receive() immediately forwards the 1 ether to sink and does not revert; release returns successfully.\n- After the call, Drainer’s balance increased by 0, not by releasable(Drainer) (1 ether)."
"2","release-balance-payee","True","FALSE","release computes payment = releasable(account) and then sends that amount via a low-level call to account (release: account.call{value: payment}("""""""")). Because this call executes account’s fallback/receive code, account can immediately forward or spend the received ETH before the transaction ends. The function only checks that the transfer succeeded; it does not (and cannot) ensure account’s final balance increased by that amount. Thus, a non-reverting call to release(a) does not guarantee a’s end-of-call balance increased by releasable(a).","- Let a be a contract with receive() that forwards any received ETH to some EOA and returns true:\n  receive() external payable { (bool,) = owner.call{value: address(this).balance}(""""""""); }\n- Deploy PaymentSplitter with payees [a, b, c] and shares [1,1,1]. Send 3 ETH to the splitter.\n- Before calling release(a), releasable(a) = 1 ETH.\n- Call release(a). PaymentSplitter sends 1 ETH to a; a’s receive immediately forwards the 1 ETH to owner and returns successfully. release(a) does not revert.\n- After the call, a’s balance has not increased by 1 ETH (it remains 0), violating the property.","58.420963287353516","20000","ANSWER: FALSE\nEXPLANATION: release computes payment = releasable(account) and then sends that amount via a low-level call to account (release: account.call{value: payment}("""""""")). Because this call executes account’s fallback/receive code, account can immediately forward or spend the received ETH before the transaction ends. The function only checks that the transfer succeeded; it does not (and cannot) ensure account’s final balance increased by that amount. Thus, a non-reverting call to release(a) does not guarantee a’s end-of-call balance increased by releasable(a).\nCOUNTEREXAMPLE: \n- Let a be a contract with receive() that forwards any received ETH to some EOA and returns true:\n  receive() external payable { (bool,) = owner.call{value: address(this).balance}(""""""""); }\n- Deploy PaymentSplitter with payees [a, b, c] and shares [1,1,1]. Send 3 ETH to the splitter.\n- Before calling release(a), releasable(a) = 1 ETH.\n- Call release(a). PaymentSplitter sends 1 ETH to a; a’s receive immediately forwards the 1 ETH to owner and returns successfully. release(a) does not revert.\n- After the call, a’s balance has not increased by 1 ETH (it remains 0), violating the property."
"3","release-balance-payee","True","FALSE","The release function sends payment via a low-level call to account (release: (bool success, ) = account.call{value: payment}("""""""");). A payee that is a contract can execute arbitrary code in its receive/fallback and immediately transfer the received ETH away, so after the non-reverting call its final balance need not be increased by releasable(a). The code does not enforce any postcondition on the recipient’s final balance; it only requires the external call to succeed.","- Deploy a malicious payee contract A with:\n  - function setSplitter(address payable s) external { splitter = s; }\n  - receive() external payable { splitter.call{value: msg.value}(""""""""); }  // forwards all received ETH back to the splitter\n- Deploy PaymentSplitter with payees [A, B, C].\n- Call A.setSplitter(address(PaymentSplitter)).\n- Send 3 wei to PaymentSplitter.\n- Before calling, releasable(A) = (balance + totalReleased)/3 - released[A] = (3 + 0)/3 - 0 = 1 wei.\n- Call PaymentSplitter.release(A). It computes payment = 1 wei, updates accounting, and sends 1 wei to A.\n- A’s receive() immediately sends that 1 wei back to the splitter; the call does not revert since PaymentSplitter’s receive() accepts ETH.\n- The transaction does not revert, but A’s final balance increased by 0 wei, not by releasable(A) = 1 wei.","68.76706337928772","20000","ANSWER: FALSE\nEXPLANATION: The release function sends payment via a low-level call to account (release: (bool success, ) = account.call{value: payment}("""""""");). A payee that is a contract can execute arbitrary code in its receive/fallback and immediately transfer the received ETH away, so after the non-reverting call its final balance need not be increased by releasable(a). The code does not enforce any postcondition on the recipient’s final balance; it only requires the external call to succeed.\nCOUNTEREXAMPLE: \n- Deploy a malicious payee contract A with:\n  - function setSplitter(address payable s) external { splitter = s; }\n  - receive() external payable { splitter.call{value: msg.value}(""""""""); }  // forwards all received ETH back to the splitter\n- Deploy PaymentSplitter with payees [A, B, C].\n- Call A.setSplitter(address(PaymentSplitter)).\n- Send 3 wei to PaymentSplitter.\n- Before calling, releasable(A) = (balance + totalReleased)/3 - released[A] = (3 + 0)/3 - 0 = 1 wei.\n- Call PaymentSplitter.release(A). It computes payment = 1 wei, updates accounting, and sends 1 wei to A.\n- A’s receive() immediately sends that 1 wei back to the splitter; the call does not revert since PaymentSplitter’s receive() accepts ETH.\n- The transaction does not revert, but A’s final balance increased by 0 wei, not by releasable(A) = 1 wei.\n"
"5","release-balance-payee","True","FALSE","release computes payment = releasable(account) and then sends exactly that amount via an external call (account.call{value: payment}(""""""""), require(success); in release). However, because account can be an arbitrary contract, it can immediately forward or spend the received ETH in its fallback/receive function. Therefore, after the non-reverting call to release(a), the final balance of a need not have increased by releasable(a). The contract only guarantees an attempted transfer, not the final net balance of a.","- Deploy PaymentSplitter with a single payee P and shares [1] (so that release does not revert due to the integer-division bug in pendingPayment).\n- Fund the splitter with 1 ether.\n- Let P be a contract:\n  - contract P { address payable sink; constructor(address payable s){sink=s;} receive() external payable { sink.transfer(msg.value); } }\n- Pre-state: balance(P) = 0; releasable(P) = 1 ether (since shares/totalShares = 1).\n- Call release(P). It does not revert and sends 1 ether to P. P’s receive immediately forwards the 1 ether to sink and returns true, so release succeeds.\n- Post-state: balance(P) = 0 (no net increase), while releasable(P) before the call was 1 ether. This violates the property.","99.60130739212036","20000","ANSWER: FALSE\nEXPLANATION: release computes payment = releasable(account) and then sends exactly that amount via an external call (account.call{value: payment}(""""""""), require(success); in release). However, because account can be an arbitrary contract, it can immediately forward or spend the received ETH in its fallback/receive function. Therefore, after the non-reverting call to release(a), the final balance of a need not have increased by releasable(a). The contract only guarantees an attempted transfer, not the final net balance of a.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with a single payee P and shares [1] (so that release does not revert due to the integer-division bug in pendingPayment).\n- Fund the splitter with 1 ether.\n- Let P be a contract:\n  - contract P { address payable sink; constructor(address payable s){sink=s;} receive() external payable { sink.transfer(msg.value); } }\n- Pre-state: balance(P) = 0; releasable(P) = 1 ether (since shares/totalShares = 1).\n- Call release(P). It does not revert and sends 1 ether to P. P’s receive immediately forwards the 1 ether to sink and returns true, so release succeeds.\n- Post-state: balance(P) = 0 (no net increase), while releasable(P) before the call was 1 ether. This violates the property."
"6","release-balance-payee","True","FALSE","release(account) computes payment = releasable(account) and then sends that amount via a low-level call: (bool success, ) = account.call{value: payment}(""""""""); require(success);. Because this external call executes arbitrary code in account, the payee can immediately forward or otherwise spend the received ETH before the outer call returns. Therefore, the payee’s end-of-call balance need not have increased by releasable(account) even though the call did not revert.","- Let A be a payee with shares[A] > 0, and B be any other address.\n- A is a contract with: receive() external payable { (bool, ) = B.call{value: msg.value}(""""""""); } // ignore return value, do not revert.\n- Deploy PaymentSplitter([A], [1]) and send 10 ETH to the splitter.\n- Before calling release(A), releasable(A) = 10 ETH and balance(A) = 0.\n- Call release(payable(A)). It does not revert (A’s receive returns successfully). During the call, A forwards the 10 ETH to B.\n- After the call, balance(A) = 0, i.e., it is not increased by releasable(A) (= 10 ETH).","135.97618103027344","20000","ANSWER: FALSE\nEXPLANATION: release(account) computes payment = releasable(account) and then sends that amount via a low-level call: (bool success, ) = account.call{value: payment}(""""""""); require(success);. Because this external call executes arbitrary code in account, the payee can immediately forward or otherwise spend the received ETH before the outer call returns. Therefore, the payee’s end-of-call balance need not have increased by releasable(account) even though the call did not revert.\nCOUNTEREXAMPLE: \n- Let A be a payee with shares[A] > 0, and B be any other address.\n- A is a contract with: receive() external payable { (bool, ) = B.call{value: msg.value}(""""""""); } // ignore return value, do not revert.\n- Deploy PaymentSplitter([A], [1]) and send 10 ETH to the splitter.\n- Before calling release(A), releasable(A) = 10 ETH and balance(A) = 0.\n- Call release(payable(A)). It does not revert (A’s receive returns successfully). During the call, A forwards the 10 ETH to B.\n- After the call, balance(A) = 0, i.e., it is not increased by releasable(A) (= 10 ETH)."
"7","release-balance-payee","True","FALSE","release() sends ETH with a low-level call to the payee (account.call{value: payment}(""""""""); require(success);). A contract payee can execute arbitrary code in its fallback/receive and immediately forward the received ETH elsewhere. Thus, after a successful release, the payee’s final balance need not have increased by the pre-call releasable(account) amount, even though the transfer succeeded.","- Let a be a contract Forwarder with:\n  - function claim(PaymentSplitter ps) external { ps.release(payable(address(this))); }\n  - receive() external payable { payable(owner).call{value: address(this).balance}(""""""""); }  // forwards all received ETH out\n- Deploy PaymentSplitter with payees = [a], shares = [1].\n- Send 10 ETH to PaymentSplitter.\n- Call a.claim(ps). This makes msg.sender == a for ps.release(a), so it does not revert. Pre-call, releasable(a) = 10 ETH. release() computes payment = 10 ETH, updates accounting, then calls a with 10 ETH. a’s receive forwards the 10 ETH to owner and returns success; release() returns successfully.\n- Final state: balance(a) has not increased (it is 0), but releasable(a) before the call was 10 ETH. Hence the balance of a did not increase by releasable(a).","194.9405550956726","20000","ANSWER: FALSE\nEXPLANATION: release() sends ETH with a low-level call to the payee (account.call{value: payment}(""""""""); require(success);). A contract payee can execute arbitrary code in its fallback/receive and immediately forward the received ETH elsewhere. Thus, after a successful release, the payee’s final balance need not have increased by the pre-call releasable(account) amount, even though the transfer succeeded.\nCOUNTEREXAMPLE: \n- Let a be a contract Forwarder with:\n  - function claim(PaymentSplitter ps) external { ps.release(payable(address(this))); }\n  - receive() external payable { payable(owner).call{value: address(this).balance}(""""""""); }  // forwards all received ETH out\n- Deploy PaymentSplitter with payees = [a], shares = [1].\n- Send 10 ETH to PaymentSplitter.\n- Call a.claim(ps). This makes msg.sender == a for ps.release(a), so it does not revert. Pre-call, releasable(a) = 10 ETH. release() computes payment = 10 ETH, updates accounting, then calls a with 10 ETH. a’s receive forwards the 10 ETH to owner and returns success; release() returns successfully.\n- Final state: balance(a) has not increased (it is 0), but releasable(a) before the call was 10 ETH. Hence the balance of a did not increase by releasable(a)."
"8","release-balance-payee","True","FALSE","release sends value to the payee via a low-level call (release: (bool success, ) = account.call{value: payment}(""""""""); require(success);). The callee (account) can execute arbitrary code on receipt and immediately forward the received ETH elsewhere, so the net balance of account after the call need not increase by releasable(account). The contract does not and cannot enforce the payee’s final balance increase.","- Let payees = [EOA_owner, MaliciousPayee], shares = [1,1], deployed by EOA_owner (satisfies “first payee must be the owner”).\n- MaliciousPayee:\n  receive() external payable { payable(EOA_sink).call{value: msg.value}(""""""""); }\n- Send 2 wei to the PaymentSplitter.\n- Before calling release, releasable(MaliciousPayee) = (2 * 1) / 2 - 0 = 1 wei.\n- Call release(MaliciousPayee). PaymentSplitter computes payment=1, updates accounting, and calls MaliciousPayee with 1 wei. MaliciousPayee immediately forwards that 1 wei to EOA_sink and returns successfully; release does not revert.\n- After the call, MaliciousPayee’s balance has not increased by 1 wei (it forwarded it), violating the property.","89.0934190750122","20000","ANSWER: FALSE\nEXPLANATION: release sends value to the payee via a low-level call (release: (bool success, ) = account.call{value: payment}(""""""""); require(success);). The callee (account) can execute arbitrary code on receipt and immediately forward the received ETH elsewhere, so the net balance of account after the call need not increase by releasable(account). The contract does not and cannot enforce the payee’s final balance increase.\nCOUNTEREXAMPLE:\n- Let payees = [EOA_owner, MaliciousPayee], shares = [1,1], deployed by EOA_owner (satisfies “first payee must be the owner”).\n- MaliciousPayee:\n  receive() external payable { payable(EOA_sink).call{value: msg.value}(""""""""); }\n- Send 2 wei to the PaymentSplitter.\n- Before calling release, releasable(MaliciousPayee) = (2 * 1) / 2 - 0 = 1 wei.\n- Call release(MaliciousPayee). PaymentSplitter computes payment=1, updates accounting, and calls MaliciousPayee with 1 wei. MaliciousPayee immediately forwards that 1 wei to EOA_sink and returns successfully; release does not revert.\n- After the call, MaliciousPayee’s balance has not increased by 1 wei (it forwarded it), violating the property."
"9","release-balance-payee","True","FALSE","The function release(account) transfers releasable(account) via a low-level call to account (release: account.call{value: payment}("""""""")). Because this external call allows arbitrary code execution in account’s fallback/receive, account can immediately forward the received ETH elsewhere before release returns. Therefore, after a non-reverting call to release(account), the final balance of account need not have increased by releasable(account).","- Deploy PaymentSplitter with payees [OwnerEOA, Drainer], shares [1, 1]. OwnerEOA is the deployer (as required by constructor).\n- Drainer is a contract with:\n  receive() external payable { (bool,)= OwnerEOA.call{value: msg.value}(""""""""); }\n- Send 10 wei to the PaymentSplitter.\n- Before calling, releasable(Drainer) = (10 * 1) / 2 - 0 = 5 wei.\n- Call release(payable(Drainer)).\n  - PaymentSplitter transfers 5 wei to Drainer.\n  - Drainer’s receive forwards the 5 wei immediately to OwnerEOA, then returns successfully.\n  - release finishes without reverting.\n- After the call, Drainer’s balance increased by 0, not by releasable(Drainer)=5.","108.22584962844849","20000","ANSWER: FALSE\nEXPLANATION: The function release(account) transfers releasable(account) via a low-level call to account (release: account.call{value: payment}("""""""")). Because this external call allows arbitrary code execution in account’s fallback/receive, account can immediately forward the received ETH elsewhere before release returns. Therefore, after a non-reverting call to release(account), the final balance of account need not have increased by releasable(account).\nCOUNTEREXAMPLE:\n- Deploy PaymentSplitter with payees [OwnerEOA, Drainer], shares [1, 1]. OwnerEOA is the deployer (as required by constructor).\n- Drainer is a contract with:\n  receive() external payable { (bool,)= OwnerEOA.call{value: msg.value}(""""""""); }\n- Send 10 wei to the PaymentSplitter.\n- Before calling, releasable(Drainer) = (10 * 1) / 2 - 0 = 5 wei.\n- Call release(payable(Drainer)).\n  - PaymentSplitter transfers 5 wei to Drainer.\n  - Drainer’s receive forwards the 5 wei immediately to OwnerEOA, then returns successfully.\n  - release finishes without reverting.\n- After the call, Drainer’s balance increased by 0, not by releasable(Drainer)=5."
"10","release-balance-payee","True","FALSE","In release, the contract sends ETH via a low-level call to the payee (release -> account.call{value: payment}("""""""")). This gives the payee arbitrary code execution during the transfer. The payee can immediately forward the received ETH elsewhere (e.g., back to the splitter via receive, which will not revert due to stateCheck), so after the non-reverting call to release(a), the payee’s final balance need not have increased by releasable(a). Relevant code: release and its low-level call, and receive which accepts ETH unconditionally subject to stateCheck.","- Deploy PaymentSplitter with payees = [Attack], shares = [1].\n- Fund the splitter with 1 ether.\n- Attack is a contract with:\n  - receive() external payable { (bool ok,) = address(splitter).call{value: msg.value}(""""""""); require(ok); }\n- Before calling release, releasable(Attack) = 1 ether.\n- Call release(payable(Attack)). PaymentSplitter sends 1 ether to Attack; Attack’s receive immediately sends the 1 ether back to the splitter (receive on splitter succeeds). The call does not revert.\n- Final state: Attack’s balance is unchanged (0), while releasable(Attack) pre-call was 1 ether. Hence the balance of Attack did not increase by releasable(Attack).","102.93168592453003","20000","ANSWER: FALSE\nEXPLANATION: In release, the contract sends ETH via a low-level call to the payee (release -> account.call{value: payment}("""""""")). This gives the payee arbitrary code execution during the transfer. The payee can immediately forward the received ETH elsewhere (e.g., back to the splitter via receive, which will not revert due to stateCheck), so after the non-reverting call to release(a), the payee’s final balance need not have increased by releasable(a). Relevant code: release and its low-level call, and receive which accepts ETH unconditionally subject to stateCheck.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with payees = [Attack], shares = [1].\n- Fund the splitter with 1 ether.\n- Attack is a contract with:\n  - receive() external payable { (bool ok,) = address(splitter).call{value: msg.value}(""""""""); require(ok); }\n- Before calling release, releasable(Attack) = 1 ether.\n- Call release(payable(Attack)). PaymentSplitter sends 1 ether to Attack; Attack’s receive immediately sends the 1 ether back to the splitter (receive on splitter succeeds). The call does not revert.\n- Final state: Attack’s balance is unchanged (0), while releasable(Attack) pre-call was 1 ether. Hence the balance of Attack did not increase by releasable(Attack)."
"4","release-balance-payee","False","FALSE","In release, after computing payment and updating state, the contract performs a low-level call to account.call{value: payment}("""""""") without checking success or reverting on failure. Thus, if the recipient reverts on receiving ETH, release does not revert and the recipient’s balance does not increase, contradicting the property. See function release: it updates totalReleased and released, then does account.call{value: payment}("""""""") without require on the return value.","- Let R be a payee contract whose fallback/receive function always reverts.\n- Deploy PaymentSplitter with payees = [R], shares = [1].\n- Send 1 ether to PaymentSplitter (so address(this).balance = 1 ether).\n- Pre-call: releasable(R) = 1 ether.\n- Call release(payable(R)). The internal call to R reverts, but release does not revert because it ignores the call’s return value. State is updated (totalReleased and released[R] increased by 1 ether), but no ETH leaves the splitter; R’s balance remains unchanged.\n- Post-call: R’s balance did not increase by releasable(R) (which is 1 ether both pre- and post-call here), violating the property.","257.6003465652466","20000","ANSWER: FALSE\nEXPLANATION: In release, after computing payment and updating state, the contract performs a low-level call to account.call{value: payment}("""""""") without checking success or reverting on failure. Thus, if the recipient reverts on receiving ETH, release does not revert and the recipient’s balance does not increase, contradicting the property. See function release: it updates totalReleased and released, then does account.call{value: payment}("""""""") without require on the return value.\nCOUNTEREXAMPLE: \n- Let R be a payee contract whose fallback/receive function always reverts.\n- Deploy PaymentSplitter with payees = [R], shares = [1].\n- Send 1 ether to PaymentSplitter (so address(this).balance = 1 ether).\n- Pre-call: releasable(R) = 1 ether.\n- Call release(payable(R)). The internal call to R reverts, but release does not revert because it ignores the call’s return value. State is updated (totalReleased and released[R] increased by 1 ether), but no ETH leaves the splitter; R’s balance remains unchanged.\n- Post-call: R’s balance did not increase by releasable(R) (which is 1 ether both pre- and post-call here), violating the property.\n"
"4","release-not-revert","True","TRUE","For any address in payees, addPayee enforces shares[account] > 0, so the first require in release passes. If releasable(account) > 0, then payment != 0 and the second require passes. The final transfer uses a low-level call without checking the return value (account.call{value: payment}("""""""")), so even if the external call fails, release does not revert. Relevant parts: addPayee (enforces positive shares), releasable (computes due amount), and release (require checks and unchecked call).","N/A","93.99473714828491","20000","ANSWER: TRUE\nEXPLANATION: For any address in payees, addPayee enforces shares[account] > 0, so the first require in release passes. If releasable(account) > 0, then payment != 0 and the second require passes. The final transfer uses a low-level call without checking the return value (account.call{value: payment}("""""""")), so even if the external call fails, release does not revert. Relevant parts: addPayee (enforces positive shares), releasable (computes due amount), and release (require checks and unchecked call).\nCOUNTEREXAMPLE: N/A"
"1","release-not-revert","False","FALSE","In release(), after verifying payment > 0, the function performs a low-level call to transfer ETH and then requires success (bool success, ) = account.call{value: payment}(""""""""); require(success);. Since addPayee() imposes no constraint that a payee be able to accept ETH, a payee can be a contract whose receive/fallback reverts, causing release() to revert even when releasable(a) > 0.","- Deploy a contract Rejector with: receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees_ = [address(Rejector)] and shares_ = [1].\n- Send 1 ETH to PaymentSplitter.\n- Now releasable(Rejector) > 0.\n- Call release(payable(address(Rejector))). The low-level call to Rejector reverts, making success false and triggering require(success), so release() reverts.","21.2862491607666","20000","ANSWER: FALSE\nEXPLANATION: In release(), after verifying payment > 0, the function performs a low-level call to transfer ETH and then requires success (bool success, ) = account.call{value: payment}(""""""""); require(success);. Since addPayee() imposes no constraint that a payee be able to accept ETH, a payee can be a contract whose receive/fallback reverts, causing release() to revert even when releasable(a) > 0.\nCOUNTEREXAMPLE: \n- Deploy a contract Rejector with: receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees_ = [address(Rejector)] and shares_ = [1].\n- Send 1 ETH to PaymentSplitter.\n- Now releasable(Rejector) > 0.\n- Call release(payable(address(Rejector))). The low-level call to Rejector reverts, making success false and triggering require(success), so release() reverts."
"2","release-not-revert","False","FALSE","release(address) requires the ETH transfer to succeed: it performs a low-level call and then require(success) (release: account.call{value: payment}(""""""""); require(success);). addPayee imposes no restriction that a payee can accept ETH (only non-zero, unique, with shares > 0). Therefore, a payee can be a contract that reverts on receiving ETH, making release revert even when releasable(a) > 0.","- Deploy a contract Rejector with: contract Rejector { receive() external payable { revert(); } }\n- Deploy PaymentSplitter with payee1 = Rejector’s address (shares1 = 1), payee2 and payee3 any valid addresses (shares > 0).\n- Send 1 ether to PaymentSplitter.\n- For payee1, releasable(payee1) > 0.\n- Call release(payee1). The low-level transfer to Rejector fails (success = false), triggering require(success) and causing release to revert.","68.1466383934021","20000","ANSWER: FALSE\nEXPLANATION: release(address) requires the ETH transfer to succeed: it performs a low-level call and then require(success) (release: account.call{value: payment}(""""""""); require(success);). addPayee imposes no restriction that a payee can accept ETH (only non-zero, unique, with shares > 0). Therefore, a payee can be a contract that reverts on receiving ETH, making release revert even when releasable(a) > 0.\nCOUNTEREXAMPLE: \n- Deploy a contract Rejector with: contract Rejector { receive() external payable { revert(); } }\n- Deploy PaymentSplitter with payee1 = Rejector’s address (shares1 = 1), payee2 and payee3 any valid addresses (shares > 0).\n- Send 1 ether to PaymentSplitter.\n- For payee1, releasable(payee1) > 0.\n- Call release(payee1). The low-level transfer to Rejector fails (success = false), triggering require(success) and causing release to revert."
"3","release-not-revert","False","FALSE","release(account) performs a low-level ETH transfer and requires success (see release: (bool success, ) = account.call{value: payment}(""""""""); require(success);). If the payee is a contract that rejects ETH (reverts in receive/fallback or has no payable handler), the transfer fails even when releasable(account) > 0, causing release to revert.","- Deploy a contract MaliciousPayee with receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees [MaliciousPayee, P2, P3].\n- Send 3 wei to PaymentSplitter.\n- Then releasable(MaliciousPayee) = 1 > 0.\n- Call release(MaliciousPayee). The internal call to MaliciousPayee reverts, success == false, and release reverts on require(success).","32.89642310142517","20000","ANSWER: FALSE\nEXPLANATION: release(account) performs a low-level ETH transfer and requires success (see release: (bool success, ) = account.call{value: payment}(""""""""); require(success);). If the payee is a contract that rejects ETH (reverts in receive/fallback or has no payable handler), the transfer fails even when releasable(account) > 0, causing release to revert.\nCOUNTEREXAMPLE: \n- Deploy a contract MaliciousPayee with receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees [MaliciousPayee, P2, P3].\n- Send 3 wei to PaymentSplitter.\n- Then releasable(MaliciousPayee) = 1 > 0.\n- Call release(MaliciousPayee). The internal call to MaliciousPayee reverts, success == false, and release reverts on require(success)."
"5","release-not-revert","False","FALSE","The release function sends ETH via a low-level call and requires the call to succeed: (bool success, ) = account.call{value: payment}(""""""""); require(success);. If a payee is a contract that rejects ETH, release will revert even when releasable(account) > 0 (which occurs, for example, when there is a single payee funded with ETH).","- Deploy a contract RevertingReceiver with receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees = [RevertingReceiver], shares = [1], and send 1 ether to the PaymentSplitter during deployment or via receive().\n- Now releasable(RevertingReceiver) returns 1 ether > 0.\n- Call release(payable(RevertingReceiver)); it reverts at require(success) because the payee rejects the transfer.","48.74207806587219","20000","ANSWER: FALSE\nEXPLANATION: The release function sends ETH via a low-level call and requires the call to succeed: (bool success, ) = account.call{value: payment}(""""""""); require(success);. If a payee is a contract that rejects ETH, release will revert even when releasable(account) > 0 (which occurs, for example, when there is a single payee funded with ETH).\nCOUNTEREXAMPLE: \n- Deploy a contract RevertingReceiver with receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees = [RevertingReceiver], shares = [1], and send 1 ether to the PaymentSplitter during deployment or via receive().\n- Now releasable(RevertingReceiver) returns 1 ether > 0.\n- Call release(payable(RevertingReceiver)); it reverts at require(success) because the payee rejects the transfer."
"6","release-not-revert","False","FALSE","In release(), after computing a positive payment, the contract sends ETH using a low-level call and then requires success (require(success);). If the payee is a contract that rejects ETH (e.g., no payable receive/fallback or explicitly reverts), success will be false and release() will revert despite releasable(a) > 0. Relevant code: release() external call and require(success); releasable() calculation uses pendingPayment().","- Deploy a contract RevertingPayee with receive() external payable { revert(""""""""no funds""""""""); } (or no payable receive/fallback).\n- Deploy PaymentSplitter with payees = [address(RevertingPayee)] and shares = [1].\n- Send 1 ether to the PaymentSplitter.\n- Now releasable(address(RevertingPayee)) > 0.\n- Call release(payable(address(RevertingPayee))). The low-level call to RevertingPayee fails, success == false, and require(success) reverts, violating the property.","55.7402606010437","20000","ANSWER: FALSE\nEXPLANATION: In release(), after computing a positive payment, the contract sends ETH using a low-level call and then requires success (require(success);). If the payee is a contract that rejects ETH (e.g., no payable receive/fallback or explicitly reverts), success will be false and release() will revert despite releasable(a) > 0. Relevant code: release() external call and require(success); releasable() calculation uses pendingPayment().\nCOUNTEREXAMPLE: \n- Deploy a contract RevertingPayee with receive() external payable { revert(""""""""no funds""""""""); } (or no payable receive/fallback).\n- Deploy PaymentSplitter with payees = [address(RevertingPayee)] and shares = [1].\n- Send 1 ether to the PaymentSplitter.\n- Now releasable(address(RevertingPayee)) > 0.\n- Call release(payable(address(RevertingPayee))). The low-level call to RevertingPayee fails, success == false, and require(success) reverts, violating the property."
"7","release-not-revert","False","FALSE","release enforces two conditions that can cause a revert even when releasable(account) > 0: (1) require(msg.sender == account) in release, and (2) the transfer require(success) after account.call{value: payment}(""""""""). Thus, a payee with positive releasable can still have release revert, e.g., if called by a different sender or if the payee is a contract that rejects ETH.","- Deploy a payee contract R with receive() external payable { revert(""""""""reject ETH""""""""); } and a function withdraw(address ps) external { PaymentSplitter(ps).release(payable(address(this))); }.\n- Deploy PaymentSplitter with payees = [address(R)] and shares = [1].\n- Send 1 ether to the PaymentSplitter.\n- Now releasable(address(R)) > 0.\n- Call R.withdraw(ps). This calls release(address(R)) with msg.sender == account, so it passes the caller and shares checks. The function then executes account.call{value: payment}(""""""""), which triggers R’s reverting receive, making success == false and causing release to revert on require(success).","173.32633638381958","20000","ANSWER: FALSE\nEXPLANATION: release enforces two conditions that can cause a revert even when releasable(account) > 0: (1) require(msg.sender == account) in release, and (2) the transfer require(success) after account.call{value: payment}(""""""""). Thus, a payee with positive releasable can still have release revert, e.g., if called by a different sender or if the payee is a contract that rejects ETH.\nCOUNTEREXAMPLE: \n- Deploy a payee contract R with receive() external payable { revert(""""""""reject ETH""""""""); } and a function withdraw(address ps) external { PaymentSplitter(ps).release(payable(address(this))); }.\n- Deploy PaymentSplitter with payees = [address(R)] and shares = [1].\n- Send 1 ether to the PaymentSplitter.\n- Now releasable(address(R)) > 0.\n- Call R.withdraw(ps). This calls release(address(R)) with msg.sender == account, so it passes the caller and shares checks. The function then executes account.call{value: payment}(""""""""), which triggers R’s reverting receive, making success == false and causing release to revert on require(success)."
"8","release-not-revert","False","FALSE","In release(), after computing payment = releasable(account), if payment != 0 the contract performs a low-level call to account and then requires success (require(success);). A payee can be a contract that reverts on receiving ETH, causing release(account) to revert even when releasable(account) > 0. Nothing in addPayee or the constructor prevents such a payee.","- Create a contract Reverter with receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees = [deployerEOA, address(Reverter)] and shares = [1, 1].\n- Send 2 wei to the PaymentSplitter.\n- Now releasable(address(Reverter)) = floor((balance + totalReleased) * 1 / 2) - 0 = floor(2/2) = 1 > 0.\n- Call release(payable(address(Reverter))). The low-level call to Reverter reverts, so require(success) in release() reverts.","32.60283303260803","20000","ANSWER: FALSE\nEXPLANATION: In release(), after computing payment = releasable(account), if payment != 0 the contract performs a low-level call to account and then requires success (require(success);). A payee can be a contract that reverts on receiving ETH, causing release(account) to revert even when releasable(account) > 0. Nothing in addPayee or the constructor prevents such a payee.\nCOUNTEREXAMPLE: \n- Create a contract Reverter with receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees = [deployerEOA, address(Reverter)] and shares = [1, 1].\n- Send 2 wei to the PaymentSplitter.\n- Now releasable(address(Reverter)) = floor((balance + totalReleased) * 1 / 2) - 0 = floor(2/2) = 1 > 0.\n- Call release(payable(address(Reverter))). The low-level call to Reverter reverts, so require(success) in release() reverts."
"9","release-not-revert","False","FALSE","In release(), if payment != 0 the contract performs a low-level call to account with value and requires success (require(success)). If the payee is a contract that rejects ETH (no payable receive/fallback or explicitly reverts), the call fails and release reverts despite releasable(account) > 0.","- Create a contract Rejector with a reverting receive:\n  contract Rejector { receive() external payable { revert(); } }\n- Deploy PaymentSplitter with payees_ = [deployerEOA, address(Rejector)] and shares_ = [1, 1], sending 1 ether to the splitter (either during construction or afterward).\n- Then releasable(address(Rejector)) = 0.5 ether > 0.\n- Call release(payable(address(Rejector))). In release(), the call to account.call{value: payment}("""""""") fails because Rejector reverts, causing require(success) to revert.","34.89457035064697","20000","ANSWER: FALSE\nEXPLANATION: In release(), if payment != 0 the contract performs a low-level call to account with value and requires success (require(success)). If the payee is a contract that rejects ETH (no payable receive/fallback or explicitly reverts), the call fails and release reverts despite releasable(account) > 0.\nCOUNTEREXAMPLE: \n- Create a contract Rejector with a reverting receive:\n  contract Rejector { receive() external payable { revert(); } }\n- Deploy PaymentSplitter with payees_ = [deployerEOA, address(Rejector)] and shares_ = [1, 1], sending 1 ether to the splitter (either during construction or afterward).\n- Then releasable(address(Rejector)) = 0.5 ether > 0.\n- Call release(payable(address(Rejector))). In release(), the call to account.call{value: payment}("""""""") fails because Rejector reverts, causing require(success) to revert."
"10","release-not-revert","False","FALSE","Even if releasable(a) > 0, release(a) can revert because it performs a low-level ETH transfer and requires success. If the payee is a contract that rejects ETH, the call fails and release reverts. See release(): it does account.call{value: payment}("""""""") and then require(success). Payees can be arbitrary non-zero addresses (addPayee only checks non-zero and unique), so they can be such rejecting contracts. releasable() can validly return > 0 when stateCheck() holds.","- Deploy a contract RevertingPayee with receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees = [RevertingPayee] and shares = [1].\n- Send 100 wei to PaymentSplitter (ensuring address(this).balance + totalReleased <= MAX_RECEIVED so stateCheck() stays true).\n- Call releasable(RevertingPayee) -> returns 100 (> 0).\n- Call release(RevertingPayee) -> the low-level call to RevertingPayee reverts, making success == false, so require(success) fails and the transaction reverts.","30.29214882850647","20000","ANSWER: FALSE\nEXPLANATION: Even if releasable(a) > 0, release(a) can revert because it performs a low-level ETH transfer and requires success. If the payee is a contract that rejects ETH, the call fails and release reverts. See release(): it does account.call{value: payment}("""""""") and then require(success). Payees can be arbitrary non-zero addresses (addPayee only checks non-zero and unique), so they can be such rejecting contracts. releasable() can validly return > 0 when stateCheck() holds.\nCOUNTEREXAMPLE: \n- Deploy a contract RevertingPayee with receive() external payable { revert(); }.\n- Deploy PaymentSplitter with payees = [RevertingPayee] and shares = [1].\n- Send 100 wei to PaymentSplitter (ensuring address(this).balance + totalReleased <= MAX_RECEIVED so stateCheck() stays true).\n- Call releasable(RevertingPayee) -> returns 100 (> 0).\n- Call release(RevertingPayee) -> the low-level call to RevertingPayee reverts, making success == false, so require(success) fails and the transaction reverts."
"1","release-not-revert-receive","True","TRUE","In release(), the only revert conditions are: (1) require(shares[account] > 0), which holds because addPayee enforces nonzero shares when populating payees; (2) require(payment != 0), which holds by the precondition releasable(a) > 0; and (3) require(success) on the ETH transfer. Since releasable() computes payment from pendingPayment(totalReceived = balance + totalReleased), each individual payment is ≤ the current balance, and with a recipient that “just accepts all ETH,” the low-level call succeeds. Relevant code: release(), releasable(), pendingPayment(), addPayee().","N/A","62.801055908203125","20000","ANSWER: TRUE\nEXPLANATION: In release(), the only revert conditions are: (1) require(shares[account] > 0), which holds because addPayee enforces nonzero shares when populating payees; (2) require(payment != 0), which holds by the precondition releasable(a) > 0; and (3) require(success) on the ETH transfer. Since releasable() computes payment from pendingPayment(totalReceived = balance + totalReleased), each individual payment is ≤ the current balance, and with a recipient that “just accepts all ETH,” the low-level call succeeds. Relevant code: release(), releasable(), pendingPayment(), addPayee().\nCOUNTEREXAMPLE: N/A"
"2","release-not-revert-receive","True","FALSE","The function release(address payable) is not payable (no payable modifier). A call to a nonpayable function that includes ETH reverts before executing the body. Thus, even if a is a payee and releasable(a) > 0, release(a) can still revert if the caller sends a nonzero msg.value. See the function signature “function release(address payable account) public virtual” and Solidity’s nonpayable behavior.","- Deploy with payees A, B, C each having shares > 0 (e.g., 1,1,1).\n- Send 3 wei to the contract so releasable(B) == 1 > 0.\n- Call release(B) while attaching any ETH (e.g., msg.value = 1 wei). Because release is nonpayable, the call reverts despite B being a payee and having releasable > 0 and its receive accepting ETH.","67.2889952659607","20000","ANSWER: FALSE\nEXPLANATION: The function release(address payable) is not payable (no payable modifier). A call to a nonpayable function that includes ETH reverts before executing the body. Thus, even if a is a payee and releasable(a) > 0, release(a) can still revert if the caller sends a nonzero msg.value. See the function signature “function release(address payable account) public virtual” and Solidity’s nonpayable behavior.\nCOUNTEREXAMPLE: \n- Deploy with payees A, B, C each having shares > 0 (e.g., 1,1,1).\n- Send 3 wei to the contract so releasable(B) == 1 > 0.\n- Call release(B) while attaching any ETH (e.g., msg.value = 1 wei). Because release is nonpayable, the call reverts despite B being a payee and having releasable > 0 and its receive accepting ETH."
"3","release-not-revert-receive","True","TRUE","In release(), all potential revert points are satisfied under the stated preconditions: (1) shares[account] > 0 and isPayee(account) hold for any payee set in the constructor; (2) releasable(account) > 0 ensures the """"""""payment != 0"""""""" check passes; (3) payment is computed as (address(this).balance + totalReleased) / 3 - released[account] (releasable → pendingPayment), which is always ≤ address(this).balance, so the subsequent low-level call with value payment succeeds if the recipient accepts ETH; and (4) given releasable() computed successfully (no overflow in address(this).balance + totalReleased), totalReleased += payment also cannot overflow because payment ≤ address(this).balance.","N/A","110.95089435577393","20000","ANSWER: TRUE\nEXPLANATION: In release(), all potential revert points are satisfied under the stated preconditions: (1) shares[account] > 0 and isPayee(account) hold for any payee set in the constructor; (2) releasable(account) > 0 ensures the """"""""payment != 0"""""""" check passes; (3) payment is computed as (address(this).balance + totalReleased) / 3 - released[account] (releasable → pendingPayment), which is always ≤ address(this).balance, so the subsequent low-level call with value payment succeeds if the recipient accepts ETH; and (4) given releasable() computed successfully (no overflow in address(this).balance + totalReleased), totalReleased += payment also cannot overflow because payment ≤ address(this).balance.\nCOUNTEREXAMPLE: N/A"
"4","release-not-revert-receive","True","TRUE","In release(address payable account), the only revert conditions are: (1) shares[account] > 0 (checked by require at the start), and (2) releasable(account) != 0 (payment != 0). If a is in payees, then shares[a] > 0 (addPayee requires shares_ > 0). If releasable(a) > 0, then the second require passes. The ETH transfer uses account.call{value: payment}("""""""") and its return value is ignored, so even a failing receive would not revert; with an accepting receive, it certainly won’t revert.","N/A","37.28197264671326","20000","ANSWER: TRUE\nEXPLANATION: In release(address payable account), the only revert conditions are: (1) shares[account] > 0 (checked by require at the start), and (2) releasable(account) != 0 (payment != 0). If a is in payees, then shares[a] > 0 (addPayee requires shares_ > 0). If releasable(a) > 0, then the second require passes. The ETH transfer uses account.call{value: payment}("""""""") and its return value is ignored, so even a failing receive would not revert; with an accepting receive, it certainly won’t revert.\nCOUNTEREXAMPLE: N/A"
"5","release-not-revert-receive","True","TRUE","In release(account): it reverts only if (1) shares[account] == 0, (2) releasable(account) == 0, or (3) the value-transfer low-level call fails. Given a is in payees, shares[a] > 0 (addPayee enforces shares_ > 0). Given releasable(a) > 0, the second revert cannot trigger. pendingPayment divides before multiplying (pendingPayment), so with multiple payees shares[a] / totalShares == 0 and releasable(a) is 0 (or would revert if alreadyReleased > 0). Thus releasable(a) > 0 can only occur when shares[a] / totalShares == 1, i.e., the single-payee case, where payment equals address(this).balance. Since a’s receive accepts ETH, the low-level call succeeds, so release(a) does not revert.","N/A","287.5909631252289","20000","ANSWER: TRUE\nEXPLANATION: In release(account): it reverts only if (1) shares[account] == 0, (2) releasable(account) == 0, or (3) the value-transfer low-level call fails. Given a is in payees, shares[a] > 0 (addPayee enforces shares_ > 0). Given releasable(a) > 0, the second revert cannot trigger. pendingPayment divides before multiplying (pendingPayment), so with multiple payees shares[a] / totalShares == 0 and releasable(a) is 0 (or would revert if alreadyReleased > 0). Thus releasable(a) > 0 can only occur when shares[a] / totalShares == 1, i.e., the single-payee case, where payment equals address(this).balance. Since a’s receive accepts ETH, the low-level call succeeds, so release(a) does not revert.\nCOUNTEREXAMPLE: N/A"
"6","release-not-revert-receive","True","TRUE","Given a is a payee (implying shares[a] > 0 via addPayee) and releasable(a) > 0, release(a) will not revert: it passes the checks require(shares[account] > 0) and require(payment != 0). The payment amount is computed as releasable(account) and, by construction of totalReceived = balance + totalReleased and the payment formula in pendingPayment, any individual payment is <= contract balance, so the value transfer (account.call{value: payment}("""""""")) will succeed if the recipient “just accepts all ETH.” Thus require(success) will also pass.","N/A","61.41966438293457","20000","ANSWER: TRUE\nEXPLANATION: Given a is a payee (implying shares[a] > 0 via addPayee) and releasable(a) > 0, release(a) will not revert: it passes the checks require(shares[account] > 0) and require(payment != 0). The payment amount is computed as releasable(account) and, by construction of totalReceived = balance + totalReleased and the payment formula in pendingPayment, any individual payment is <= contract balance, so the value transfer (account.call{value: payment}("""""""")) will succeed if the recipient “just accepts all ETH.” Thus require(success) will also pass.\nCOUNTEREXAMPLE: N/A"
"8","release-not-revert-receive","True","TRUE","In release, the only revert paths are: (1) require(shares[account] > 0), which holds if a is in payees (addPayee enforces non-zero shares); and (2) require(success) after sending payment via account.call{value: payment}(""""""""). If releasable(a) > 0, the code takes the payment != 0 branch and does not trigger the else path. The payment equals pendingPayment computed in releasable/pendingPayment as (address(this).balance + totalReleased) * shares[a] / totalShares - released[a], which is non-negative and, by construction, cannot exceed address(this).balance (the sum of all payees’ releasables is ≤ the current balance). Given that a’s receive accepts ETH, the call succeeds, so release(a) does not revert.","N/A","87.69239735603333","20000","ANSWER: TRUE\nEXPLANATION: In release, the only revert paths are: (1) require(shares[account] > 0), which holds if a is in payees (addPayee enforces non-zero shares); and (2) require(success) after sending payment via account.call{value: payment}(""""""""). If releasable(a) > 0, the code takes the payment != 0 branch and does not trigger the else path. The payment equals pendingPayment computed in releasable/pendingPayment as (address(this).balance + totalReleased) * shares[a] / totalShares - released[a], which is non-negative and, by construction, cannot exceed address(this).balance (the sum of all payees’ releasables is ≤ the current balance). Given that a’s receive accepts ETH, the call succeeds, so release(a) does not revert.\nCOUNTEREXAMPLE: N/A"
"9","release-not-revert-receive","True","TRUE","In release(account), when releasable(account) > 0, the function executes the payment branch: it updates accounting and then performs (bool success, ) = account.call{value: payment}(""""""""); require(success); The only revert path in this branch is if the call to account fails. Given the premise that account (a) is a payee and its receive accepts all ETH, the call succeeds and the function does not revert. The zero-payment else branch (which could send 1 wei to owner) is not taken when releasable(a) > 0.","N/A","142.5555431842804","20000","ANSWER: TRUE\nEXPLANATION: In release(account), when releasable(account) > 0, the function executes the payment branch: it updates accounting and then performs (bool success, ) = account.call{value: payment}(""""""""); require(success); The only revert path in this branch is if the call to account fails. Given the premise that account (a) is a payee and its receive accepts all ETH, the call succeeds and the function does not revert. The zero-payment else branch (which could send 1 wei to owner) is not taken when releasable(a) > 0.\nCOUNTEREXAMPLE: N/A"
"10","release-not-revert-receive","True","TRUE","In release(account), the only revert conditions are: stateCheck() (line in release), shares[account] > 0, payment != 0, and the transfer success (require(success)). If a is in payees, then shares[a] > 0 due to addPayee’s checks. The precondition releasable(a) > 0 implies stateCheck() holds (releasable and pendingPayment both require stateCheck()) and guarantees payment != 0. The computed payment never exceeds the contract balance (classic PaymentSplitter invariant using totalReceived = balance + totalReleased). Finally, with a receive that “just accepts all ETH,” the low-level call succeeds. Hence release(a) does not revert.","N/A","102.54240369796753","20000","ANSWER: TRUE\nEXPLANATION: In release(account), the only revert conditions are: stateCheck() (line in release), shares[account] > 0, payment != 0, and the transfer success (require(success)). If a is in payees, then shares[a] > 0 due to addPayee’s checks. The precondition releasable(a) > 0 implies stateCheck() holds (releasable and pendingPayment both require stateCheck()) and guarantees payment != 0. The computed payment never exceeds the contract balance (classic PaymentSplitter invariant using totalReceived = balance + totalReleased). Finally, with a receive that “just accepts all ETH,” the low-level call succeeds. Hence release(a) does not revert.\nCOUNTEREXAMPLE: N/A"
"7","release-not-revert-receive","False","FALSE","release requires msg.sender == account. Even if a is a payee, accepts ETH, and releasable(a) > 0, the call reverts unless a itself is the caller (see release: require(msg.sender == account, """"""""PaymentSplitter: can only be called by the payee"""""""")).","- Deploy with payees = [Alice], shares = [1].\n- Fund the contract with 1 ether so releasable(Alice) > 0.\n- Bob (not Alice) calls release(Alice).\n- The call reverts with """"""""PaymentSplitter: can only be called by the payee"""""""".","15.434383869171143","20000","ANSWER: FALSE\nEXPLANATION: release requires msg.sender == account. Even if a is a payee, accepts ETH, and releasable(a) > 0, the call reverts unless a itself is the caller (see release: require(msg.sender == account, """"""""PaymentSplitter: can only be called by the payee"""""""")).\nCOUNTEREXAMPLE: \n- Deploy with payees = [Alice], shares = [1].\n- Fund the contract with 1 ether so releasable(Alice) > 0.\n- Bob (not Alice) calls release(Alice).\n- The call reverts with """"""""PaymentSplitter: can only be called by the payee""""""""."
"1","release-release-revert","True","TRUE","release requires payment = releasable(account) to be nonzero (require(payment != 0)). After a successful release, totalReleased and released[account] are increased by payment, and payment is sent out. With no ETH received by the contract between calls, totalReceived = address(this).balance + totalReleased remains unchanged (balance decreases by payment while totalReleased increases by the same payment). Thus releasable(account) becomes zero, and a second call to release(account) reverts with """"""""PaymentSplitter: account is not due payment"""""""" (see releasable, pendingPayment, and release).","N/A","86.15416622161865","20000","ANSWER: TRUE\nEXPLANATION: release requires payment = releasable(account) to be nonzero (require(payment != 0)). After a successful release, totalReleased and released[account] are increased by payment, and payment is sent out. With no ETH received by the contract between calls, totalReceived = address(this).balance + totalReleased remains unchanged (balance decreases by payment while totalReleased increases by the same payment). Thus releasable(account) becomes zero, and a second call to release(account) reverts with """"""""PaymentSplitter: account is not due payment"""""""" (see releasable, pendingPayment, and release).\nCOUNTEREXAMPLE: N/A"
"2","release-release-revert","True","FALSE","The second call to release(a) can succeed if new ETH is received by the contract during the first call. In release(), state is updated and then an external call is made to account (account.call{value: payment}("""""""")). During this callback, the payee can send ETH to the contract via receive() (which is payable). Since releasable() uses totalReceived = address(this).balance + totalReleased, this additional ETH increases the next releasable amount even though no ETH was transferred to the contract between the two release calls.","- Deploy with payees A, B, C and shares 1, 1, 1 respectively, where A is a contract whose payable fallback, upon receiving ETH, immediately sends 3 wei to the PaymentSplitter.\n- Fund the PaymentSplitter with 3 wei.\n- Call release(A):\n  - Before callback: payment = floor((3 + 0) * 1 / 3) - 0 = 1 wei.\n  - State updates: totalReleased = 1; released[A] = 1.\n  - External call sends 1 wei to A; A’s fallback immediately sends 3 wei to PaymentSplitter (receive() accepts it).\n  - After the call: balance = 3 - 1 + 3 = 5; totalReleased = 1.\n- Without any ETH transfer to the contract between calls, call release(A) again:\n  - Now releasable(A) = floor((5 + 1) * 1 / 3) - 1 = floor(6/3) - 1 = 2 - 1 = 1 wei > 0, so the call does NOT revert.","104.6025652885437","20000","ANSWER: FALSE\nEXPLANATION: The second call to release(a) can succeed if new ETH is received by the contract during the first call. In release(), state is updated and then an external call is made to account (account.call{value: payment}("""""""")). During this callback, the payee can send ETH to the contract via receive() (which is payable). Since releasable() uses totalReceived = address(this).balance + totalReleased, this additional ETH increases the next releasable amount even though no ETH was transferred to the contract between the two release calls.\nCOUNTEREXAMPLE: \n- Deploy with payees A, B, C and shares 1, 1, 1 respectively, where A is a contract whose payable fallback, upon receiving ETH, immediately sends 3 wei to the PaymentSplitter.\n- Fund the PaymentSplitter with 3 wei.\n- Call release(A):\n  - Before callback: payment = floor((3 + 0) * 1 / 3) - 0 = 1 wei.\n  - State updates: totalReleased = 1; released[A] = 1.\n  - External call sends 1 wei to A; A’s fallback immediately sends 3 wei to PaymentSplitter (receive() accepts it).\n  - After the call: balance = 3 - 1 + 3 = 5; totalReleased = 1.\n- Without any ETH transfer to the contract between calls, call release(A) again:\n  - Now releasable(A) = floor((5 + 1) * 1 / 3) - 1 = floor(6/3) - 1 = 2 - 1 = 1 wei > 0, so the call does NOT revert.\n"
"3","release-release-revert","True","FALSE","In release(), totalReleased and released[account] are updated before the ETH transfer (release: totalReleased += payment; released[account] += payment). releasable(account) computes using totalReceived = address(this).balance + totalReleased, and pendingPayment returns (totalReceived / PAYEES) - alreadyReleased. If the payee is the contract itself, the value transfer to account.call{value: payment}("""""""") returns the ETH to the same balance (net balance unchanged), while totalReleased increases. Thus totalReceived increases between calls even without any external ETH deposit, enabling a second nonzero payment due to integer division rounding.","- Deploy PaymentSplitter with payees: [A = this contract’s address, B, C], and send 5 wei to the constructor.\n- Initial: balance = 5, totalReleased = 0, released[A] = 0.\n- First call: release(A):\n  - totalReceived = 5 + 0 = 5; payment = floor(5/3) - 0 = 1.\n  - Update: totalReleased = 1; released[A] = 1.\n  - Send 1 wei to A (the contract itself). Net balance remains 5; call succeeds.\n- Second call (no ETH sent to the contract in-between): release(A):\n  - totalReceived = balance + totalReleased = 5 + 1 = 6.\n  - payment = floor(6/3) - released[A] = 2 - 1 = 1 > 0.\n  - The second call does not revert, violating the property.","97.62573790550232","20000","ANSWER: FALSE\nEXPLANATION: In release(), totalReleased and released[account] are updated before the ETH transfer (release: totalReleased += payment; released[account] += payment). releasable(account) computes using totalReceived = address(this).balance + totalReleased, and pendingPayment returns (totalReceived / PAYEES) - alreadyReleased. If the payee is the contract itself, the value transfer to account.call{value: payment}("""""""") returns the ETH to the same balance (net balance unchanged), while totalReleased increases. Thus totalReceived increases between calls even without any external ETH deposit, enabling a second nonzero payment due to integer division rounding.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with payees: [A = this contract’s address, B, C], and send 5 wei to the constructor.\n- Initial: balance = 5, totalReleased = 0, released[A] = 0.\n- First call: release(A):\n  - totalReceived = 5 + 0 = 5; payment = floor(5/3) - 0 = 1.\n  - Update: totalReleased = 1; released[A] = 1.\n  - Send 1 wei to A (the contract itself). Net balance remains 5; call succeeds.\n- Second call (no ETH sent to the contract in-between): release(A):\n  - totalReceived = balance + totalReleased = 5 + 1 = 6.\n  - payment = floor(6/3) - released[A] = 2 - 1 = 1 > 0.\n  - The second call does not revert, violating the property."
"4","release-release-revert","True","FALSE","The function releasable uses totalReceived = address(this).balance + totalReleased. In release, totalReleased and released[account] are incremented before attempting the external payment, and the low-level call account.call{value: payment}("""""""") has its return value ignored. If the external transfer fails, the state remains updated while the balance is unchanged, increasing totalReceived and potentially making releasable(account) > 0 again due to integer division rounding. Thus, a second consecutive release can succeed (not revert) without any ETH being sent to the contract between calls.","- Setup: Deploy with two payees: A with 1 share and B with 2 shares (totalShares = 3). Let A be a contract that rejects ETH (no payable receive/fallback).\n- Fund the splitter with 5 wei.\n- Call 1: release(A).\n  - totalReceived = 5 + 0 = 5; payment1 = floor(5/3) - 0 = 1.\n  - State updated: totalReleased = 1, released[A] = 1.\n  - account.call sends 1 wei to A but fails; function does not revert.\n- No ETH is sent to the splitter between calls.\n- Call 2: release(A).\n  - totalReceived = balance + totalReleased = 5 + 1 = 6; payment2 = floor(6/3) - 1 = 1.\n  - payment2 != 0, so the call does not revert, violating the property.","65.42973971366882","20000","ANSWER: FALSE\nEXPLANATION: The function releasable uses totalReceived = address(this).balance + totalReleased. In release, totalReleased and released[account] are incremented before attempting the external payment, and the low-level call account.call{value: payment}("""""""") has its return value ignored. If the external transfer fails, the state remains updated while the balance is unchanged, increasing totalReceived and potentially making releasable(account) > 0 again due to integer division rounding. Thus, a second consecutive release can succeed (not revert) without any ETH being sent to the contract between calls.\nCOUNTEREXAMPLE:\n- Setup: Deploy with two payees: A with 1 share and B with 2 shares (totalShares = 3). Let A be a contract that rejects ETH (no payable receive/fallback).\n- Fund the splitter with 5 wei.\n- Call 1: release(A).\n  - totalReceived = 5 + 0 = 5; payment1 = floor(5/3) - 0 = 1.\n  - State updated: totalReleased = 1, released[A] = 1.\n  - account.call sends 1 wei to A but fails; function does not revert.\n- No ETH is sent to the splitter between calls.\n- Call 2: release(A).\n  - totalReceived = balance + totalReleased = 5 + 1 = 6; payment2 = floor(6/3) - 1 = 1.\n  - payment2 != 0, so the call does not revert, violating the property."
"5","release-release-revert","True","FALSE","The second call to release(a) only reverts if releasable(a) == 0 (require(payment != 0) in release). Because receive() is payable, the payee can send ETH back to the contract during the first release call. releasable() uses address(this).balance + totalReleased, so any ETH returned to the contract during the first call increases the balance and makes the second call’s payment > 0 even without any ETH transfer occurring between the two calls. This is especially clear with a single-payee setup where shares[account] == totalShares, making pendingPayment = totalReceived - alreadyReleased.","- Setup: Deploy with a single payee A and shares [100]. Send 10 ETH to the contract.\n- A is a contract whose fallback/receive, upon receiving ETH, immediately sends 1 ETH back to the PaymentSplitter (simple call with value).\n- Call 1: release(A). Payment = 10 ETH. State is updated (totalReleased = 10, released[A] = 10), then 10 ETH is sent to A; A’s fallback sends 1 ETH back to PaymentSplitter. The call succeeds. After the call: contract balance = 1 ETH.\n- No ETH transfers occur to the splitter between calls.\n- Call 2: release(A) again. Now releasable(A) = address(this).balance + totalReleased - released[A] = 1 + 10 - 10 = 1 ETH, so require(payment != 0) passes and the call does NOT revert.","134.943345785141","20000","ANSWER: FALSE\nEXPLANATION: The second call to release(a) only reverts if releasable(a) == 0 (require(payment != 0) in release). Because receive() is payable, the payee can send ETH back to the contract during the first release call. releasable() uses address(this).balance + totalReleased, so any ETH returned to the contract during the first call increases the balance and makes the second call’s payment > 0 even without any ETH transfer occurring between the two calls. This is especially clear with a single-payee setup where shares[account] == totalShares, making pendingPayment = totalReceived - alreadyReleased.\nCOUNTEREXAMPLE:\n- Setup: Deploy with a single payee A and shares [100]. Send 10 ETH to the contract.\n- A is a contract whose fallback/receive, upon receiving ETH, immediately sends 1 ETH back to the PaymentSplitter (simple call with value).\n- Call 1: release(A). Payment = 10 ETH. State is updated (totalReleased = 10, released[A] = 10), then 10 ETH is sent to A; A’s fallback sends 1 ETH back to PaymentSplitter. The call succeeds. After the call: contract balance = 1 ETH.\n- No ETH transfers occur to the splitter between calls.\n- Call 2: release(A) again. Now releasable(A) = address(this).balance + totalReleased - released[A] = 1 + 10 - 10 = 1 ETH, so require(payment != 0) passes and the call does NOT revert."
"6","release-release-revert","True","FALSE","release updates accounting before sending ETH and then requires the external call to succeed. If the receiver reverts, the entire release reverts and no state changes persist. Therefore, a second call can still succeed (payment remains due) if nothing changed in the splitter’s balance (releasable still > 0). See release() where payment is computed, state updated, and require(success) enforces revert on failed transfer.","- Deploy PaymentSplitter with one payee A having nonzero shares, and fund the splitter (e.g., send 1 ETH).\n- Let A be a contract with receive() that reverts unless a flag accept is true:\n  receive() external payable { require(accept); }\n  function setAccept(bool v) external { accept = v; }\n- Call release(payable(A)): this computes a nonzero payment but A’s receive() reverts, so require(success) reverts and no state is updated.\n- Without sending any ETH to the PaymentSplitter, call A.setAccept(true).\n- Call release(payable(A)) again: payment is still due (state unchanged), the transfer now succeeds, so the second call does NOT revert.\nThis violates the property since the second consecutive release call for A did not revert despite no ETH being transferred into the splitter between the calls.","89.30163192749023","20000","ANSWER: FALSE\nEXPLANATION: release updates accounting before sending ETH and then requires the external call to succeed. If the receiver reverts, the entire release reverts and no state changes persist. Therefore, a second call can still succeed (payment remains due) if nothing changed in the splitter’s balance (releasable still > 0). See release() where payment is computed, state updated, and require(success) enforces revert on failed transfer.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with one payee A having nonzero shares, and fund the splitter (e.g., send 1 ETH).\n- Let A be a contract with receive() that reverts unless a flag accept is true:\n  receive() external payable { require(accept); }\n  function setAccept(bool v) external { accept = v; }\n- Call release(payable(A)): this computes a nonzero payment but A’s receive() reverts, so require(success) reverts and no state is updated.\n- Without sending any ETH to the PaymentSplitter, call A.setAccept(true).\n- Call release(payable(A)) again: payment is still due (state unchanged), the transfer now succeeds, so the second call does NOT revert.\nThis violates the property since the second consecutive release call for A did not revert despite no ETH being transferred into the splitter between the calls."
"7","release-release-revert","True","TRUE","The second call must revert because release requires releasable(account) > 0. releasable uses totalReceived = address(this).balance + totalReleased (releasable and pendingPayment). A successful first release increases totalReleased and decreases balance by the same amount, keeping totalReceived constant, while increasing released[account] so that pendingPayment becomes zero. Without any ETH transferred into the contract between calls, releasable(account) remains zero, causing the second call to revert at require(releasable(account) > 0) in release.","N/A","54.0150728225708","20000","ANSWER: TRUE\nEXPLANATION: The second call must revert because release requires releasable(account) > 0. releasable uses totalReceived = address(this).balance + totalReleased (releasable and pendingPayment). A successful first release increases totalReleased and decreases balance by the same amount, keeping totalReceived constant, while increasing released[account] so that pendingPayment becomes zero. Without any ETH transferred into the contract between calls, releasable(account) remains zero, causing the second call to revert at require(releasable(account) > 0) in release.\nCOUNTEREXAMPLE: N/A"
"8","release-release-revert","True","FALSE","In release, when payment == 0 (which happens on a second consecutive call without new funds), the function does not revert; it sends 1 wei to owner and requires success. This will not revert if the contract balance is at least 1 wei (see the else branch in release).","- Deploy with payees [owner O, user U] and shares [1, 1].\n- Send 2 wei (or 2 ETH) to the contract.\n- Call release(U): U gets 1 wei, contract retains 1 wei.\n- Call release(U) again (no ETH sent to the contract in between): payment == 0, so the function sends 1 wei to owner O and succeeds. No revert occurs.","19.396374464035034","20000","ANSWER: FALSE\nEXPLANATION: In release, when payment == 0 (which happens on a second consecutive call without new funds), the function does not revert; it sends 1 wei to owner and requires success. This will not revert if the contract balance is at least 1 wei (see the else branch in release).\nCOUNTEREXAMPLE: \n- Deploy with payees [owner O, user U] and shares [1, 1].\n- Send 2 wei (or 2 ETH) to the contract.\n- Call release(U): U gets 1 wei, contract retains 1 wei.\n- Call release(U) again (no ETH sent to the contract in between): payment == 0, so the function sends 1 wei to owner O and succeeds. No revert occurs."
"9","release-release-revert","True","FALSE","In release(), when payment == 0, the function does not revert; instead it sends 1 wei to the owner and requires success ((bool success, ) = owner.call{value: 1}(""""""""); require(success);). Therefore, a second consecutive call for the same address need not revert if the contract still has at least 1 wei balance (e.g., due to other payees’ unclaimed funds).","- Deploy with payees [O, B] and shares [1, 1], where O is the deployer/owner (constructor requires payees_[0] == msg.sender).\n- Send 2 wei to the contract.\n- Call release(B): payment = (2 * 1 / 2) - 0 = 1; B receives 1 wei; contract balance becomes 1 wei; totalReleased becomes 1.\n- Call release(B) again (no ETH sent to the contract in between): payment = ( (balance 1 + totalReleased 1) * 1 / 2 ) - 1 = (2 * 1 / 2) - 1 = 0. The else branch executes and sends 1 wei to owner O, which succeeds given the 1 wei balance. No revert occurs.\n\nThis violates the stated property.","37.590412855148315","20000","ANSWER: FALSE\nEXPLANATION: In release(), when payment == 0, the function does not revert; instead it sends 1 wei to the owner and requires success ((bool success, ) = owner.call{value: 1}(""""""""); require(success);). Therefore, a second consecutive call for the same address need not revert if the contract still has at least 1 wei balance (e.g., due to other payees’ unclaimed funds).\nCOUNTEREXAMPLE: \n- Deploy with payees [O, B] and shares [1, 1], where O is the deployer/owner (constructor requires payees_[0] == msg.sender).\n- Send 2 wei to the contract.\n- Call release(B): payment = (2 * 1 / 2) - 0 = 1; B receives 1 wei; contract balance becomes 1 wei; totalReleased becomes 1.\n- Call release(B) again (no ETH sent to the contract in between): payment = ( (balance 1 + totalReleased 1) * 1 / 2 ) - 1 = (2 * 1 / 2) - 1 = 0. The else branch executes and sends 1 wei to owner O, which succeeds given the 1 wei balance. No revert occurs.\n\nThis violates the stated property."
"10","release-release-revert","True","TRUE","In release(account), the amount due is computed as payment = releasable(account), where releasable uses totalReceived = address(this).balance + totalReleased and returns floor(totalReceived * shares[account] / totalShares) - released[account]. After a successful release, totalReleased and released[account] are increased by payment, while the contract’s balance decreases by the same amount, keeping totalReceived constant. Without any new ETH transferred to the contract between the two calls, the second call computes payment = 0 and reverts due to require(payment != 0, """"""""PaymentSplitter: account is not due payment"""""""").","N/A","63.73976802825928","20000","ANSWER: TRUE\nEXPLANATION: In release(account), the amount due is computed as payment = releasable(account), where releasable uses totalReceived = address(this).balance + totalReleased and returns floor(totalReceived * shares[account] / totalShares) - released[account]. After a successful release, totalReleased and released[account] are increased by payment, while the contract’s balance decreases by the same amount, keeping totalReceived constant. Without any new ETH transferred to the contract between the two calls, the second call computes payment = 0 and reverts due to require(payment != 0, """"""""PaymentSplitter: account is not due payment"""""""").\nCOUNTEREXAMPLE: N/A"
"5","swappable-call-order","True","TRUE","The function pendingPayment divides shares[account] by totalShares first (see comment and code in pendingPayment), which for any setup with at least two payees and positive shares makes shares[account] / totalShares equal to 0. Therefore releasable(account) always returns 0 for any payee, and release(account) reverts at require(payment != 0) without changing state. Hence calling release(a) and release(b) in any order produces no state changes, yielding the same contract state.","N/A","42.2868230342865","20000","ANSWER: TRUE\nEXPLANATION: The function pendingPayment divides shares[account] by totalShares first (see comment and code in pendingPayment), which for any setup with at least two payees and positive shares makes shares[account] / totalShares equal to 0. Therefore releasable(account) always returns 0 for any payee, and release(account) reverts at require(payment != 0) without changing state. Hence calling release(a) and release(b) in any order produces no state changes, yielding the same contract state.\nCOUNTEREXAMPLE: N/A"
"1","swappable-call-order","False","FALSE","The release function performs an external call to the payee (account.call{value: payment}("""""""")) after updating state (release). This allows the payee’s fallback/receive to execute arbitrary code, including sending ETH back to the splitter (receive()) before the other payee’s release. Since releasable() uses totalReceived = address(this).balance + totalReleased, an inbound deposit during the first call changes the second payee’s computed payment. Thus, release(a) and release(b) are not order-independent in general. Relevant code: release (external call) and receive(), and the formula in releasable/pendingPayment.","- Setup:\n  - Two payees A and B with equal shares (1,1).\n  - PaymentSplitter balance initially 100 wei.\n  - A is a contract whose fallback, upon receiving ETH from PaymentSplitter, immediately sends 100 wei to PaymentSplitter (triggering receive()), and does not call release() further.\n  - B is an EOA.\n  - A is pre-funded externally with 100 wei to make the deposit.\n\n- Order 1: release(A) then release(B)\n  1) release(A):\n     - payment to A = (100 + 0) * 1/2 - 0 = 50 wei.\n     - State after effects but before external call: totalReleased=50, balance=50.\n     - A’s fallback sends 100 wei to PaymentSplitter: balance becomes 150.\n  2) release(B):\n     - totalReceived = 150 + 50 = 200; payment to B = 200/2 - 0 = 100 wei.\n     - Final state: released[A]=50, released[B]=100, totalReleased=150, balance=50.\n\n- Order 2: release(B) then release(A)\n  1) release(B):\n     - payment to B = (100 + 0) * 1/2 - 0 = 50 wei.\n     - State: totalReleased=50, balance=50.\n  2) release(A):\n     - payment to A = (50 + 50) * 1/2 - 0 = 50 wei.\n     - After external call, A’s fallback sends 100 wei to PaymentSplitter: balance becomes 100.\n     - Final state: released[A]=50, released[B]=50, totalReleased=100, balance=100.\n\nThe final contract states differ, so the property does not hold.","116.5139000415802","20000","ANSWER: FALSE\nEXPLANATION: The release function performs an external call to the payee (account.call{value: payment}("""""""")) after updating state (release). This allows the payee’s fallback/receive to execute arbitrary code, including sending ETH back to the splitter (receive()) before the other payee’s release. Since releasable() uses totalReceived = address(this).balance + totalReleased, an inbound deposit during the first call changes the second payee’s computed payment. Thus, release(a) and release(b) are not order-independent in general. Relevant code: release (external call) and receive(), and the formula in releasable/pendingPayment.\nCOUNTEREXAMPLE:\n- Setup:\n  - Two payees A and B with equal shares (1,1).\n  - PaymentSplitter balance initially 100 wei.\n  - A is a contract whose fallback, upon receiving ETH from PaymentSplitter, immediately sends 100 wei to PaymentSplitter (triggering receive()), and does not call release() further.\n  - B is an EOA.\n  - A is pre-funded externally with 100 wei to make the deposit.\n\n- Order 1: release(A) then release(B)\n  1) release(A):\n     - payment to A = (100 + 0) * 1/2 - 0 = 50 wei.\n     - State after effects but before external call: totalReleased=50, balance=50.\n     - A’s fallback sends 100 wei to PaymentSplitter: balance becomes 150.\n  2) release(B):\n     - totalReceived = 150 + 50 = 200; payment to B = 200/2 - 0 = 100 wei.\n     - Final state: released[A]=50, released[B]=100, totalReleased=150, balance=50.\n\n- Order 2: release(B) then release(A)\n  1) release(B):\n     - payment to B = (100 + 0) * 1/2 - 0 = 50 wei.\n     - State: totalReleased=50, balance=50.\n  2) release(A):\n     - payment to A = (50 + 50) * 1/2 - 0 = 50 wei.\n     - After external call, A’s fallback sends 100 wei to PaymentSplitter: balance becomes 100.\n     - Final state: released[A]=50, released[B]=50, totalReleased=100, balance=100.\n\nThe final contract states differ, so the property does not hold."
"2","swappable-call-order","False","FALSE","The amount paid by release(account) depends on totalReceived = address(this).balance + totalReleased (releasable and pendingPayment). In release, the contract performs an external call to the payee (account.call{value: payment}("""""""")) after updating totalReleased and released[account]. Because receive() is payable, a payee’s fallback can send ETH back to the splitter during its own release. This changes address(this).balance before the second release, altering the second payee’s payout. Thus, the final contract state (e.g., released[], totalReleased, and balance) can differ based on call order.","- Setup:\n  - Payees: A (a contract), B (an EOA), C (an EOA). Shares: A=1, B=1, C=1 (totalShares=3).\n  - Fund the splitter with 3 wei (so totalReceived initially 3).\n  - A’s fallback, upon receiving ETH from the splitter, immediately sends 3 wei back to the splitter (payable(msg.sender).call{value: 3}("""""""")).\n- Order 1: release(A) then release(B).\n  1) release(A): payment = (balance + totalReleased)*1/3 - released[A] = (3+0)*1/3 - 0 = 1. After paying A, A’s fallback sends back 3 wei. Now balance=5, totalReleased=1, released[A]=1.\n  2) release(B): payment = (5+1)*1/3 - 0 = 2. After paying B, balance=3, totalReleased=3, released[B]=2.\n  Final state: released[A]=1, released[B]=2, totalReleased=3, balance=3.\n- Order 2: release(B) then release(A).\n  1) release(B): payment = (3+0)*1/3 - 0 = 1. Now balance=2, totalReleased=1, released[B]=1.\n  2) release(A): payment = (2+1)*1/3 - 0 = 1. After paying A, A’s fallback sends back 3 wei. Now balance=4, totalReleased=2, released[A]=1.\n  Final state: released[A]=1, released[B]=1, totalReleased=2, balance=4.\n\nThe final contract states differ, so the property is violated.","107.0800392627716","20000","ANSWER: FALSE\nEXPLANATION: The amount paid by release(account) depends on totalReceived = address(this).balance + totalReleased (releasable and pendingPayment). In release, the contract performs an external call to the payee (account.call{value: payment}("""""""")) after updating totalReleased and released[account]. Because receive() is payable, a payee’s fallback can send ETH back to the splitter during its own release. This changes address(this).balance before the second release, altering the second payee’s payout. Thus, the final contract state (e.g., released[], totalReleased, and balance) can differ based on call order.\nCOUNTEREXAMPLE:\n- Setup:\n  - Payees: A (a contract), B (an EOA), C (an EOA). Shares: A=1, B=1, C=1 (totalShares=3).\n  - Fund the splitter with 3 wei (so totalReceived initially 3).\n  - A’s fallback, upon receiving ETH from the splitter, immediately sends 3 wei back to the splitter (payable(msg.sender).call{value: 3}("""""""")).\n- Order 1: release(A) then release(B).\n  1) release(A): payment = (balance + totalReleased)*1/3 - released[A] = (3+0)*1/3 - 0 = 1. After paying A, A’s fallback sends back 3 wei. Now balance=5, totalReleased=1, released[A]=1.\n  2) release(B): payment = (5+1)*1/3 - 0 = 2. After paying B, balance=3, totalReleased=3, released[B]=2.\n  Final state: released[A]=1, released[B]=2, totalReleased=3, balance=3.\n- Order 2: release(B) then release(A).\n  1) release(B): payment = (3+0)*1/3 - 0 = 1. Now balance=2, totalReleased=1, released[B]=1.\n  2) release(A): payment = (2+1)*1/3 - 0 = 1. After paying A, A’s fallback sends back 3 wei. Now balance=4, totalReleased=2, released[A]=1.\n  Final state: released[A]=1, released[B]=1, totalReleased=2, balance=4.\n\nThe final contract states differ, so the property is violated."
"3","swappable-call-order","False","FALSE","The amount paid by release(account) depends on totalReceived = address(this).balance + totalReleased (function releasable), and the contract allows receiving ETH at any time via receive(). Because release makes an external call to the payee (account.call{value: payment}("""""""")), the payee can send ETH back to the contract between two releases, changing address(this).balance and thus totalReceived for the second call. Therefore, the final state after calling release(a) and release(b) can differ by order.","- Setup: Deploy with payees a, b, c. Fund the contract with 4 wei (balance=4, totalReleased=0). Let a be a contract whose fallback, upon receiving ETH, immediately sends 2 wei to the PaymentSplitter.\n- Order 1 (a then b):\n  1) release(a): payment = floor((4 + 0)/3) = 1. After updating state and paying a, a’s fallback sends 2 wei back. Now balance=5, totalReleased=1, so totalReceived=6.\n  2) release(b): payment = floor(6/3) - 0 = 2. Final: released[a]=1, released[b]=2, totalReleased=3, balance=3.\n- Order 2 (b then a):\n  1) release(b): payment = floor((4 + 0)/3) = 1. Now balance=3, totalReleased=1.\n  2) release(a): payment = floor((3 + 1)/3) = 1. After paying a, a’s fallback sends 2 wei back. Final: released[a]=1, released[b]=1, totalReleased=2, balance=4.\nFinal states differ, so the property does not hold.","110.30407547950745","20000","ANSWER: FALSE\nEXPLANATION: The amount paid by release(account) depends on totalReceived = address(this).balance + totalReleased (function releasable), and the contract allows receiving ETH at any time via receive(). Because release makes an external call to the payee (account.call{value: payment}("""""""")), the payee can send ETH back to the contract between two releases, changing address(this).balance and thus totalReceived for the second call. Therefore, the final state after calling release(a) and release(b) can differ by order.\nCOUNTEREXAMPLE: \n- Setup: Deploy with payees a, b, c. Fund the contract with 4 wei (balance=4, totalReleased=0). Let a be a contract whose fallback, upon receiving ETH, immediately sends 2 wei to the PaymentSplitter.\n- Order 1 (a then b):\n  1) release(a): payment = floor((4 + 0)/3) = 1. After updating state and paying a, a’s fallback sends 2 wei back. Now balance=5, totalReleased=1, so totalReceived=6.\n  2) release(b): payment = floor(6/3) - 0 = 2. Final: released[a]=1, released[b]=2, totalReleased=3, balance=3.\n- Order 2 (b then a):\n  1) release(b): payment = floor((4 + 0)/3) = 1. Now balance=3, totalReleased=1.\n  2) release(a): payment = floor((3 + 1)/3) = 1. After paying a, a’s fallback sends 2 wei back. Final: released[a]=1, released[b]=1, totalReleased=2, balance=4.\nFinal states differ, so the property does not hold."
"4","swappable-call-order","False","FALSE","release updates totalReleased and released[account] before attempting the external payment (account.call{value: payment}("""""""")), and it ignores the call result. releasable uses address(this).balance + totalReleased. If one payee’s transfer fails, balance stays the same while totalReleased increases, changing totalReceived for the next call and thus the computed payment. Therefore, the final state depends on the order of release calls. See release (state update before call) and releasable/pendingPayment (use of balance + totalReleased).","- Setup: Deploy with payees [a, b], shares [1, 1], and fund the contract with 100 wei. Let a be a contract that rejects ETH (non-payable, so account.call returns false). Let b be an EOA (accepts ETH).\n- Initial: totalShares = 2, totalReleased = 0, released[a] = 0, released[b] = 0, balance = 100.\n- Order 1: release(a) then release(b)\n  - release(a): payment = (100 * 1 / 2) - 0 = 50. totalReleased = 50; released[a] = 50; external call fails; balance stays 100.\n  - release(b): payment = ((100 + 50) * 1 / 2) - 0 = 75. totalReleased = 125; released[b] = 75; external call succeeds; balance = 25.\n  - Final state: released[a]=50, released[b]=75, totalReleased=125, balance=25.\n- Order 2: release(b) then release(a)\n  - release(b): payment = (100 * 1 / 2) - 0 = 50. totalReleased = 50; released[b] = 50; call succeeds; balance = 50.\n  - release(a): payment = (100 * 1 / 2) - 0 = 50. totalReleased = 100; released[a] = 50; call fails; balance = 50.\n  - Final state: released[a]=50, released[b]=50, totalReleased=100, balance=50.\n\nFinal states differ, so the property is false.","94.92237854003906","20000","ANSWER: FALSE\nEXPLANATION: release updates totalReleased and released[account] before attempting the external payment (account.call{value: payment}("""""""")), and it ignores the call result. releasable uses address(this).balance + totalReleased. If one payee’s transfer fails, balance stays the same while totalReleased increases, changing totalReceived for the next call and thus the computed payment. Therefore, the final state depends on the order of release calls. See release (state update before call) and releasable/pendingPayment (use of balance + totalReleased).\nCOUNTEREXAMPLE: \n- Setup: Deploy with payees [a, b], shares [1, 1], and fund the contract with 100 wei. Let a be a contract that rejects ETH (non-payable, so account.call returns false). Let b be an EOA (accepts ETH).\n- Initial: totalShares = 2, totalReleased = 0, released[a] = 0, released[b] = 0, balance = 100.\n- Order 1: release(a) then release(b)\n  - release(a): payment = (100 * 1 / 2) - 0 = 50. totalReleased = 50; released[a] = 50; external call fails; balance stays 100.\n  - release(b): payment = ((100 + 50) * 1 / 2) - 0 = 75. totalReleased = 125; released[b] = 75; external call succeeds; balance = 25.\n  - Final state: released[a]=50, released[b]=75, totalReleased=125, balance=25.\n- Order 2: release(b) then release(a)\n  - release(b): payment = (100 * 1 / 2) - 0 = 50. totalReleased = 50; released[b] = 50; call succeeds; balance = 50.\n  - release(a): payment = (100 * 1 / 2) - 0 = 50. totalReleased = 100; released[a] = 50; call fails; balance = 50.\n  - Final state: released[a]=50, released[b]=50, totalReleased=100, balance=50.\n\nFinal states differ, so the property is false."
"6","swappable-call-order","False","FALSE","The amount released to a payee depends on totalReceived = address(this).balance + totalReleased (releasable/pendingPayment). The contract accepts ETH at any time (receive() external payable) and release() makes an external call to the payee (account.call) without a reentrancy guard, after updating totals. Thus, a payee can send ETH back to the splitter during its own release, changing address(this).balance (and hence totalReceived) before the other payee’s release, making the final state order-dependent.","Setup:\n- Two payees a and b with shares[a]=1, shares[b]=1 (totalShares=2). Initial contract balance = 2 wei. Initially, released[a]=released[b]=totalReleased=0.\n- a is a contract whose fallback/receive, upon receiving ETH, immediately sends 2 wei to the PaymentSplitter (payable(splitter).call{value:2}("""""""")).\n\nOrder 1: release(a) then release(b)\n1) release(a): payment = (2*1)/2 - 0 = 1. totalReleased=1; released[a]=1. During the external call, a sends 2 wei to the splitter. Contract balance becomes 2 - 1 + 2 = 3.\n2) release(b): totalReceived = balance + totalReleased = 3 + 1 = 4. payment = (4*1)/2 - 0 = 2. totalReleased=3; released[b]=2; balance becomes 3 - 2 = 1.\n\nFinal state after order 1: released[a]=1, released[b]=2, totalReleased=3, balance=1.\n\nOrder 2: release(b) then release(a)\n1) release(b): payment = (2*1)/2 - 0 = 1. totalReleased=1; released[b]=1; balance becomes 1.\n2) release(a): totalReceived = 1 + 1 = 2. payment = (2*1)/2 - 0 = 1. totalReleased=2; released[a]=1; balance becomes 0; during the external call, a sends 2 wei to the splitter; balance becomes 2.\n\nFinal state after order 2: released[a]=1, released[b]=1, totalReleased=2, balance=2.\n\nThe two final states differ; hence the property is false.","112.57552409172058","20000","ANSWER: FALSE\nEXPLANATION: The amount released to a payee depends on totalReceived = address(this).balance + totalReleased (releasable/pendingPayment). The contract accepts ETH at any time (receive() external payable) and release() makes an external call to the payee (account.call) without a reentrancy guard, after updating totals. Thus, a payee can send ETH back to the splitter during its own release, changing address(this).balance (and hence totalReceived) before the other payee’s release, making the final state order-dependent.\nCOUNTEREXAMPLE: Setup:\n- Two payees a and b with shares[a]=1, shares[b]=1 (totalShares=2). Initial contract balance = 2 wei. Initially, released[a]=released[b]=totalReleased=0.\n- a is a contract whose fallback/receive, upon receiving ETH, immediately sends 2 wei to the PaymentSplitter (payable(splitter).call{value:2}("""""""")).\n\nOrder 1: release(a) then release(b)\n1) release(a): payment = (2*1)/2 - 0 = 1. totalReleased=1; released[a]=1. During the external call, a sends 2 wei to the splitter. Contract balance becomes 2 - 1 + 2 = 3.\n2) release(b): totalReceived = balance + totalReleased = 3 + 1 = 4. payment = (4*1)/2 - 0 = 2. totalReleased=3; released[b]=2; balance becomes 3 - 2 = 1.\n\nFinal state after order 1: released[a]=1, released[b]=2, totalReleased=3, balance=1.\n\nOrder 2: release(b) then release(a)\n1) release(b): payment = (2*1)/2 - 0 = 1. totalReleased=1; released[b]=1; balance becomes 1.\n2) release(a): totalReceived = 1 + 1 = 2. payment = (2*1)/2 - 0 = 1. totalReleased=2; released[a]=1; balance becomes 0; during the external call, a sends 2 wei to the splitter; balance becomes 2.\n\nFinal state after order 2: released[a]=1, released[b]=1, totalReleased=2, balance=2.\n\nThe two final states differ; hence the property is false."
"7","swappable-call-order","False","FALSE","The amount a payee can release is computed from totalReceived = address(this).balance + totalReleased (releasable/pendingPayment). During release, the contract updates state then performs an external call to the payee (release). The payee’s fallback can send ETH back to the splitter (receive), changing address(this).balance mid-sequence. This makes totalReceived seen by the second release depend on which payee was paid first, causing different final states.","- Setup:\n  - Deploy PaymentSplitter with payees [A, B], shares [1, 1], and send 100 wei in the constructor.\n  - A is a contract whose fallback/receive sends 2 wei back to the PaymentSplitter upon receiving ETH.\n  - B is a contract that accepts ETH without sending anything back.\n- Order 1 (A then B):\n  1) A calls release(A):\n     - payment_A = floor((100)*1/2) = 50; totalReleased = 50; released[A] = 50.\n     - 50 wei sent to A; A immediately sends 2 wei back. Contract balance becomes 52.\n  2) B calls release(B):\n     - totalReceived = balance + totalReleased = 52 + 50 = 102.\n     - payment_B = floor(102*1/2) = 51; totalReleased = 101; released[B] = 51.\n     - Final state: released[A]=50, released[B]=51, totalReleased=101, balance=1.\n- Order 2 (B then A):\n  1) B calls release(B):\n     - payment_B = floor((100)*1/2) = 50; totalReleased = 50; released[B] = 50; balance = 50.\n  2) A calls release(A):\n     - totalReceived = 50 + 50 = 100.\n     - payment_A = 50; totalReleased = 100; released[A] = 50.\n     - A sends back 2 wei; balance becomes 2.\n     - Final state: released[A]=50, released[B]=50, totalReleased=100, balance=2.\n\nFinal states differ, so the property is false.","158.2479703426361","20000","ANSWER: FALSE\nEXPLANATION: The amount a payee can release is computed from totalReceived = address(this).balance + totalReleased (releasable/pendingPayment). During release, the contract updates state then performs an external call to the payee (release). The payee’s fallback can send ETH back to the splitter (receive), changing address(this).balance mid-sequence. This makes totalReceived seen by the second release depend on which payee was paid first, causing different final states.\nCOUNTEREXAMPLE: \n- Setup:\n  - Deploy PaymentSplitter with payees [A, B], shares [1, 1], and send 100 wei in the constructor.\n  - A is a contract whose fallback/receive sends 2 wei back to the PaymentSplitter upon receiving ETH.\n  - B is a contract that accepts ETH without sending anything back.\n- Order 1 (A then B):\n  1) A calls release(A):\n     - payment_A = floor((100)*1/2) = 50; totalReleased = 50; released[A] = 50.\n     - 50 wei sent to A; A immediately sends 2 wei back. Contract balance becomes 52.\n  2) B calls release(B):\n     - totalReceived = balance + totalReleased = 52 + 50 = 102.\n     - payment_B = floor(102*1/2) = 51; totalReleased = 101; released[B] = 51.\n     - Final state: released[A]=50, released[B]=51, totalReleased=101, balance=1.\n- Order 2 (B then A):\n  1) B calls release(B):\n     - payment_B = floor((100)*1/2) = 50; totalReleased = 50; released[B] = 50; balance = 50.\n  2) A calls release(A):\n     - totalReceived = 50 + 50 = 100.\n     - payment_A = 50; totalReleased = 100; released[A] = 50.\n     - A sends back 2 wei; balance becomes 2.\n     - Final state: released[A]=50, released[B]=50, totalReleased=100, balance=2.\n\nFinal states differ, so the property is false."
"8","swappable-call-order","False","FALSE","The release function sends 1 wei to owner when releasable(account) == 0 (else branch in release). This decreases address(this).balance without increasing totalReleased, so the totalReceived = balance + totalReleased used by releasable() changes based on call order, making payouts (and thus state) order-dependent.","- Setup: Deploy with payees [A, B], shares [1, 3], from A (so A is owner), and fund the contract with 3 wei (totalShares=4, totalReleased=0, released[A]=released[B]=0, balance=3).\n- Order 1: release(A) then release(B)\n  - release(A): releasable(A)=floor((3*1)/4)=0 ⇒ else branch sends 1 wei to owner A; balance=2; totalReleased=0.\n  - release(B): totalReceived=2+0=2 ⇒ releasable(B)=floor((2*3)/4)=1; pay 1 wei to B; released[B]=1; totalReleased=1; balance=1.\n  - Final state: totalReleased=1, released[A]=0, released[B]=1, balance=1.\n- Order 2: release(B) then release(A)\n  - release(B): totalReceived=3 ⇒ releasable(B)=floor((3*3)/4)=2; pay 2 wei; released[B]=2; totalReleased=2; balance=1.\n  - release(A): releasable(A)=floor((3*1)/4)=0 ⇒ else branch sends 1 wei to owner A; balance=0; totalReleased=2.\n  - Final state: totalReleased=2, released[A]=0, released[B]=2, balance=0.\n\nStates differ between the two orders, so the property is false.","89.41657662391663","20000","ANSWER: FALSE\nEXPLANATION: The release function sends 1 wei to owner when releasable(account) == 0 (else branch in release). This decreases address(this).balance without increasing totalReleased, so the totalReceived = balance + totalReleased used by releasable() changes based on call order, making payouts (and thus state) order-dependent.\nCOUNTEREXAMPLE: \n- Setup: Deploy with payees [A, B], shares [1, 3], from A (so A is owner), and fund the contract with 3 wei (totalShares=4, totalReleased=0, released[A]=released[B]=0, balance=3).\n- Order 1: release(A) then release(B)\n  - release(A): releasable(A)=floor((3*1)/4)=0 ⇒ else branch sends 1 wei to owner A; balance=2; totalReleased=0.\n  - release(B): totalReceived=2+0=2 ⇒ releasable(B)=floor((2*3)/4)=1; pay 1 wei to B; released[B]=1; totalReleased=1; balance=1.\n  - Final state: totalReleased=1, released[A]=0, released[B]=1, balance=1.\n- Order 2: release(B) then release(A)\n  - release(B): totalReceived=3 ⇒ releasable(B)=floor((3*3)/4)=2; pay 2 wei; released[B]=2; totalReleased=2; balance=1.\n  - release(A): releasable(A)=floor((3*1)/4)=0 ⇒ else branch sends 1 wei to owner A; balance=0; totalReleased=2.\n  - Final state: totalReleased=2, released[A]=0, released[B]=2, balance=0.\n\nStates differ between the two orders, so the property is false."
"9","swappable-call-order","False","FALSE","In release(), if the computed payment is 0, the function still sends 1 wei to the owner (else branch), altering the contract balance without increasing totalReleased (see release: else { owner.call{value: 1}(""""""""); }). Since releasable() uses totalReceived = address(this).balance + totalReleased, this 1 wei side-effect changes future payouts and makes release calls order-dependent.","- Deploy with payees [A (owner), B] and shares [1, 2]; send 2 wei to the contract in the constructor.\n- Order 1: release(A), then release(B)\n  - release(A): payment = floor((2+0)*1/3) = 0 → sends 1 wei to owner. Balance=1, totalReleased=0.\n  - release(B): payment = floor((1+0)*2/3) = 0 → sends 1 wei to owner. Balance=0, totalReleased=0, released[B]=0.\n- Order 2: release(B), then release(A)\n  - release(B): payment = floor((2+0)*2/3) = 1 → pays 1 wei to B. Balance=1, totalReleased=1, released[B]=1.\n  - release(A): payment = floor((1+1)*1/3) = 0 → sends 1 wei to owner. Balance=0, totalReleased=1, released[B]=1.\nFinal states differ (e.g., totalReleased 0 vs 1; released[B] 0 vs 1), so the property does not hold.","60.26505899429321","20000","ANSWER: FALSE\nEXPLANATION: In release(), if the computed payment is 0, the function still sends 1 wei to the owner (else branch), altering the contract balance without increasing totalReleased (see release: else { owner.call{value: 1}(""""""""); }). Since releasable() uses totalReceived = address(this).balance + totalReleased, this 1 wei side-effect changes future payouts and makes release calls order-dependent.\nCOUNTEREXAMPLE: \n- Deploy with payees [A (owner), B] and shares [1, 2]; send 2 wei to the contract in the constructor.\n- Order 1: release(A), then release(B)\n  - release(A): payment = floor((2+0)*1/3) = 0 → sends 1 wei to owner. Balance=1, totalReleased=0.\n  - release(B): payment = floor((1+0)*2/3) = 0 → sends 1 wei to owner. Balance=0, totalReleased=0, released[B]=0.\n- Order 2: release(B), then release(A)\n  - release(B): payment = floor((2+0)*2/3) = 1 → pays 1 wei to B. Balance=1, totalReleased=1, released[B]=1.\n  - release(A): payment = floor((1+1)*1/3) = 0 → sends 1 wei to owner. Balance=0, totalReleased=1, released[B]=1.\nFinal states differ (e.g., totalReleased 0 vs 1; released[B] 0 vs 1), so the property does not hold."
"10","swappable-call-order","False","FALSE","release updates state then performs an external call to the payee (account.call{value: payment}("""""""")) and lacks a reentrancy guard. A reentrant payee can call release on the other payee during its fallback. Because release requires payment != 0 and reverts on a failed external call (require(success)), the outcome depends on order: in one order the reentrant call succeeds; in the opposite order it reverts and rolls back the outer release. See release() and the external call with require(success).","- Setup:\n  - Deploy PaymentSplitter with payees [a, b], shares [1, 1].\n  - Send 2 wei to the splitter (stateCheck passes).\n  - Let a be a contract whose receive/fallback calls splitter.release(payable(b)) and does not catch reverts. Let b be an EOA.\n\n- Order 1: release(a) then release(b)\n  1) release(a): payment to a = 1. State is updated, then call to a transfers 1 wei; in a’s fallback, it calls release(b):\n     - release(b): payment to b = 1, succeeds, sends 1 wei to b.\n     - release(a) completes successfully.\n     State after tx1: totalReleased=2; released[a]=1; released[b]=1; balance=0.\n  2) release(b): payment = 0 -> reverts. Final state unchanged.\n  Final state: both a and b paid (released[a]=1, released[b]=1), balance=0.\n\n- Order 2: release(b) then release(a)\n  1) release(b): payment to b = 1, succeeds. State: totalReleased=1; released[b]=1; balance=1.\n  2) release(a): payment to a = 1; during the external call to a, its fallback calls release(b):\n     - release(b): payment = 0 -> reverts; this causes the call to a to fail; require(success) reverts; entire release(a) reverts.\n  Final state: only b paid (released[a]=0, released[b]=1), balance=1.\n\nThus, the final contract state differs depending on call order.","169.740891456604","20000","ANSWER: FALSE\nEXPLANATION: release updates state then performs an external call to the payee (account.call{value: payment}("""""""")) and lacks a reentrancy guard. A reentrant payee can call release on the other payee during its fallback. Because release requires payment != 0 and reverts on a failed external call (require(success)), the outcome depends on order: in one order the reentrant call succeeds; in the opposite order it reverts and rolls back the outer release. See release() and the external call with require(success).\nCOUNTEREXAMPLE:\n- Setup:\n  - Deploy PaymentSplitter with payees [a, b], shares [1, 1].\n  - Send 2 wei to the splitter (stateCheck passes).\n  - Let a be a contract whose receive/fallback calls splitter.release(payable(b)) and does not catch reverts. Let b be an EOA.\n\n- Order 1: release(a) then release(b)\n  1) release(a): payment to a = 1. State is updated, then call to a transfers 1 wei; in a’s fallback, it calls release(b):\n     - release(b): payment to b = 1, succeeds, sends 1 wei to b.\n     - release(a) completes successfully.\n     State after tx1: totalReleased=2; released[a]=1; released[b]=1; balance=0.\n  2) release(b): payment = 0 -> reverts. Final state unchanged.\n  Final state: both a and b paid (released[a]=1, released[b]=1), balance=0.\n\n- Order 2: release(b) then release(a)\n  1) release(b): payment to b = 1, succeeds. State: totalReleased=1; released[b]=1; balance=1.\n  2) release(a): payment to a = 1; during the external call to a, its fallback calls release(b):\n     - release(b): payment = 0 -> reverts; this causes the call to a to fail; require(success) reverts; entire release(a) reverts.\n  Final state: only b paid (released[a]=0, released[b]=1), balance=1.\n\nThus, the final contract state differs depending on call order."
"1","tx-transfer-releasable-receive","True","TRUE","Any user can call release(account) (public). If releasable(a) > 0, then payment = releasable(a) is nonzero and, given the formula pendingPayment(totalReceived, released[a]) and that shares[a] > 0 for any address with releasable > 0, both requires pass. The function then executes account.call{value: payment}("""""""") and requires success, which will succeed if a’s receive accepts ETH. See release (requires, call, require(success)) and releasable/pendingPayment calculations.","N/A","41.870317697525024","20000","ANSWER: TRUE\nEXPLANATION: Any user can call release(account) (public). If releasable(a) > 0, then payment = releasable(a) is nonzero and, given the formula pendingPayment(totalReceived, released[a]) and that shares[a] > 0 for any address with releasable > 0, both requires pass. The function then executes account.call{value: payment}("""""""") and requires success, which will succeed if a’s receive accepts ETH. See release (requires, call, require(success)) and releasable/pendingPayment calculations.\nCOUNTEREXAMPLE: N/A"
"2","tx-transfer-releasable-receive","True","TRUE","The public function release(address payable account) transfers the releasable amount to account after checking (i) account has shares and is a payee (isPayee(account)), and (ii) payment != 0. If releasable(a) > 0, then shares[a] > 0 (non-payees have shares[a] = 0 so releasable would be 0), so isPayee(a) holds since addPayee registers all payees in the payees array. The transfer is executed via account.call{value: payment}(""""""""), and require(success) ensures it succeeds if a’s receive accepts ETH.","N/A","26.16922664642334","20000","ANSWER: TRUE\nEXPLANATION: The public function release(address payable account) transfers the releasable amount to account after checking (i) account has shares and is a payee (isPayee(account)), and (ii) payment != 0. If releasable(a) > 0, then shares[a] > 0 (non-payees have shares[a] = 0 so releasable would be 0), so isPayee(a) holds since addPayee registers all payees in the payees array. The transfer is executed via account.call{value: payment}(""""""""), and require(success) ensures it succeeds if a’s receive accepts ETH.\nCOUNTEREXAMPLE: N/A"
"3","tx-transfer-releasable-receive","True","FALSE","The release function requires the target address to be a payee with shares (require(shares[account] > 0) and require(isPayee(account))) before sending ETH. However, releasable(account) is computed without checking shares, as (address(this).balance + totalReleased) / PAYEES - released[account], which can be > 0 for non-payees. Thus, even if releasable(a) > 0 and a accepts ETH, no transfer can occur unless a is one of the three payees.","- Deploy PaymentSplitter with payees P1, P2, P3 (distinct nonzero addresses).\n- Let A be an address not among {P1, P2, P3}, with a receive() payable {} that accepts ETH.\n- Send 3 wei to the contract (so address(this).balance = 3, totalReleased = 0).\n- Then releasable(A) = (3 + 0) / 3 - 0 = 1 > 0.\n- Any call to release(A) reverts at require(shares[A] > 0) or require(isPayee(A)), so no ETH can be transferred to A from the contract.","28.79101061820984","20000","ANSWER: FALSE\nEXPLANATION: The release function requires the target address to be a payee with shares (require(shares[account] > 0) and require(isPayee(account))) before sending ETH. However, releasable(account) is computed without checking shares, as (address(this).balance + totalReleased) / PAYEES - released[account], which can be > 0 for non-payees. Thus, even if releasable(a) > 0 and a accepts ETH, no transfer can occur unless a is one of the three payees.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with payees P1, P2, P3 (distinct nonzero addresses).\n- Let A be an address not among {P1, P2, P3}, with a receive() payable {} that accepts ETH.\n- Send 3 wei to the contract (so address(this).balance = 3, totalReleased = 0).\n- Then releasable(A) = (3 + 0) / 3 - 0 = 1 > 0.\n- Any call to release(A) reverts at require(shares[A] > 0) or require(isPayee(A)), so no ETH can be transferred to A from the contract."
"4","tx-transfer-releasable-receive","True","TRUE","The public function release(address payable account) transfers ETH to account if shares[account] > 0 and releasable(account) > 0. It computes payment = releasable(account) and requires payment != 0, then sends ETH via account.call{value: payment}(""""""""). Since a’s receive accepts ETH, the call succeeds. releasable(account) is computed in releasable() using pendingPayment(), so if it’s > 0, the send is enabled.","N/A","16.954535961151123","20000","ANSWER: TRUE\nEXPLANATION: The public function release(address payable account) transfers ETH to account if shares[account] > 0 and releasable(account) > 0. It computes payment = releasable(account) and requires payment != 0, then sends ETH via account.call{value: payment}(""""""""). Since a’s receive accepts ETH, the call succeeds. releasable(account) is computed in releasable() using pendingPayment(), so if it’s > 0, the send is enabled.\nCOUNTEREXAMPLE: N/A"
"5","tx-transfer-releasable-receive","True","TRUE","The function release(address payable account) is public and can be called by anyone. It computes payment = releasable(account) and requires payment != 0 and shares[account] > 0. If releasable(a) > 0, these checks pass. The function then sends ETH via account.call{value: payment}("""""""") and requires success; since a’s receive accepts all ETH, the call succeeds and transfers funds (see release and releasable/pendingPayment).","N/A","70.76304149627686","20000","ANSWER: TRUE\nEXPLANATION: The function release(address payable account) is public and can be called by anyone. It computes payment = releasable(account) and requires payment != 0 and shares[account] > 0. If releasable(a) > 0, these checks pass. The function then sends ETH via account.call{value: payment}("""""""") and requires success; since a’s receive accepts all ETH, the call succeeds and transfers funds (see release and releasable/pendingPayment).\nCOUNTEREXAMPLE: N/A"
"2","tx-transfer-balance-receive","False","FALSE","Because release() only transfers funds when releasable(account) > 0, and releasable() uses integer division in pendingPayment(), small positive balances can yield zero for every payee. Specifically, release() requires payment != 0 and reverts otherwise (release, lines with require(payment != 0)). pendingPayment computes (totalReceived * shares[account]) / totalShares - alreadyReleased (pendingPayment). With 3 payees and equal shares, a balance of 1 or 2 wei makes each releasable() = 0, so no call to release can decrease the balance despite a non-zero contract balance and EOA payees.","- Deploy with three distinct EOAs p1, p2, p3 and shares (1,1,1).\n- Send 1 wei to the contract (receive()).\n- Now totalShares = 3, totalReleased = 0, balance = 1, so for any pi: releasable(pi) = floor((1 + 0) * 1 / 3) - 0 = 0.\n- Any call release(pi) reverts with """"""""PaymentSplitter: account is not due payment"""""""". No other function can transfer ETH out, so no transaction on PaymentSplitter can decrease the contract balance.","70.8591639995575","20000","ANSWER: FALSE\nEXPLANATION: Because release() only transfers funds when releasable(account) > 0, and releasable() uses integer division in pendingPayment(), small positive balances can yield zero for every payee. Specifically, release() requires payment != 0 and reverts otherwise (release, lines with require(payment != 0)). pendingPayment computes (totalReceived * shares[account]) / totalShares - alreadyReleased (pendingPayment). With 3 payees and equal shares, a balance of 1 or 2 wei makes each releasable() = 0, so no call to release can decrease the balance despite a non-zero contract balance and EOA payees.\nCOUNTEREXAMPLE: \n- Deploy with three distinct EOAs p1, p2, p3 and shares (1,1,1).\n- Send 1 wei to the contract (receive()).\n- Now totalShares = 3, totalReleased = 0, balance = 1, so for any pi: releasable(pi) = floor((1 + 0) * 1 / 3) - 0 = 0.\n- Any call release(pi) reverts with """"""""PaymentSplitter: account is not due payment"""""""". No other function can transfer ETH out, so no transaction on PaymentSplitter can decrease the contract balance."
"3","tx-transfer-balance-receive","False","FALSE","The only function that can decrease the contract balance is release, which requires payment != 0 (see release: require(payment != 0, """"""""PaymentSplitter: account is not due payment"""""""")). The payment is computed as releasable(account) = (address(this).balance + totalReleased) / 3 - released[account] (see releasable and pendingPayment). Due to integer division by 3, if totalReceived < 3 or in general if floor(totalReceived/3) == released[account] for all payees, then releasable is zero for every payee and all release calls revert. Thus there are reachable states with a non-zero balance where no transaction can decrease the balance.","- Deploy the contract with three distinct EOA payees A, B, C.\n- Send 1 wei to the contract (balance = 1, totalReleased = 0).\n- For any payee X in {A, B, C}, releasable(X) = (1 + 0) / 3 - 0 = 0.\n- Calling release(X) reverts with """"""""PaymentSplitter: account is not due payment"""""""", so no transaction can decrease the contract balance.","103.46541237831116","20000","ANSWER: FALSE\nEXPLANATION: The only function that can decrease the contract balance is release, which requires payment != 0 (see release: require(payment != 0, """"""""PaymentSplitter: account is not due payment"""""""")). The payment is computed as releasable(account) = (address(this).balance + totalReleased) / 3 - released[account] (see releasable and pendingPayment). Due to integer division by 3, if totalReceived < 3 or in general if floor(totalReceived/3) == released[account] for all payees, then releasable is zero for every payee and all release calls revert. Thus there are reachable states with a non-zero balance where no transaction can decrease the balance.\nCOUNTEREXAMPLE: \n- Deploy the contract with three distinct EOA payees A, B, C.\n- Send 1 wei to the contract (balance = 1, totalReleased = 0).\n- For any payee X in {A, B, C}, releasable(X) = (1 + 0) / 3 - 0 = 0.\n- Calling release(X) reverts with """"""""PaymentSplitter: account is not due payment"""""""", so no transaction can decrease the contract balance."
"4","tx-transfer-balance-receive","False","FALSE","The only function that can decrease the contract’s balance is release, which requires payment != 0 (release -> releasable -> pendingPayment). pendingPayment computes floor((totalReceived * shares[account]) / totalShares) - alreadyReleased. With many payees and small per-share fractions, integer division can make every payee’s releasable zero unless totalReceived is extremely large. Because total ETH is finite, if totalShares is larger than the total possible wei that can ever be received, no payee will ever have payment > 0, so no transaction can decrease the balance.","Deploy with N EOAs as payees, each assigned shares=1, where N is strictly greater than the total number of wei that can ever exist (e.g., N = 10^30). Then totalShares = N and for any totalReceived ≤ total ETH supply in wei, for every payee i: releasable(i) = floor(totalReceived / N) - released[i] = 0. \n- Send any amount of ETH (e.g., 1 wei) to the contract so balance > 0.\n- Calling release(payee) for any payee reverts with """"""""PaymentSplitter: account is not due payment"""""""" because payment == 0, so no balance decrease occurs.\n- Any future sequence of deposits is bounded by total ETH supply, so totalReceived < N forever; releasable remains 0 for all payees, and no transaction can ever decrease the contract balance.","153.5530936717987","20000","ANSWER: FALSE\nEXPLANATION: The only function that can decrease the contract’s balance is release, which requires payment != 0 (release -> releasable -> pendingPayment). pendingPayment computes floor((totalReceived * shares[account]) / totalShares) - alreadyReleased. With many payees and small per-share fractions, integer division can make every payee’s releasable zero unless totalReceived is extremely large. Because total ETH is finite, if totalShares is larger than the total possible wei that can ever be received, no payee will ever have payment > 0, so no transaction can decrease the balance.\nCOUNTEREXAMPLE: Deploy with N EOAs as payees, each assigned shares=1, where N is strictly greater than the total number of wei that can ever exist (e.g., N = 10^30). Then totalShares = N and for any totalReceived ≤ total ETH supply in wei, for every payee i: releasable(i) = floor(totalReceived / N) - released[i] = 0. \n- Send any amount of ETH (e.g., 1 wei) to the contract so balance > 0.\n- Calling release(payee) for any payee reverts with """"""""PaymentSplitter: account is not due payment"""""""" because payment == 0, so no balance decrease occurs.\n- Any future sequence of deposits is bounded by total ETH supply, so totalReceived < N forever; releasable remains 0 for all payees, and no transaction can ever decrease the contract balance.\n"
"5","tx-transfer-balance-receive","False","FALSE","The payment calculation in pendingPayment divides before multiplying: totalReceived * (shares[account] / totalShares) - alreadyReleased (see pendingPayment). With at least two payees, shares[account] < totalShares, so shares[account] / totalShares = 0, making payment = 0. Then release requires payment != 0 and reverts (see release). As release is the only function that sends ETH out, the contract balance cannot be decreased even when non-zero.","- Deploy PaymentSplitter with two EOAs A and B and shares [1, 1].\n- Send 1 ETH to the contract (receive).\n- Call release(payable(A)) or release(payable(B)) from any address. payment computes to 0 due to integer truncation, causing require(payment != 0) to revert.\n- No transaction can reduce the contract balance.","11.815336227416992","20000","ANSWER: FALSE\nEXPLANATION: The payment calculation in pendingPayment divides before multiplying: totalReceived * (shares[account] / totalShares) - alreadyReleased (see pendingPayment). With at least two payees, shares[account] < totalShares, so shares[account] / totalShares = 0, making payment = 0. Then release requires payment != 0 and reverts (see release). As release is the only function that sends ETH out, the contract balance cannot be decreased even when non-zero.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with two EOAs A and B and shares [1, 1].\n- Send 1 ETH to the contract (receive).\n- Call release(payable(A)) or release(payable(B)) from any address. payment computes to 0 due to integer truncation, causing require(payment != 0) to revert.\n- No transaction can reduce the contract balance."
"6","tx-transfer-balance-receive","False","FALSE","The function pendingPayment computes (totalReceived * shares[account]) / totalShares (see pendingPayment). There is no cap on shares in addPayee, and arithmetic in Solidity 0.8 reverts on overflow. If a payee’s shares are very large, the multiplication totalReceived * shares[account] can overflow, causing releasable/account and release to revert, making it impossible to withdraw funds. Since release is the only function that decreases balance, the contract can get stuck with a positive balance.","- Deploy with a single EOA payee Alice and shares[Alice] = 2^256 - 1 (addPayee allows this).\n- Send 2 wei to the contract (so totalReceived = 2 > 0, balance > 0).\n- Any call to release(payable(Alice)) computes pendingPayment(…) which tries 2 * (2^256 - 1) and overflows, causing releasable/release to revert.\n- No other function can decrease the contract balance, so the balance can never be reduced despite all payees being EOAs.","54.08873701095581","20000","ANSWER: FALSE\nEXPLANATION: The function pendingPayment computes (totalReceived * shares[account]) / totalShares (see pendingPayment). There is no cap on shares in addPayee, and arithmetic in Solidity 0.8 reverts on overflow. If a payee’s shares are very large, the multiplication totalReceived * shares[account] can overflow, causing releasable/account and release to revert, making it impossible to withdraw funds. Since release is the only function that decreases balance, the contract can get stuck with a positive balance.\nCOUNTEREXAMPLE: \n- Deploy with a single EOA payee Alice and shares[Alice] = 2^256 - 1 (addPayee allows this).\n- Send 2 wei to the contract (so totalReceived = 2 > 0, balance > 0).\n- Any call to release(payable(Alice)) computes pendingPayment(…) which tries 2 * (2^256 - 1) and overflows, causing releasable/release to revert.\n- No other function can decrease the contract balance, so the balance can never be reduced despite all payees being EOAs."
"7","tx-transfer-balance-receive","False","FALSE","The only function that can decrease the contract balance is release, which requires releasable(account) > 0 (see release: requires and releasable()). The releasable amount is computed via integer division in pendingPayment as (totalReceived * shares[account]) / totalShares - released[account]. Due to rounding, it is possible to have a non-zero contract balance while every payee’s releasable is 0, making release impossible for all payees and thus preventing any balance decrease.","- Deploy with two EOA payees A and B, shares [1, 1], so totalShares = 2.\n- Send 1 wei to the contract.\n- Now totalReceived = balance + totalReleased = 1. For each payee, releasable = floor(1 * 1 / 2) - 0 = 0.\n- release(A) and release(B) both revert at require(releasable(account) > 0) in release, so no transaction can decrease the balance despite a non-zero balance.","65.39215874671936","20000","ANSWER: FALSE\nEXPLANATION: The only function that can decrease the contract balance is release, which requires releasable(account) > 0 (see release: requires and releasable()). The releasable amount is computed via integer division in pendingPayment as (totalReceived * shares[account]) / totalShares - released[account]. Due to rounding, it is possible to have a non-zero contract balance while every payee’s releasable is 0, making release impossible for all payees and thus preventing any balance decrease.\nCOUNTEREXAMPLE: \n- Deploy with two EOA payees A and B, shares [1, 1], so totalShares = 2.\n- Send 1 wei to the contract.\n- Now totalReceived = balance + totalReleased = 1. For each payee, releasable = floor(1 * 1 / 2) - 0 = 0.\n- release(A) and release(B) both revert at require(releasable(account) > 0) in release, so no transaction can decrease the balance despite a non-zero balance."
"10","tx-transfer-balance-receive","False","FALSE","Many functions, including release and releasable, are guarded by require(stateCheck()) (receive(), releasable(), release(), pendingPayment(), and most getters). stateCheck requires address(this).balance + totalReleased <= MAX_RECEIVED, where MAX_RECEIVED is very low (999,999,999,999,999 wei). Because ETH can be forcibly sent via selfdestruct (which bypasses receive()), the contract can end up with balance > MAX_RECEIVED - totalReleased, making stateCheck false forever. In that state, release reverts and no transaction on PaymentSplitter can decrease its balance, even if all payees are EOAs.","- Deploy PaymentSplitter with payees [Alice (EOA)] and shares [1] (totalShares < 10000 holds).\n- From a separate contract Bomb, fund Bomb with 1 ETH and then selfdestruct Bomb to the PaymentSplitter address. This increases PaymentSplitter’s balance without invoking receive(), so address(this).balance + totalReleased > MAX_RECEIVED.\n- Now any call to PaymentSplitter.release(payable(Alice)) reverts on require(stateCheck()), and all other relevant functions also revert. No transaction on PaymentSplitter can decrease its balance.","24.31281065940857","20000","ANSWER: FALSE\nEXPLANATION: Many functions, including release and releasable, are guarded by require(stateCheck()) (receive(), releasable(), release(), pendingPayment(), and most getters). stateCheck requires address(this).balance + totalReleased <= MAX_RECEIVED, where MAX_RECEIVED is very low (999,999,999,999,999 wei). Because ETH can be forcibly sent via selfdestruct (which bypasses receive()), the contract can end up with balance > MAX_RECEIVED - totalReleased, making stateCheck false forever. In that state, release reverts and no transaction on PaymentSplitter can decrease its balance, even if all payees are EOAs.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with payees [Alice (EOA)] and shares [1] (totalShares < 10000 holds).\n- From a separate contract Bomb, fund Bomb with 1 ETH and then selfdestruct Bomb to the PaymentSplitter address. This increases PaymentSplitter’s balance without invoking receive(), so address(this).balance + totalReleased > MAX_RECEIVED.\n- Now any call to PaymentSplitter.release(payable(Alice)) reverts on require(stateCheck()), and all other relevant functions also revert. No transaction on PaymentSplitter can decrease its balance."
"8","tx-transfer-releasable-receive","True","TRUE","The public function release(address payable account) allows anyone to trigger a payment to account when payment = releasable(account) > 0. It requires shares[account] > 0 and then executes (bool success, ) = account.call{value: payment}(""""""""), requiring success (release, lines invoking call). Since account’s receive accepts ETH, the call succeeds. The computation totalReceived = address(this).balance + totalReleased in releasable/pendingPayment ensures the payment does not exceed the contract’s current balance.","N/A","38.201931953430176","20000","ANSWER: TRUE\nEXPLANATION: The public function release(address payable account) allows anyone to trigger a payment to account when payment = releasable(account) > 0. It requires shares[account] > 0 and then executes (bool success, ) = account.call{value: payment}(""""""""), requiring success (release, lines invoking call). Since account’s receive accepts ETH, the call succeeds. The computation totalReceived = address(this).balance + totalReleased in releasable/pendingPayment ensures the payment does not exceed the contract’s current balance.\nCOUNTEREXAMPLE: N/A"
"9","tx-transfer-releasable-receive","True","TRUE","The public function release(address payable account) computes payment = releasable(account) and, if payment != 0, transfers that amount to account via a low-level call and requires success ((bool success, ) = account.call{value: payment}(""""""""); require(success);). Since a’s receive accepts all ETH, the call will succeed, and anyone can invoke release(a) to trigger the transfer.","N/A","45.05214333534241","20000","ANSWER: TRUE\nEXPLANATION: The public function release(address payable account) computes payment = releasable(account) and, if payment != 0, transfers that amount to account via a low-level call and requires success ((bool success, ) = account.call{value: payment}(""""""""); require(success);). Since a’s receive accepts all ETH, the call will succeed, and anyone can invoke release(a) to trigger the transfer.\nCOUNTEREXAMPLE: N/A"
"10","tx-transfer-releasable-receive","True","TRUE","Anyone can call release(address payable) to transfer funds. If releasable(a) > 0, then shares[a] > 0 and stateCheck() holds (releasable() itself requires stateCheck()). In release(), payment is recomputed as releasable(a) and required to be nonzero, then sent via account.call{value: payment}("""""""") with require(success) (functions releasable, release, pendingPayment). Since a’s receive accepts ETH, the call succeeds and ETH is transferred from the contract to a.","N/A","103.66342544555664","20000","ANSWER: TRUE\nEXPLANATION: Anyone can call release(address payable) to transfer funds. If releasable(a) > 0, then shares[a] > 0 and stateCheck() holds (releasable() itself requires stateCheck()). In release(), payment is recomputed as releasable(a) and required to be nonzero, then sent via account.call{value: payment}("""""""") with require(success) (functions releasable, release, pendingPayment). Since a’s receive accepts ETH, the call succeeds and ETH is transferred from the contract to a.\nCOUNTEREXAMPLE: N/A"
