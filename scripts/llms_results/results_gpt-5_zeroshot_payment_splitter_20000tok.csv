"contract_id","property_id","ground_truth","llm_answer","llm_explanation","llm_counterexample","time","tokens","raw_output"
"1","fair-split-geq","False","TRUE","The contract enforces released[a] ≤ (address(this).balance + totalReleased) * shares[a] / totalShares at all times. Specifically:\n- totalReceived is defined as address(this).balance + totalReleased (releasable).\n- pendingPayment(account, totalReceived, released[account]) = (totalReceived * shares[account]) / totalShares - released[account].\n- release() increases released[account] exactly by releasable(account), i.e., by the non-negative difference between the allocation and alreadyReleased, and then transfers that amount. Thus after release, released[account] equals floor(totalReceived * shares[account] / totalShares).\n- On release, address(this).balance decreases by the payment while totalReleased increases by the same amount, keeping totalReceived constant; deposits only increase totalReceived. Therefore, released[account] can never exceed the computed allocation.\nRelevant code: releasable(), pendingPayment(), and release().","N/A","116.45584058761597","20000","ANSWER: TRUE\nEXPLANATION: The contract enforces released[a] ≤ (address(this).balance + totalReleased) * shares[a] / totalShares at all times. Specifically:\n- totalReceived is defined as address(this).balance + totalReleased (releasable).\n- pendingPayment(account, totalReceived, released[account]) = (totalReceived * shares[account]) / totalShares - released[account].\n- release() increases released[account] exactly by releasable(account), i.e., by the non-negative difference between the allocation and alreadyReleased, and then transfers that amount. Thus after release, released[account] equals floor(totalReceived * shares[account] / totalShares).\n- On release, address(this).balance decreases by the payment while totalReleased increases by the same amount, keeping totalReceived constant; deposits only increase totalReceived. Therefore, released[account] can never exceed the computed allocation.\nRelevant code: releasable(), pendingPayment(), and release().\nCOUNTEREXAMPLE: N/A"
"1","fair-split-geq-no-overflow","True","TRUE","The contract defines totalReceived as address(this).balance + totalReleased (releasable). For each payee a, pendingPayment computes ((totalReceived * shares[a]) / totalShares) - released[a]. The only way to increase released[a] is via release, which sets payment = pendingPayment and then updates released[a] += payment and totalReleased += payment. Since payment is never more than the computed due, released[a] never exceeds (totalReceived * shares[a]) / totalShares. Moreover, during a release, totalReceived remains constant (balance decreases by payment while totalReleased increases by the same payment), preserving the invariant.","N/A","125.50065541267395","20000","ANSWER: TRUE\nEXPLANATION: The contract defines totalReceived as address(this).balance + totalReleased (releasable). For each payee a, pendingPayment computes ((totalReceived * shares[a]) / totalShares) - released[a]. The only way to increase released[a] is via release, which sets payment = pendingPayment and then updates released[a] += payment and totalReleased += payment. Since payment is never more than the computed due, released[a] never exceeds (totalReceived * shares[a]) / totalShares. Moreover, during a release, totalReceived remains constant (balance decreases by payment while totalReleased increases by the same payment), preserving the invariant.\nCOUNTEREXAMPLE: N/A"
"1","non-zero-payees","True","TRUE","The only way entries are added to the payees array is via addPayee, called from the constructor. addPayee enforces account != ZERO_ADDRESS (require in addPayee), preventing the zero address from ever being pushed into payees. There are no other functions that modify payees after deployment.","N/A","14.69156527519226","20000","ANSWER: TRUE\nEXPLANATION: The only way entries are added to the payees array is via addPayee, called from the constructor. addPayee enforces account != ZERO_ADDRESS (require in addPayee), preventing the zero address from ever being pushed into payees. There are no other functions that modify payees after deployment.\nCOUNTEREXAMPLE: N/A"
"2","non-zero-payees","True","TRUE","The only way to insert into the payees array is via addPayee, which requires account != ZERO_ADDRESS (""""""""""""""""PaymentSplitter: account is the zero address""""""""""""""""). The constructor populates the three payees exclusively through addPayee, and there are no functions to modify payees afterward.","N/A","13.73404049873352","20000","ANSWER: TRUE\nEXPLANATION: The only way to insert into the payees array is via addPayee, which requires account != ZERO_ADDRESS (""""""""""""""""PaymentSplitter: account is the zero address""""""""""""""""). The constructor populates the three payees exclusively through addPayee, and there are no functions to modify payees afterward.\nCOUNTEREXAMPLE: N/A"
"3","non-zero-payees","True","TRUE","The constructor requires each of the three payees to be non-zero before adding them to the payees array (three separate require checks: payee1 != ZERO_ADDRESS, payee2 != ZERO_ADDRESS, payee3 != ZERO_ADDRESS). After construction, there are no functions that modify the payees array. Therefore, all addresses in payees are always non-zero.","N/A","17.48133873939514","20000","ANSWER: TRUE\nEXPLANATION: The constructor requires each of the three payees to be non-zero before adding them to the payees array (three separate require checks: payee1 != ZERO_ADDRESS, payee2 != ZERO_ADDRESS, payee3 != ZERO_ADDRESS). After construction, there are no functions that modify the payees array. Therefore, all addresses in payees are always non-zero.\nCOUNTEREXAMPLE: N/A"
"4","non-zero-payees","True","TRUE","The only way entries are added to the payees array is via addPayee, which enforces account != ZERO_ADDRESS. The constructor iterates over the provided payees_ and calls addPayee for each; there are no functions to add or modify payees afterward. Therefore, any deployed instance must have all payees non-zero.","N/A","18.12173581123352","20000","ANSWER: TRUE\nEXPLANATION: The only way entries are added to the payees array is via addPayee, which enforces account != ZERO_ADDRESS. The constructor iterates over the provided payees_ and calls addPayee for each; there are no functions to add or modify payees afterward. Therefore, any deployed instance must have all payees non-zero.\nCOUNTEREXAMPLE: N/A"
"5","non-zero-payees","True","TRUE","The only way payees are added is via the private addPayee function, which is called exclusively from the constructor. addPayee enforces that account != ZERO_ADDRESS via require (addPayee). Therefore, every element pushed into the payees array is non-zero and no other function can later modify payees.","N/A","10.349046230316162","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via the private addPayee function, which is called exclusively from the constructor. addPayee enforces that account != ZERO_ADDRESS via require (addPayee). Therefore, every element pushed into the payees array is non-zero and no other function can later modify payees.\nCOUNTEREXAMPLE: N/A"
"6","non-zero-payees","False","FALSE","The constructor calls addPayee for each provided payee. In addPayee, the zero-address check compares against a mis-set constant ZERO_ADDRESS = 0x...80 (not the true 0x0), via require(account != ZERO_ADDRESS, ...). This allows address(0) to be added to payees. See ZERO_ADDRESS definition and addPayee.","Deploy the contract with payees_ = [address(0x0)] and shares_ = [1]. The require(account != ZERO_ADDRESS) passes since ZERO_ADDRESS != address(0), so payees will contain address(0), violating the property.","14.94186282157898","20000","ANSWER: FALSE\nEXPLANATION: The constructor calls addPayee for each provided payee. In addPayee, the zero-address check compares against a mis-set constant ZERO_ADDRESS = 0x...80 (not the true 0x0), via require(account != ZERO_ADDRESS, ...). This allows address(0) to be added to payees. See ZERO_ADDRESS definition and addPayee.\nCOUNTEREXAMPLE: Deploy the contract with payees_ = [address(0x0)] and shares_ = [1]. The require(account != ZERO_ADDRESS) passes since ZERO_ADDRESS != address(0), so payees will contain address(0), violating the property."
"1","positive-shares","True","TRUE","The only way to populate the payees array is via addPayee, which is called from the constructor. addPayee enforces shares_ > 0 and pushes the account to payees only after this check. There are no functions that later modify shares or add payees (addPayee is private), so every address in payees always has shares[addr] > 0.","N/A","10.853040933609009","20000","ANSWER: TRUE\nEXPLANATION: The only way to populate the payees array is via addPayee, which is called from the constructor. addPayee enforces shares_ > 0 and pushes the account to payees only after this check. There are no functions that later modify shares or add payees (addPayee is private), so every address in payees always has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"2","positive-shares","True","TRUE","The only way payees are added is via addPayee, which is called exactly three times in the constructor. addPayee requires shares_ > 0 and sets shares[account] = shares_. No other function modifies shares or payees thereafter. Therefore every address in payees has shares[addr] > 0.","N/A","18.533000230789185","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via addPayee, which is called exactly three times in the constructor. addPayee requires shares_ > 0 and sets shares[account] = shares_. No other function modifies shares or payees thereafter. Therefore every address in payees has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"3","positive-shares","True","TRUE","In the constructor, each of the three payees is pushed into the payees array and assigned shares[payee] = 1. Duplicate or zero addresses are rejected. There are no functions that modify the payees array or the shares mapping after deployment. Therefore, for every address in payees, shares[address] remains > 0.","N/A","9.316549301147461","20000","ANSWER: TRUE\nEXPLANATION: In the constructor, each of the three payees is pushed into the payees array and assigned shares[payee] = 1. Duplicate or zero addresses are rejected. There are no functions that modify the payees array or the shares mapping after deployment. Therefore, for every address in payees, shares[address] remains > 0.\nCOUNTEREXAMPLE: N/A"
"4","positive-shares","True","TRUE","The only way to populate the payees array is via addPayee, which is called exclusively in the constructor. addPayee enforces shares_ > 0 and prevents duplicates (shares[account] == 0) and zero address. No function later modifies payees or shares. Therefore, every address in payees has shares[addr] > 0 and this remains invariant.","N/A","20.28274703025818","20000","ANSWER: TRUE\nEXPLANATION: The only way to populate the payees array is via addPayee, which is called exclusively in the constructor. addPayee enforces shares_ > 0 and prevents duplicates (shares[account] == 0) and zero address. No function later modifies payees or shares. Therefore, every address in payees has shares[addr] > 0 and this remains invariant.\nCOUNTEREXAMPLE: N/A"
"5","positive-shares","True","TRUE","The only way payees are added is via the constructor, which calls addPayee(account, shares_). In addPayee, there is a require(shares_ > 0, ...) and then shares[account] = shares_; payees.push(account). There are no functions that later modify payees or set shares to zero. Therefore, every address stored in payees has shares[addr] > 0.","N/A","10.74180006980896","20000","ANSWER: TRUE\nEXPLANATION: The only way payees are added is via the constructor, which calls addPayee(account, shares_). In addPayee, there is a require(shares_ > 0, ...) and then shares[account] = shares_; payees.push(account). There are no functions that later modify payees or set shares to zero. Therefore, every address stored in payees has shares[addr] > 0.\nCOUNTEREXAMPLE: N/A"
"8","tx-transfer-balance-receive","True","TRUE","Function release(address) either sends the due payment to the payee if releasable(account) > 0, or, if the computed payment is 0, it still sends 1 wei to the owner (see release: the if(payment != 0) branch sends payment; the else branch sends 1 wei to owner). With all payees EOAs, these calls succeed. Since the contract balance is non-zero, there exists at least one payee for whom releasable() does not underflow; calling release for such a payee will decrease the balance either by the payment or by 1 wei (owner drain).","N/A","172.0350935459137","20000","ANSWER: TRUE\nEXPLANATION: Function release(address) either sends the due payment to the payee if releasable(account) > 0, or, if the computed payment is 0, it still sends 1 wei to the owner (see release: the if(payment != 0) branch sends payment; the else branch sends 1 wei to owner). With all payees EOAs, these calls succeed. Since the contract balance is non-zero, there exists at least one payee for whom releasable() does not underflow; calling release for such a payee will decrease the balance either by the payment or by 1 wei (owner drain).\nCOUNTEREXAMPLE: N/A"
"1","tx-transfer-balance-receive","False","FALSE","The only function that can decrease the contract balance is release, which requires payment != 0 (release: “PaymentSplitter: account is not due payment”). The payment is computed as (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (pendingPayment). Due to integer division, when balance is small relative to totalShares, every payee’s computed payment can be 0, making release impossible and leaving a non-zero “dust” balance forever.","- Deploy with two EOA payees A and B, shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (balance = 1).\n- For each payee, releasable = (1 * 1 / 2) - 0 = 0.\n- Calling release(A) or release(B) reverts with """"""""""""""""PaymentSplitter: account is not due payment"""""""""""""""".\n- No other function decreases the balance, so the non-zero balance cannot be reduced.","42.00898599624634","20000","ANSWER: FALSE\nEXPLANATION: The only function that can decrease the contract balance is release, which requires payment != 0 (release: “PaymentSplitter: account is not due payment”). The payment is computed as (address(this).balance + totalReleased) * shares[account] / totalShares - released[account] (pendingPayment). Due to integer division, when balance is small relative to totalShares, every payee’s computed payment can be 0, making release impossible and leaving a non-zero “dust” balance forever.\nCOUNTEREXAMPLE: \n- Deploy with two EOA payees A and B, shares [1, 1] (totalShares = 2).\n- Send 1 wei to the contract (balance = 1).\n- For each payee, releasable = (1 * 1 / 2) - 0 = 0.\n- Calling release(A) or release(B) reverts with """"""""""""""""PaymentSplitter: account is not due payment"""""""""""""""".\n- No other function decreases the balance, so the non-zero balance cannot be reduced."
"6","tx-transfer-releasable-receive","True","TRUE","The public function release(address payable account) allows anyone to trigger a payment to account if releasable(account) > 0. It requires shares[account] > 0 and payment != 0, then performs (bool success, ) = account.call{value: payment}("""""""""""""""""""""""""""""""") and requires success. If a’s receive accepts ETH, this call succeeds, transferring ETH. See functions releasable (computes due payment) and release (performs the transfer and requires success).","N/A","38.00345492362976","20000","ANSWER: TRUE\nEXPLANATION: The public function release(address payable account) allows anyone to trigger a payment to account if releasable(account) > 0. It requires shares[account] > 0 and payment != 0, then performs (bool success, ) = account.call{value: payment}("""""""""""""""""""""""""""""""") and requires success. If a’s receive accepts ETH, this call succeeds, transferring ETH. See functions releasable (computes due payment) and release (performs the transfer and requires success).\nCOUNTEREXAMPLE: N/A"
"7","tx-transfer-releasable-receive","False","TRUE","If releasable(a) > 0, release(a) can be called, but only by a itself due to require(msg.sender == account) in release (lines requiring caller equals account). The function computes the due payment, updates accounting, and sends ETH via account.call{value: payment}("""""""""""""""""""""""""""""""") (which will succeed if a’s receive accepts ETH). Thus a can perform a transaction that transfers ETH from the contract to a.","N/A","54.55776929855347","20000","ANSWER: TRUE\nEXPLANATION: If releasable(a) > 0, release(a) can be called, but only by a itself due to require(msg.sender == account) in release (lines requiring caller equals account). The function computes the due payment, updates accounting, and sends ETH via account.call{value: payment}("""""""""""""""""""""""""""""""") (which will succeed if a’s receive accepts ETH). Thus a can perform a transaction that transfers ETH from the contract to a.\nCOUNTEREXAMPLE: N/A"
"9","tx-transfer-balance-receive","True","FALSE","The constructor does not require any payee to have a non-zero share (addPayee only checks for non-duplication and non-zero address). The release function requires shares[account] > 0 to proceed, so if all shares are zero, no release can ever succeed, and no other function decreases the balance. Thus, with non-zero balance and all payees being EOAs but having zero shares, the balance cannot be decreased. Relevant: constructor/addPayee (no check for shares_ > 0), release requires shares[account] > 0; else-branch (sending 1 wei to owner) is unreachable without passing this require.","1) Deploy PaymentSplitter with payees_ = [A] where A = msg.sender (EOA), shares_ = [0], and send 1 ether in the constructor call (contract balance = 1 ether).\n2) All payees are EOAs, but shares[A] = 0 and totalShares = 0.\n3) Any call to release(A) reverts at require(shares[account] > 0).\n4) No other function can decrease the balance. Therefore, despite non-zero balance and all payees being EOAs, no transaction can reduce the contract balance.","52.10583448410034","20000","ANSWER: FALSE\nEXPLANATION: The constructor does not require any payee to have a non-zero share (addPayee only checks for non-duplication and non-zero address). The release function requires shares[account] > 0 to proceed, so if all shares are zero, no release can ever succeed, and no other function decreases the balance. Thus, with non-zero balance and all payees being EOAs but having zero shares, the balance cannot be decreased. Relevant: constructor/addPayee (no check for shares_ > 0), release requires shares[account] > 0; else-branch (sending 1 wei to owner) is unreachable without passing this require.\nCOUNTEREXAMPLE: \n1) Deploy PaymentSplitter with payees_ = [A] where A = msg.sender (EOA), shares_ = [0], and send 1 ether in the constructor call (contract balance = 1 ether).\n2) All payees are EOAs, but shares[A] = 0 and totalShares = 0.\n3) Any call to release(A) reverts at require(shares[account] > 0).\n4) No other function can decrease the balance. Therefore, despite non-zero balance and all payees being EOAs, no transaction can reduce the contract balance."
"10","fair-split-eq","True","TRUE","For any payee a (added via addPayee with shares[a] > 0 and totalShares > 0), releasable(a) computes pendingPayment(a, totalReceived, released[a]) where totalReceived = address(this).balance + totalReleased (releasable). pendingPayment returns (totalReceived * shares[a]) / totalShares - released[a]. Therefore released[a] + releasable(a) = released[a] + ((totalReceived * shares[a]) / totalShares - released[a]) = (totalReceived * shares[a]) / totalShares. This holds in all callable states due to the definitions in releasable and pendingPayment.","N/A","101.82665729522705","20000","ANSWER: TRUE\nEXPLANATION: For any payee a (added via addPayee with shares[a] > 0 and totalShares > 0), releasable(a) computes pendingPayment(a, totalReceived, released[a]) where totalReceived = address(this).balance + totalReleased (releasable). pendingPayment returns (totalReceived * shares[a]) / totalShares - released[a]. Therefore released[a] + releasable(a) = released[a] + ((totalReceived * shares[a]) / totalShares - released[a]) = (totalReceived * shares[a]) / totalShares. This holds in all callable states due to the definitions in releasable and pendingPayment.\nCOUNTEREXAMPLE: N/A"
"1","fair-split-eq","False","TRUE","By definition, releasable(account) calls pendingPayment(account, totalReceived, released[account]) with totalReceived = address(this).balance + totalReleased (see releasable and pendingPayment). pendingPayment returns (totalReceived * shares[account]) / totalShares - released[account]. Therefore, for any payee a, released[a] + releasable(a) equals (totalReceived * shares[a]) / totalShares. Constructor guarantees totalShares > 0 and shares[a] > 0 for payees.","N/A","87.59235644340515","20000","ANSWER: TRUE\nEXPLANATION: By definition, releasable(account) calls pendingPayment(account, totalReceived, released[account]) with totalReceived = address(this).balance + totalReleased (see releasable and pendingPayment). pendingPayment returns (totalReceived * shares[account]) / totalShares - released[account]. Therefore, for any payee a, released[a] + releasable(a) equals (totalReceived * shares[a]) / totalShares. Constructor guarantees totalShares > 0 and shares[a] > 0 for payees.\nCOUNTEREXAMPLE: N/A"
"2","fair-split-eq","False","TRUE","By definition, releasable(account) computes pendingPayment(account, totalReceived, released[account]) where totalReceived = address(this).balance + totalReleased (see releasable). pendingPayment returns (totalReceived * shares[account]) / totalShares - alreadyReleased (see pendingPayment). Therefore, for any payee a, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares holds algebraically. The constructor enforces payees have nonzero shares and nonzero address via addPayee, so division by totalShares is valid.","N/A","78.96849131584167","20000","ANSWER: TRUE\nEXPLANATION: By definition, releasable(account) computes pendingPayment(account, totalReceived, released[account]) where totalReceived = address(this).balance + totalReleased (see releasable). pendingPayment returns (totalReceived * shares[account]) / totalShares - alreadyReleased (see pendingPayment). Therefore, for any payee a, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares holds algebraically. The constructor enforces payees have nonzero shares and nonzero address via addPayee, so division by totalShares is valid.\nCOUNTEREXAMPLE: N/A"
"3","fair-split-eq","False","TRUE","For each payee, shares[a] is set to 1 in the constructor and totalShares becomes 3 (three payees). The function releasable(a) computes (address(this).balance + totalReleased)/3 - released[a] (via pendingPayment using PAYEES=3). Therefore, for any payee a, released[a] + releasable(a) = (address(this).balance + totalReleased)/3 = (totalReceived * shares[a]) / totalShares.","N/A","65.70598530769348","20000","ANSWER: TRUE\nEXPLANATION: For each payee, shares[a] is set to 1 in the constructor and totalShares becomes 3 (three payees). The function releasable(a) computes (address(this).balance + totalReleased)/3 - released[a] (via pendingPayment using PAYEES=3). Therefore, for any payee a, released[a] + releasable(a) = (address(this).balance + totalReleased)/3 = (totalReceived * shares[a]) / totalShares.\nCOUNTEREXAMPLE: N/A"
"4","fair-split-eq","False","TRUE","By definition in releasable (function releasable), totalReceived is computed as address(this).balance + totalReleased. Then releasable(a) returns pendingPayment(a, totalReceived, released[a]) (function pendingPayment), which is (totalReceived * shares[a]) / totalShares - released[a]. Therefore released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares for any address a (including all payees). Preconditions ensuring totalShares > 0 are enforced in the constructor/addPayee (nonzero shares).","N/A","77.37825965881348","20000","ANSWER: TRUE\nEXPLANATION: By definition in releasable (function releasable), totalReceived is computed as address(this).balance + totalReleased. Then releasable(a) returns pendingPayment(a, totalReceived, released[a]) (function pendingPayment), which is (totalReceived * shares[a]) / totalShares - released[a]. Therefore released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares for any address a (including all payees). Preconditions ensuring totalShares > 0 are enforced in the constructor/addPayee (nonzero shares).\nCOUNTEREXAMPLE: N/A"
"5","fair-split-eq","False","FALSE","The function pendingPayment divides shares by totalShares before multiplying (pendingPayment), causing integer truncation: totalReceived * (shares[a] / totalShares) - released[a]. Thus released[a] + releasable(a) equals totalReceived * (shares[a] / totalShares), not (totalReceived * shares[a]) / totalShares as in the property. See releasable (computes totalReceived as balance + totalReleased) and pendingPayment (uses the incorrect order of operations).","Deploy with two payees A and B, shares [1, 1] (totalShares = 2). Send 100 wei to the contract. For A:\n- totalReceived = 100\n- shares[A] / totalShares = 1/2 = 0 (integer division)\n- releasable(A) = 100 * 0 - 0 = 0; released[A] = 0\nLeft-hand side: released[A] + releasable(A) = 0\nRight-hand side: (totalReceived * shares[A]) / totalShares = (100 * 1) / 2 = 50\nThus 0 != 50, violating the property.","24.92226481437683","20000","ANSWER: FALSE\nEXPLANATION: The function pendingPayment divides shares by totalShares before multiplying (pendingPayment), causing integer truncation: totalReceived * (shares[a] / totalShares) - released[a]. Thus released[a] + releasable(a) equals totalReceived * (shares[a] / totalShares), not (totalReceived * shares[a]) / totalShares as in the property. See releasable (computes totalReceived as balance + totalReleased) and pendingPayment (uses the incorrect order of operations).\nCOUNTEREXAMPLE: Deploy with two payees A and B, shares [1, 1] (totalShares = 2). Send 100 wei to the contract. For A:\n- totalReceived = 100\n- shares[A] / totalShares = 1/2 = 0 (integer division)\n- releasable(A) = 100 * 0 - 0 = 0; released[A] = 0\nLeft-hand side: released[A] + releasable(A) = 0\nRight-hand side: (totalReceived * shares[A]) / totalShares = (100 * 1) / 2 = 50\nThus 0 != 50, violating the property."
"6","fair-split-eq","False","FALSE","The equality relies on releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] (pendingPayment). However, addPayee allows arbitrarily large shares. In Solidity ^0.8, the multiplication totalReceived * shares[a] in pendingPayment is performed before division and can overflow, causing releasable(a) to revert. Thus, there exist reachable states where releasable(a) is undefined, so the stated equality does not always hold for every payee.","- Deploy with payees = [A], shares = [type(uint256).max] (allowed by addPayee).\n- Send 2 wei to the contract (so totalReceived = address(this).balance + totalReleased = 2).\n- For A: totalShares = type(uint256).max, shares[A] = type(uint256).max, released[A] = 0.\n- Calling releasable(A) computes (2 * type(uint256).max) / type(uint256).max - 0 in pendingPayment, which overflows on the multiplication and reverts.\n- Hence released[A] + releasable(A) cannot be evaluated, violating the “always” property.","160.44053864479065","20000","ANSWER: FALSE\nEXPLANATION: The equality relies on releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] (pendingPayment). However, addPayee allows arbitrarily large shares. In Solidity ^0.8, the multiplication totalReceived * shares[a] in pendingPayment is performed before division and can overflow, causing releasable(a) to revert. Thus, there exist reachable states where releasable(a) is undefined, so the stated equality does not always hold for every payee.\nCOUNTEREXAMPLE: \n- Deploy with payees = [A], shares = [type(uint256).max] (allowed by addPayee).\n- Send 2 wei to the contract (so totalReceived = address(this).balance + totalReleased = 2).\n- For A: totalShares = type(uint256).max, shares[A] = type(uint256).max, released[A] = 0.\n- Calling releasable(A) computes (2 * type(uint256).max) / type(uint256).max - 0 in pendingPayment, which overflows on the multiplication and reverts.\n- Hence released[A] + releasable(A) cannot be evaluated, violating the “always” property."
"7","fair-split-eq","False","FALSE","The identity holds algebraically by construction of releasable, but it is not guaranteed to be computable for all payees. In pendingPayment (called by releasable), the multiplication (totalReceived * shares[account]) can overflow and revert (Solidity 0.8+ checked arithmetic), see pendingPayment and releasable. The constructor/addPayee imposes no upper bound on shares (addPayee only checks shares_ > 0), so a payee can have an extremely large shares value, making the product overflow once totalReceived ≥ 2, causing releasable to revert. Thus the stated equality does not always hold (the left-hand side cannot even be evaluated for that payee).","- Deploy with payees_ = [A], shares_ = [type(uint256).max].\n- Send 2 wei to the contract (totalReceived = address(this).balance + totalReleased = 2).\n- For a = A, calling releasable(A) triggers pendingPayment which computes (2 * type(uint256).max) / totalShares - released[A]; the multiplication overflows and reverts.\n- Therefore released[A] + releasable(A) cannot be evaluated, violating the “always” property.","116.87277412414551","20000","ANSWER: FALSE\nEXPLANATION: The identity holds algebraically by construction of releasable, but it is not guaranteed to be computable for all payees. In pendingPayment (called by releasable), the multiplication (totalReceived * shares[account]) can overflow and revert (Solidity 0.8+ checked arithmetic), see pendingPayment and releasable. The constructor/addPayee imposes no upper bound on shares (addPayee only checks shares_ > 0), so a payee can have an extremely large shares value, making the product overflow once totalReceived ≥ 2, causing releasable to revert. Thus the stated equality does not always hold (the left-hand side cannot even be evaluated for that payee).\nCOUNTEREXAMPLE: \n- Deploy with payees_ = [A], shares_ = [type(uint256).max].\n- Send 2 wei to the contract (totalReceived = address(this).balance + totalReleased = 2).\n- For a = A, calling releasable(A) triggers pendingPayment which computes (2 * type(uint256).max) / totalShares - released[A]; the multiplication overflows and reverts.\n- Therefore released[A] + releasable(A) cannot be evaluated, violating the “always” property."
"8","fair-split-eq","False","FALSE","The equality holds only as long as releasable(account) can be computed as (totalReceived * shares[account]) / totalShares - released[account]. However, in release(), when payment == 0 the contract sends 1 wei to owner without updating totalReleased or released (else branch), reducing address(this).balance and hence totalReceived by 1 while leaving released unchanged. This can make released[account] > floor(totalReceived * shares[account] / totalShares), so releasable(account) underflows and reverts. Thus the stated equality does not always hold for all payees. See functions releasable(), pendingPayment(), and the else branch in release().","- Deploy with payees [Owner O, Alice A], shares [1, 2] (totalShares = 3).\n- Send 3 wei to the contract.\n- Call release(O): pays 1 wei to O.\n- Call release(A): pays 2 wei to A. Now totalReleased = 3, balance = 0, released[O]=1, released[A]=2, totalReceived = 3.\n- Send 2 wei to the contract (balance = 2, totalReleased = 3, totalReceived = 5).\n- Call release(A): payment = floor(5*2/3) - 2 = 1; pays 1 wei; totalReleased = 4; balance = 1; released[A] = 3; totalReceived remains 5.\n- Call release(O): payment = floor(5*1/3) - 1 = 0; else-branch executes and transfers 1 wei to owner; totalReleased stays 4; balance becomes 0; totalReceived becomes 4.\n- Now for A: RHS = floor(4*2/3) = 2, but released[A] = 3 and releasable(A) = floor(4*2/3) - 3 = -1 (underflow → revert). Hence the property “released[A] + releasable(A) == (totalReceived * shares[A]) / totalShares” is violated (releasable(A) cannot be computed).","231.560688495636","20000","ANSWER: FALSE\nEXPLANATION: The equality holds only as long as releasable(account) can be computed as (totalReceived * shares[account]) / totalShares - released[account]. However, in release(), when payment == 0 the contract sends 1 wei to owner without updating totalReleased or released (else branch), reducing address(this).balance and hence totalReceived by 1 while leaving released unchanged. This can make released[account] > floor(totalReceived * shares[account] / totalShares), so releasable(account) underflows and reverts. Thus the stated equality does not always hold for all payees. See functions releasable(), pendingPayment(), and the else branch in release().\nCOUNTEREXAMPLE: \n- Deploy with payees [Owner O, Alice A], shares [1, 2] (totalShares = 3).\n- Send 3 wei to the contract.\n- Call release(O): pays 1 wei to O.\n- Call release(A): pays 2 wei to A. Now totalReleased = 3, balance = 0, released[O]=1, released[A]=2, totalReceived = 3.\n- Send 2 wei to the contract (balance = 2, totalReleased = 3, totalReceived = 5).\n- Call release(A): payment = floor(5*2/3) - 2 = 1; pays 1 wei; totalReleased = 4; balance = 1; released[A] = 3; totalReceived remains 5.\n- Call release(O): payment = floor(5*1/3) - 1 = 0; else-branch executes and transfers 1 wei to owner; totalReleased stays 4; balance becomes 0; totalReceived becomes 4.\n- Now for A: RHS = floor(4*2/3) = 2, but released[A] = 3 and releasable(A) = floor(4*2/3) - 3 = -1 (underflow → revert). Hence the property “released[A] + releasable(A) == (totalReceived * shares[A]) / totalShares” is violated (releasable(A) cannot be computed)."
"9","fair-split-eq","False","FALSE","The invariant relies on totalReceived = address(this).balance + totalReleased staying consistent when distributions happen. However, in release(), if payment == 0 the contract sends 1 wei to owner without updating totalReleased (see the else branch in release). This decreases address(this).balance and thus totalReceived, potentially making released[a] exceed (totalReceived * shares[a]) / totalShares. Then releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] underflows and reverts, so released[a] + releasable(a) cannot equal the right-hand side.","- Deploy with payees [owner, Bob], shares [1, 1].\n- Send 2 wei to the contract.\n- Call release(Bob): payment = (2*1)/2 - 0 = 1; after: released[Bob] = 1, totalReleased = 1, balance = 1.\n- Call release(Charlie) where Charlie has 0 shares (not a payee): payment = 0, so the else branch sends 1 wei to owner; after: balance = 0, totalReleased = 1.\n- Now for a = Bob: RHS = ((balance + totalReleased) * shares[a]) / totalShares = (0 + 1) * 1 / 2 = 0, but released[Bob] = 1. releasable(Bob) would be (1*1)/2 - 1 = 0 - 1, which underflows and reverts. Hence released[Bob] + releasable(Bob) ≠ 0, violating the property.","52.38512301445007","20000","ANSWER: FALSE\nEXPLANATION: The invariant relies on totalReceived = address(this).balance + totalReleased staying consistent when distributions happen. However, in release(), if payment == 0 the contract sends 1 wei to owner without updating totalReleased (see the else branch in release). This decreases address(this).balance and thus totalReceived, potentially making released[a] exceed (totalReceived * shares[a]) / totalShares. Then releasable(a) = (totalReceived * shares[a]) / totalShares - released[a] underflows and reverts, so released[a] + releasable(a) cannot equal the right-hand side.\nCOUNTEREXAMPLE:\n- Deploy with payees [owner, Bob], shares [1, 1].\n- Send 2 wei to the contract.\n- Call release(Bob): payment = (2*1)/2 - 0 = 1; after: released[Bob] = 1, totalReleased = 1, balance = 1.\n- Call release(Charlie) where Charlie has 0 shares (not a payee): payment = 0, so the else branch sends 1 wei to owner; after: balance = 0, totalReleased = 1.\n- Now for a = Bob: RHS = ((balance + totalReleased) * shares[a]) / totalShares = (0 + 1) * 1 / 2 = 0, but released[Bob] = 1. releasable(Bob) would be (1*1)/2 - 1 = 0 - 1, which underflows and reverts. Hence released[Bob] + releasable(Bob) ≠ 0, violating the property."
"1","fair-split-eq-no-overflow","True","TRUE","The function releasable(account) sets totalReceived = address(this).balance + totalReleased and returns pendingPayment(account, totalReceived, released[account]) (function releasable). pendingPayment computes (totalReceived * shares[account]) / totalShares - alreadyReleased (function pendingPayment). Therefore, for any payee a: released[a] + releasable(a) = released[a] + ((totalReceived * shares[a]) / totalShares - released[a]) = (totalReceived * shares[a]) / totalShares. The release logic preserves totalReceived (address(this).balance decreases by payment while totalReleased increases by the same payment), keeping the identity valid after payouts. This holds whenever the multiplication does not overflow.","N/A","46.674492597579956","20000","ANSWER: TRUE\nEXPLANATION: The function releasable(account) sets totalReceived = address(this).balance + totalReleased and returns pendingPayment(account, totalReceived, released[account]) (function releasable). pendingPayment computes (totalReceived * shares[account]) / totalShares - alreadyReleased (function pendingPayment). Therefore, for any payee a: released[a] + releasable(a) = released[a] + ((totalReceived * shares[a]) / totalShares - released[a]) = (totalReceived * shares[a]) / totalShares. The release logic preserves totalReceived (address(this).balance decreases by payment while totalReleased increases by the same payment), keeping the identity valid after payouts. This holds whenever the multiplication does not overflow.\nCOUNTEREXAMPLE: N/A"
"2","fair-split-eq-no-overflow","True","TRUE","By definition, releasable(a) is computed as pendingPayment(account, totalReceived, released[account]) where totalReceived = address(this).balance + totalReleased (function releasable). pendingPayment returns (totalReceived * shares[account]) / totalShares - alreadyReleased. Hence, for any payee a, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares. The constructor/addPayee ensure totalShares > 0 and shares[a] > 0 for payees, and the property conditions exclude overflow.","N/A","28.70275354385376","20000","ANSWER: TRUE\nEXPLANATION: By definition, releasable(a) is computed as pendingPayment(account, totalReceived, released[account]) where totalReceived = address(this).balance + totalReleased (function releasable). pendingPayment returns (totalReceived * shares[account]) / totalShares - alreadyReleased. Hence, for any payee a, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares. The constructor/addPayee ensure totalShares > 0 and shares[a] > 0 for payees, and the property conditions exclude overflow.\nCOUNTEREXAMPLE: N/A"
"3","fair-split-eq-no-overflow","True","TRUE","Each payee gets exactly 1 share (constructor sets shares[payeeX] = 1 and increments totalShares to 3). releasable(a) computes totalReceived = address(this).balance + totalReleased and returns (totalReceived / PAYEES) - released[a] (pendingPayment). Thus, for any payee a: released[a] + releasable(a) = released[a] + (totalReceived/3 - released[a]) = totalReceived/3. Since shares[a] = 1 and totalShares = 3, (totalReceived * shares[a]) / totalShares = totalReceived/3. See: PAYEES=3, shares set in constructor, releasable(a), pendingPayment, and totalShares updates in constructor.","N/A","90.45831513404846","20000","ANSWER: TRUE\nEXPLANATION: Each payee gets exactly 1 share (constructor sets shares[payeeX] = 1 and increments totalShares to 3). releasable(a) computes totalReceived = address(this).balance + totalReleased and returns (totalReceived / PAYEES) - released[a] (pendingPayment). Thus, for any payee a: released[a] + releasable(a) = released[a] + (totalReceived/3 - released[a]) = totalReceived/3. Since shares[a] = 1 and totalShares = 3, (totalReceived * shares[a]) / totalShares = totalReceived/3. See: PAYEES=3, shares set in constructor, releasable(a), pendingPayment, and totalShares updates in constructor.\nCOUNTEREXAMPLE: N/A"
"5","fair-split-eq-no-overflow","True","FALSE","The function pendingPayment divides before multiplying: totalReceived * (shares[account] / totalShares) - alreadyReleased (see pendingPayment). This causes integer truncation, so released[a] + releasable(a) equals totalReceived * (shares[a] / totalShares), which can differ from (totalReceived * shares[a]) / totalShares.","- Deploy with payees = [A, B], shares = [1, 99].\n- Send 100 wei to the contract.\n- totalReceived = address(this).balance + totalReleased = 100 + 0 = 100.\n- For A: shares[A] = 1, totalShares = 100.\n  - Contract computes: releasable(A) = 100 * (1/100) - 0 = 0 (since 1/100 = 0 by integer division). So released[A] + releasable(A) = 0.\n  - Property RHS: (100 * 1) / 100 = 1.\n- Hence 0 != 1, violating the property without overflow.","24.443004846572876","20000","ANSWER: FALSE\nEXPLANATION: The function pendingPayment divides before multiplying: totalReceived * (shares[account] / totalShares) - alreadyReleased (see pendingPayment). This causes integer truncation, so released[a] + releasable(a) equals totalReceived * (shares[a] / totalShares), which can differ from (totalReceived * shares[a]) / totalShares.\nCOUNTEREXAMPLE: \n- Deploy with payees = [A, B], shares = [1, 99].\n- Send 100 wei to the contract.\n- totalReceived = address(this).balance + totalReleased = 100 + 0 = 100.\n- For A: shares[A] = 1, totalShares = 100.\n  - Contract computes: releasable(A) = 100 * (1/100) - 0 = 0 (since 1/100 = 0 by integer division). So released[A] + releasable(A) = 0.\n  - Property RHS: (100 * 1) / 100 = 1.\n- Hence 0 != 1, violating the property without overflow."
"6","fair-split-eq-no-overflow","True","TRUE","By definition in releasable(account), totalReceived is computed as address(this).balance + totalReleased, and pendingPayment returns (totalReceived * shares[account]) / totalShares - released[account]. Therefore, for any payee a, released[a] + releasable(a) equals (totalReceived * shares[a]) / totalShares whenever the multiplication does not overflow. See releasable and pendingPayment.","N/A","97.7842710018158","20000","ANSWER: TRUE\nEXPLANATION: By definition in releasable(account), totalReceived is computed as address(this).balance + totalReleased, and pendingPayment returns (totalReceived * shares[account]) / totalShares - released[account]. Therefore, for any payee a, released[a] + releasable(a) equals (totalReceived * shares[a]) / totalShares whenever the multiplication does not overflow. See releasable and pendingPayment.\nCOUNTEREXAMPLE: N/A"
"7","fair-split-eq-no-overflow","True","TRUE","By definition, releasable(account) computes totalReceived = address(this).balance + totalReleased and returns pendingPayment(account, totalReceived, released[account]) which equals (totalReceived * shares[account]) / totalShares - released[account] (see releasable and pendingPayment). Thus, for any payee, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares. The constructor and addPayee ensure totalShares > 0, and the property is conditioned on no overflow.","N/A","37.71979284286499","20000","ANSWER: TRUE\nEXPLANATION: By definition, releasable(account) computes totalReceived = address(this).balance + totalReleased and returns pendingPayment(account, totalReceived, released[account]) which equals (totalReceived * shares[account]) / totalShares - released[account] (see releasable and pendingPayment). Thus, for any payee, released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares. The constructor and addPayee ensure totalShares > 0, and the property is conditioned on no overflow.\nCOUNTEREXAMPLE: N/A"
"10","fair-split-eq-no-overflow","True","FALSE","The equality is defined via releasable(account) = (totalReceived * shares[account]) / totalShares - released[account]. However, releasable() (and pendingPayment()) both require stateCheck() (see releasable and pendingPayment), which enforces address(this).balance + totalReleased <= MAX_RECEIVED (see stateCheck). If ETH is force-sent via selfdestruct so that address(this).balance + totalReleased > MAX_RECEIVED, releasable() reverts even though the arithmetic on the RHS does not overflow. Thus the stated equality cannot hold in all reachable states.","- Deploy PaymentSplitter with payees [A, B] and shares [1, 1].\n- Deploy an attacker contract:\n  contract Force {\n      function boom(address payable target) external payable { selfdestruct(target); }\n  }\n- Call Force.boom{value: MAX_RECEIVED + 1}(payable(address(splitter))) to force-send ETH.\n- Now totalReceived = address(splitter).balance + totalReleased = MAX_RECEIVED + 1, which does not overflow.\n- Call splitter.releasable(A) -> it reverts due to require(stateCheck()) in releasable, so released[A] + releasable(A) cannot equal (totalReceived * shares[A]) / totalShares.","82.80192160606384","20000","ANSWER: FALSE\nEXPLANATION: The equality is defined via releasable(account) = (totalReceived * shares[account]) / totalShares - released[account]. However, releasable() (and pendingPayment()) both require stateCheck() (see releasable and pendingPayment), which enforces address(this).balance + totalReleased <= MAX_RECEIVED (see stateCheck). If ETH is force-sent via selfdestruct so that address(this).balance + totalReleased > MAX_RECEIVED, releasable() reverts even though the arithmetic on the RHS does not overflow. Thus the stated equality cannot hold in all reachable states.\nCOUNTEREXAMPLE: \n- Deploy PaymentSplitter with payees [A, B] and shares [1, 1].\n- Deploy an attacker contract:\n  contract Force {\n      function boom(address payable target) external payable { selfdestruct(target); }\n  }\n- Call Force.boom{value: MAX_RECEIVED + 1}(payable(address(splitter))) to force-send ETH.\n- Now totalReceived = address(splitter).balance + totalReleased = MAX_RECEIVED + 1, which does not overflow.\n- Call splitter.releasable(A) -> it reverts due to require(stateCheck()) in releasable, so released[A] + releasable(A) cannot equal (totalReceived * shares[A]) / totalShares."
"4","fair-split-eq-no-overflow","False","TRUE","In releasable(account), totalReceived is defined as address(this).balance + totalReleased, and the function returns pendingPayment(account, totalReceived, released[account]) which is (totalReceived * shares[account]) / totalShares - released[account] (see releasable and pendingPayment). Therefore, for any payee (shares[a] > 0), released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares, matching the stated property whenever the arithmetic does not overflow.","N/A","51.69570755958557","20000","ANSWER: TRUE\nEXPLANATION: In releasable(account), totalReceived is defined as address(this).balance + totalReleased, and the function returns pendingPayment(account, totalReceived, released[account]) which is (totalReceived * shares[account]) / totalShares - released[account] (see releasable and pendingPayment). Therefore, for any payee (shares[a] > 0), released[a] + releasable(a) = (totalReceived * shares[a]) / totalShares, matching the stated property whenever the arithmetic does not overflow.\nCOUNTEREXAMPLE: N/A"
"8","fair-split-eq-no-overflow","False","FALSE","The function releasable(account) defines totalReceived as address(this).balance + totalReleased and computes pendingPayment as (totalReceived * shares[account]) / totalShares - released[account]. However, the release function’s else-branch sends 1 wei to owner when payment == 0 without updating totalReleased. This decreases address(this).balance (hence totalReceived) while keeping released unchanged, breaking the invariant. Consequently, there exist reachable states where released[a] > (totalReceived * shares[a]) / totalShares, making the equality fail and releasable(a) underflow/revert. See release (else branch sending 1 wei to owner) and pendingPayment.","- Deploy with payees [A (owner), B] and shares [2, 1] (totalShares = 3).\n- Send 2 wei to the contract.\n- Call release(A): totalReceived = 2; payment = floor(2*2/3) - 0 = 1. State after: released[A] = 1, totalReleased = 1, balance = 1.\n- Call release(B): totalReceived = balance + totalReleased = 1 + 1 = 2; payment = floor(2*1/3) - 0 = 0 ⇒ else-branch sends 1 wei to owner. State after: balance = 0, totalReleased = 1, released[B] = 0.\n- Now for a = A: totalReceived = 0 + 1 = 1; RHS = floor(1*2/3) = 0, but released[A] = 1. Therefore released[A] + releasable(A) cannot equal 0; in fact releasable(A) attempts to compute floor(1*2/3) - 1 = -1 and reverts. Hence the stated equality does not hold.","192.28954434394836","20000","ANSWER: FALSE\nEXPLANATION: The function releasable(account) defines totalReceived as address(this).balance + totalReleased and computes pendingPayment as (totalReceived * shares[account]) / totalShares - released[account]. However, the release function’s else-branch sends 1 wei to owner when payment == 0 without updating totalReleased. This decreases address(this).balance (hence totalReceived) while keeping released unchanged, breaking the invariant. Consequently, there exist reachable states where released[a] > (totalReceived * shares[a]) / totalShares, making the equality fail and releasable(a) underflow/revert. See release (else branch sending 1 wei to owner) and pendingPayment.\nCOUNTEREXAMPLE: \n- Deploy with payees [A (owner), B] and shares [2, 1] (totalShares = 3).\n- Send 2 wei to the contract.\n- Call release(A): totalReceived = 2; payment = floor(2*2/3) - 0 = 1. State after: released[A] = 1, totalReleased = 1, balance = 1.\n- Call release(B): totalReceived = balance + totalReleased = 1 + 1 = 2; payment = floor(2*1/3) - 0 = 0 ⇒ else-branch sends 1 wei to owner. State after: balance = 0, totalReleased = 1, released[B] = 0.\n- Now for a = A: totalReceived = 0 + 1 = 1; RHS = floor(1*2/3) = 0, but released[A] = 1. Therefore released[A] + releasable(A) cannot equal 0; in fact releasable(A) attempts to compute floor(1*2/3) - 1 = -1 and reverts. Hence the stated equality does not hold."
"9","fair-split-eq-no-overflow","False","FALSE","The equality is algebraically enforced by releasable() (which computes (balance + totalReleased) * shares[a] / totalShares − released[a]), but release() has a nonstandard else branch that, when payment == 0, sends 1 wei to owner without updating totalReleased (see release()’s else branch). This reduces totalReceived = balance + totalReleased and can make released[a] exceed (totalReceived * shares[a]) / totalShares. Then pendingPayment underflows and releasable(a) reverts, so released[a] + releasable(a) is undefined while the RHS is well-defined, violating the property. Relevant code: releasable(), pendingPayment(), and the else branch in release().","- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract. Now balance = 2, totalReleased = 0, totalReceived = 2.\n- Call release(A): payment = (2*1)/2 − 0 = 1. After: released[A] = 1, totalReleased = 1, balance = 1, totalReceived = 2.\n- Call release(A) again: payment = (2*1)/2 − 1 = 0, so the else branch sends 1 wei to owner. After: released[A] = 1, totalReleased = 1, balance = 0, totalReceived = 1.\n- Now for A: RHS = (1*1)/2 = 0 (no overflow). But releasable(A) = (1*1)/2 − 1 underflows and reverts, so released[A] + releasable(A) is not a value. Hence the stated equality does not hold for every payee.","153.98778700828552","20000","ANSWER: FALSE\nEXPLANATION: The equality is algebraically enforced by releasable() (which computes (balance + totalReleased) * shares[a] / totalShares − released[a]), but release() has a nonstandard else branch that, when payment == 0, sends 1 wei to owner without updating totalReleased (see release()’s else branch). This reduces totalReceived = balance + totalReleased and can make released[a] exceed (totalReceived * shares[a]) / totalShares. Then pendingPayment underflows and releasable(a) reverts, so released[a] + releasable(a) is undefined while the RHS is well-defined, violating the property. Relevant code: releasable(), pendingPayment(), and the else branch in release().\nCOUNTEREXAMPLE:\n- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract. Now balance = 2, totalReleased = 0, totalReceived = 2.\n- Call release(A): payment = (2*1)/2 − 0 = 1. After: released[A] = 1, totalReleased = 1, balance = 1, totalReceived = 2.\n- Call release(A) again: payment = (2*1)/2 − 1 = 0, so the else branch sends 1 wei to owner. After: released[A] = 1, totalReleased = 1, balance = 0, totalReceived = 1.\n- Now for A: RHS = (1*1)/2 = 0 (no overflow). But releasable(A) = (1*1)/2 − 1 underflows and reverts, so released[A] + releasable(A) is not a value. Hence the stated equality does not hold for every payee."
"10","fair-split-geq","True","TRUE","The only way released[a] increases is via release(account), which sets payment = (address(this).balance + totalReleased) * shares[a] / totalShares - released[a] (via releasable -> pendingPayment) and then does released[a] += payment and totalReleased += payment. A release preserves address(this).balance + totalReleased, so released[a] becomes exactly the current floor entitlement and never exceeds it. Since totalReceived can only stay the same (on releases) or increase (on deposits), the invariant (totalReceived * shares[a]) / totalShares >= released[a] always holds for every payee. Relevant functions: release, releasable, pendingPayment.","N/A","76.6989266872406","20000","ANSWER: TRUE\nEXPLANATION: The only way released[a] increases is via release(account), which sets payment = (address(this).balance + totalReleased) * shares[a] / totalShares - released[a] (via releasable -> pendingPayment) and then does released[a] += payment and totalReleased += payment. A release preserves address(this).balance + totalReleased, so released[a] becomes exactly the current floor entitlement and never exceeds it. Since totalReceived can only stay the same (on releases) or increase (on deposits), the invariant (totalReceived * shares[a]) / totalShares >= released[a] always holds for every payee. Relevant functions: release, releasable, pendingPayment.\nCOUNTEREXAMPLE: N/A"
"2","fair-split-geq","False","TRUE","The only way released[a] changes is via release(), which increases released[a] by releasable(a). releasable(a) is defined as pendingPayment(a, totalReceived, released[a]) where totalReceived = address(this).balance + totalReleased and pendingPayment returns (totalReceived * shares[a]) / totalShares - released[a]. Thus after any call to release(), released[a] becomes at most floor((totalReceived * shares[a]) / totalShares). No other function modifies released[a] or totalShares/shares[a]. Reentrancy cannot violate this because the increase in totalReleased is exactly offset by the decrease in balance during value transfer, keeping totalReceived consistent.","N/A","112.17759108543396","20000","ANSWER: TRUE\nEXPLANATION: The only way released[a] changes is via release(), which increases released[a] by releasable(a). releasable(a) is defined as pendingPayment(a, totalReceived, released[a]) where totalReceived = address(this).balance + totalReleased and pendingPayment returns (totalReceived * shares[a]) / totalShares - released[a]. Thus after any call to release(), released[a] becomes at most floor((totalReceived * shares[a]) / totalShares). No other function modifies released[a] or totalShares/shares[a]. Reentrancy cannot violate this because the increase in totalReleased is exactly offset by the decrease in balance during value transfer, keeping totalReceived consistent.\nCOUNTEREXAMPLE: N/A"
"3","fair-split-geq","False","TRUE","Each payee gets exactly 1 share and totalShares is set to 3 in the constructor. releasable(account) computes payment as (address(this).balance + totalReleased)/3 - released[account] (see releasable and pendingPayment), and release updates released[account] by at most this amount. Thus, after any sequence of operations, released[a] ≤ floor((address(this).balance + totalReleased)/3) = floor(totalReceived/3). Since shares[a] = 1 and totalShares = 3, the property (totalReceived * shares[a]) / totalShares ≥ released[a] holds for every payee at all times. Moreover, totalReceived = balance + totalReleased is non-decreasing (sending ETH increases totalReleased while decreasing balance by the same amount), preserving the invariant.","N/A","91.07583022117615","20000","ANSWER: TRUE\nEXPLANATION: Each payee gets exactly 1 share and totalShares is set to 3 in the constructor. releasable(account) computes payment as (address(this).balance + totalReleased)/3 - released[account] (see releasable and pendingPayment), and release updates released[account] by at most this amount. Thus, after any sequence of operations, released[a] ≤ floor((address(this).balance + totalReleased)/3) = floor(totalReceived/3). Since shares[a] = 1 and totalShares = 3, the property (totalReceived * shares[a]) / totalShares ≥ released[a] holds for every payee at all times. Moreover, totalReceived = balance + totalReleased is non-decreasing (sending ETH increases totalReleased while decreasing balance by the same amount), preserving the invariant.\nCOUNTEREXAMPLE: N/A"
"4","fair-split-geq","False","FALSE","The invariant relies on totalReceived = address(this).balance + totalReleased (releasable) and on released[account] being increased by at most the account’s pro-rata share. However, in release the contract:\n- updates totalReleased and released[account] in an unchecked block (unchecked { totalReleased += payment; released[account] += payment; })\n- ignores the result of the value transfer (account.call{value: payment}(""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""))\nThis lets an attacker repeatedly call release for a payee whose fallback reverts, so the transfer always fails but totalReleased and released[payee] still increase while balance stays unchanged. Repeating this can grow totalReleased without bound and, due to unchecked addition, eventually overflow uint256. When totalReleased overflows, totalReceived wraps to a small value while some other payee’s released remains large, violating (totalReceived * shares[a]) / totalShares >= released[a].","- Setup: Deploy with payees [A, B], shares [1, 1], and initial ETH (e.g., 2 wei). Let A be a contract whose fallback reverts on receiving ETH.\n- Step 1: Call release(A) repeatedly. Each time, payment = (address(this).balance + totalReleased)/2 - released[A]. The external call to A fails, but unchecked { totalReleased += payment; released[A] += payment; } executes, so totalReleased grows while balance stays constant. Repeat until totalReleased is just below 2^256 (no overflow yet).\n- Step 2: Call release(B) once. This sets released[B] to X = floor((address(this).balance + totalReleased)/2), a very large number, and increases totalReleased accordingly (still below 2^256 because of the choice in Step 1).\n- Step 3: Call release(A) once more. The unchecked addition totalReleased += payment overflows, wrapping totalReleased to a small value Y. The call again fails, so balance remains unchanged.\n- Result: Now totalReceived = address(this).balance + totalReleased ≈ address(this).balance + Y is small, hence (totalReceived * shares[B]) / totalShares = floor(totalReceived / 2) is small, but released[B] = X is huge from Step 2. Therefore, (totalReceived * shares[B]) / totalShares < released[B], violating the property.","235.2142789363861","20000","ANSWER: FALSE\nEXPLANATION: The invariant relies on totalReceived = address(this).balance + totalReleased (releasable) and on released[account] being increased by at most the account’s pro-rata share. However, in release the contract:\n- updates totalReleased and released[account] in an unchecked block (unchecked { totalReleased += payment; released[account] += payment; })\n- ignores the result of the value transfer (account.call{value: payment}(""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""))\nThis lets an attacker repeatedly call release for a payee whose fallback reverts, so the transfer always fails but totalReleased and released[payee] still increase while balance stays unchanged. Repeating this can grow totalReleased without bound and, due to unchecked addition, eventually overflow uint256. When totalReleased overflows, totalReceived wraps to a small value while some other payee’s released remains large, violating (totalReceived * shares[a]) / totalShares >= released[a].\nCOUNTEREXAMPLE: \n- Setup: Deploy with payees [A, B], shares [1, 1], and initial ETH (e.g., 2 wei). Let A be a contract whose fallback reverts on receiving ETH.\n- Step 1: Call release(A) repeatedly. Each time, payment = (address(this).balance + totalReleased)/2 - released[A]. The external call to A fails, but unchecked { totalReleased += payment; released[A] += payment; } executes, so totalReleased grows while balance stays constant. Repeat until totalReleased is just below 2^256 (no overflow yet).\n- Step 2: Call release(B) once. This sets released[B] to X = floor((address(this).balance + totalReleased)/2), a very large number, and increases totalReleased accordingly (still below 2^256 because of the choice in Step 1).\n- Step 3: Call release(A) once more. The unchecked addition totalReleased += payment overflows, wrapping totalReleased to a small value Y. The call again fails, so balance remains unchanged.\n- Result: Now totalReceived = address(this).balance + totalReleased ≈ address(this).balance + Y is small, hence (totalReceived * shares[B]) / totalShares = floor(totalReceived / 2) is small, but released[B] = X is huge from Step 2. Therefore, (totalReceived * shares[B]) / totalShares < released[B], violating the property."
"5","fair-split-geq","False","TRUE","totalReceived is computed as address(this).balance + totalReleased (releasable). The only way released[a] can increase is via release, which uses payment = releasable(account) and pendingPayment. Because pendingPayment divides first (totalReceived * (shares[a] / totalShares) - released[a]), when there are multiple payees shares[a] / totalShares = 0, so payment is 0 and released[a] stays 0, trivially satisfying (totalReceived * shares[a]) / totalShares ≥ released[a]. With a single payee, shares[a] = totalShares so payment = totalReceived - released[a], ensuring released[a] ≤ totalReceived. State is updated before the external call and reverts on failure, keeping the invariant intact.","N/A","84.29706168174744","20000","ANSWER: TRUE\nEXPLANATION: totalReceived is computed as address(this).balance + totalReleased (releasable). The only way released[a] can increase is via release, which uses payment = releasable(account) and pendingPayment. Because pendingPayment divides first (totalReceived * (shares[a] / totalShares) - released[a]), when there are multiple payees shares[a] / totalShares = 0, so payment is 0 and released[a] stays 0, trivially satisfying (totalReceived * shares[a]) / totalShares ≥ released[a]. With a single payee, shares[a] = totalShares so payment = totalReceived - released[a], ensuring released[a] ≤ totalReceived. State is updated before the external call and reverts on failure, keeping the invariant intact.\nCOUNTEREXAMPLE: N/A"
"6","fair-split-geq","False","TRUE","The invariant follows directly from how payments are computed and recorded. In releasable(account) the contract computes pendingPayment as (totalReceived * shares[account]) / totalShares - released[account] (functions releasable and pendingPayment). In release, it then increases released[account] by exactly this amount and increases totalReleased by the same amount, so after any release we have released[account] = floor(totalReceived * shares[account] / totalShares) at that moment, and never more. Since totalReceived is defined as address(this).balance + totalReleased, releasing funds keeps totalReceived constant (balance decreases while totalReleased increases by the same amount), preserving the inequality at all times, including under reentrancy.","N/A","71.37700653076172","20000","ANSWER: TRUE\nEXPLANATION: The invariant follows directly from how payments are computed and recorded. In releasable(account) the contract computes pendingPayment as (totalReceived * shares[account]) / totalShares - released[account] (functions releasable and pendingPayment). In release, it then increases released[account] by exactly this amount and increases totalReleased by the same amount, so after any release we have released[account] = floor(totalReceived * shares[account] / totalShares) at that moment, and never more. Since totalReceived is defined as address(this).balance + totalReleased, releasing funds keeps totalReceived constant (balance decreases while totalReleased increases by the same amount), preserving the inequality at all times, including under reentrancy.\nCOUNTEREXAMPLE: N/A"
"7","fair-split-geq","False","TRUE","The invariant follows from how payments are computed and state is updated. pendingPayment(account, R, released[a]) returns (R * shares[a]) / totalShares − released[a], where R = address(this).balance + totalReleased (releasable). release only pays when this value is > 0 and then does:\n- totalReleased += payment and released[a] += payment (release),\n- sends exactly payment out, so address(this).balance decreases by payment.\nThus R remains unchanged during a release, making released[a] become exactly floor(R * shares[a] / totalShares). Deposits only increase R, so the LHS cannot decrease below released[a]. Constructor/addPayee ensure totalShares > 0 and shares[a] > 0, preventing division by zero and non-payees receiving shares.","N/A","48.05093789100647","20000","ANSWER: TRUE\nEXPLANATION: The invariant follows from how payments are computed and state is updated. pendingPayment(account, R, released[a]) returns (R * shares[a]) / totalShares − released[a], where R = address(this).balance + totalReleased (releasable). release only pays when this value is > 0 and then does:\n- totalReleased += payment and released[a] += payment (release),\n- sends exactly payment out, so address(this).balance decreases by payment.\nThus R remains unchanged during a release, making released[a] become exactly floor(R * shares[a] / totalShares). Deposits only increase R, so the LHS cannot decrease below released[a]. Constructor/addPayee ensure totalShares > 0 and shares[a] > 0, preventing division by zero and non-payees receiving shares.\nCOUNTEREXAMPLE: N/A"
"8","fair-split-geq","False","FALSE","The property depends on totalReceived = address(this).balance + totalReleased (releasable). In release, when payment == 0, the contract transfers 1 wei to owner without updating released[...] or totalReleased. This reduces address(this).balance and thus totalReceived, potentially making released[a] exceed (totalReceived * shares[a]) / totalShares.","- Setup: Deploy with payees [owner (msg.sender), Bob] and shares [1, 1]. totalShares = 2.\n- Fund: Send 2 wei to the contract.\n- Step 1: Call release(Bob). Payment = ( (2) * 1 ) / 2 - 0 = 1 wei. After execution: released[Bob] = 1, totalReleased = 1, contract balance = 1.\n- Step 2: Call release(Bob) again. Now payment = ( (balance + totalReleased) * 1 ) / 2 - released[Bob] = ( (1 + 1) * 1 ) / 2 - 1 = 0, so the else branch executes and sends 1 wei to owner. After this: contract balance = 0, totalReleased = 1 (unchanged), totalReceived = balance + totalReleased = 1.\n- Check: Bob’s entitlement = (1 * 1) / 2 = 0, but released[Bob] = 1. Thus (totalReceived * shares[Bob]) / totalShares < released[Bob], violating the property.","38.07414674758911","20000","ANSWER: FALSE\nEXPLANATION: The property depends on totalReceived = address(this).balance + totalReleased (releasable). In release, when payment == 0, the contract transfers 1 wei to owner without updating released[...] or totalReleased. This reduces address(this).balance and thus totalReceived, potentially making released[a] exceed (totalReceived * shares[a]) / totalShares.\nCOUNTEREXAMPLE: \n- Setup: Deploy with payees [owner (msg.sender), Bob] and shares [1, 1]. totalShares = 2.\n- Fund: Send 2 wei to the contract.\n- Step 1: Call release(Bob). Payment = ( (2) * 1 ) / 2 - 0 = 1 wei. After execution: released[Bob] = 1, totalReleased = 1, contract balance = 1.\n- Step 2: Call release(Bob) again. Now payment = ( (balance + totalReleased) * 1 ) / 2 - released[Bob] = ( (1 + 1) * 1 ) / 2 - 1 = 0, so the else branch executes and sends 1 wei to owner. After this: contract balance = 0, totalReleased = 1 (unchanged), totalReceived = balance + totalReleased = 1.\n- Check: Bob’s entitlement = (1 * 1) / 2 = 0, but released[Bob] = 1. Thus (totalReceived * shares[Bob]) / totalShares < released[Bob], violating the property."
"9","fair-split-geq","False","FALSE","The function release has an else branch that, when payment == 0, sends 1 wei to owner without increasing totalReleased (see release: the else branch with owner.call{value: 1}(""""""""). This decreases address(this).balance while leaving totalReleased unchanged, so totalReceived = balance + totalReleased decreases. Since released[a] does not decrease, the ratio (totalReceived * shares[a]) / totalShares can become less than released[a], violating the property. releasable defines totalReceived as address(this).balance + totalReleased and pendingPayment computes the ratio used in the property.","- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract.\n- Call release(A): payment = floor((2 * 1)/2) - 0 = 1. After execution: totalReleased = 1, released[A] = 1, balance = 1, totalReceived = 1 + 1 = 2.\n- Call release(C) where C is not a payee (shares[C] = 0): payment = 0, so the else branch executes and transfers 1 wei to owner. Now balance = 0, totalReleased = 1, hence totalReceived = 0 + 1 = 1.\n- For payee A: (totalReceived * shares[A]) / totalShares = floor(1 * 1 / 2) = 0 < released[A] = 1. Property violated.","41.51250600814819","20000","ANSWER: FALSE\nEXPLANATION: The function release has an else branch that, when payment == 0, sends 1 wei to owner without increasing totalReleased (see release: the else branch with owner.call{value: 1}(""""""""). This decreases address(this).balance while leaving totalReleased unchanged, so totalReceived = balance + totalReleased decreases. Since released[a] does not decrease, the ratio (totalReceived * shares[a]) / totalShares can become less than released[a], violating the property. releasable defines totalReceived as address(this).balance + totalReleased and pendingPayment computes the ratio used in the property.\nCOUNTEREXAMPLE: \n- Deploy with payees [A (owner), B] and shares [1, 1] (totalShares = 2).\n- Send 2 wei to the contract.\n- Call release(A): payment = floor((2 * 1)/2) - 0 = 1. After execution: totalReleased = 1, released[A] = 1, balance = 1, totalReceived = 1 + 1 = 2.\n- Call release(C) where C is not a payee (shares[C] = 0): payment = 0, so the else branch executes and transfers 1 wei to owner. Now balance = 0, totalReleased = 1, hence totalReceived = 0 + 1 = 1.\n- For payee A: (totalReceived * shares[A]) / totalShares = floor(1 * 1 / 2) = 0 < released[A] = 1. Property violated."
