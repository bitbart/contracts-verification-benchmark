"contract_id","property_id","ground_truth","llm_answer","llm_explanation","llm_counterexample","time","tokens","raw_output"
"1","guardAddressChange","True","FALSE","While GuardManager.setGuard is the only function in the code that explicitly writes to GUARD_STORAGE_SLOT (see GuardManager.setGuard, sstore(GUARD_STORAGE_SLOT, guard)), the Safe can execute arbitrary delegatecalls (see Executor.execute: delegatecall when operation == Enum.Operation.DelegateCall, invoked by Safe.execTransaction). Any delegatecalled contract can directly write to the same GUARD_STORAGE_SLOT and thus change the transaction guard without calling setGuard. This can also occur during setup via setupModules(to, data), which delegatecalls arbitrary initializer code.","1) Deploy Safe with owner Alice (threshold=1).\n2) Deploy a helper contract:\n   contract GuardChanger {\n       function change(address newGuard) external {\n           bytes32 slot = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8; // GUARD_STORAGE_SLOT\n           assembly { sstore(slot, newGuard) }\n       }\n   }\n3) Alice submits Safe.execTransaction pointing to GuardChanger with operation=DelegateCall and data encoding change(attackerGuard).\n4) Executor.execute performs a delegatecall into GuardChanger, which sstores to GUARD_STORAGE_SLOT, changing the guard without calling setGuard.","45.90009117126465","20000","ANSWER: FALSE\nEXPLANATION: While GuardManager.setGuard is the only function in the code that explicitly writes to GUARD_STORAGE_SLOT (see GuardManager.setGuard, sstore(GUARD_STORAGE_SLOT, guard)), the Safe can execute arbitrary delegatecalls (see Executor.execute: delegatecall when operation == Enum.Operation.DelegateCall, invoked by Safe.execTransaction). Any delegatecalled contract can directly write to the same GUARD_STORAGE_SLOT and thus change the transaction guard without calling setGuard. This can also occur during setup via setupModules(to, data), which delegatecalls arbitrary initializer code.\nCOUNTEREXAMPLE: \n1) Deploy Safe with owner Alice (threshold=1).\n2) Deploy a helper contract:\n   contract GuardChanger {\n       function change(address newGuard) external {\n           bytes32 slot = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8; // GUARD_STORAGE_SLOT\n           assembly { sstore(slot, newGuard) }\n       }\n   }\n3) Alice submits Safe.execTransaction pointing to GuardChanger with operation=DelegateCall and data encoding change(attackerGuard).\n4) Executor.execute performs a delegatecall into GuardChanger, which sstores to GUARD_STORAGE_SLOT, changing the guard without calling setGuard."
"1","setGuardReentrant","True","TRUE","The function setGuard in GuardManager is marked with the authorized modifier (GuardManager.setGuard), which comes from SelfAuthorized and enforces require(msg.sender == address(this)) via requireSelfCall (""""""""GS031""""""""). Therefore, only the contract itself can invoke setGuard (e.g., through an internal/self-call), and any direct external call by a user reverts.","N/A","41.32869911193848","20000","ANSWER: TRUE\nEXPLANATION: The function setGuard in GuardManager is marked with the authorized modifier (GuardManager.setGuard), which comes from SelfAuthorized and enforces require(msg.sender == address(this)) via requireSelfCall (""""""""GS031""""""""). Therefore, only the contract itself can invoke setGuard (e.g., through an internal/self-call), and any direct external call by a user reverts.\nCOUNTEREXAMPLE: N/A"
"1","txnGuardCalled","True","FALSE","In execTransaction, the guard is called pre-execution via ITransactionGuard(guard).checkTransaction(...) if a guard is set. However, post-execution it calls ITransactionGuard(guard).checkAfterExecution(txHash, success) only after the execution block. If the inner execution fails with safeTxGas == 0 and gasPrice == 0, the function reverts early (assembly revert) before the post-guard call, so the guard is not called post-execution. See Safe.execTransaction: pre-call to checkTransaction before execution; early revert on (!success && safeTxGas == 0 && gasPrice == 0); post-call to checkAfterExecution only after that revert point.","- Assume a guard G is installed (setGuard(G) succeeds and G supports ITransactionGuard).\n- Deploy a target contract T with a function that reverts.\n- Call execTransaction with to = T, data = T.revertingFunction(), operation = Call, safeTxGas = 0, baseGas arbitrary, gasPrice = 0, gasToken = 0, refundReceiver arbitrary, and valid owner signatures.\n- Flow: guard.checkTransaction(...) is executed; T.revertingFunction() reverts; since safeTxGas == 0 and gasPrice == 0, execTransaction reverts before reaching guard.checkAfterExecution(...). Thus, the transaction guard is not called post-execution.","46.777052879333496","20000","ANSWER: FALSE\nEXPLANATION: In execTransaction, the guard is called pre-execution via ITransactionGuard(guard).checkTransaction(...) if a guard is set. However, post-execution it calls ITransactionGuard(guard).checkAfterExecution(txHash, success) only after the execution block. If the inner execution fails with safeTxGas == 0 and gasPrice == 0, the function reverts early (assembly revert) before the post-guard call, so the guard is not called post-execution. See Safe.execTransaction: pre-call to checkTransaction before execution; early revert on (!success && safeTxGas == 0 && gasPrice == 0); post-call to checkAfterExecution only after that revert point.\nCOUNTEREXAMPLE: \n- Assume a guard G is installed (setGuard(G) succeeds and G supports ITransactionGuard).\n- Deploy a target contract T with a function that reverts.\n- Call execTransaction with to = T, data = T.revertingFunction(), operation = Call, safeTxGas = 0, baseGas arbitrary, gasPrice = 0, gasToken = 0, refundReceiver arbitrary, and valid owner signatures.\n- Flow: guard.checkTransaction(...) is executed; T.revertingFunction() reverts; since safeTxGas == 0 and gasPrice == 0, execTransaction reverts before reaching guard.checkAfterExecution(...). Thus, the transaction guard is not called post-execution."
"1","moduleGuardAddressChange","True","FALSE","Besides setModuleGuard (ModuleManager.setModuleGuard) writing to MODULE_GUARD_STORAGE_SLOT, the contract allows arbitrary delegatecalls that can modify storage. Specifically:\n- Safe.execTransaction forwards the chosen operation to Executor.execute, which performs a delegatecall when operation == Enum.Operation.DelegateCall (base/Executor.sol).\n- setupModules in ModuleManager does a delegatecall to an arbitrary initializer (base/ModuleManager.sol).\nAny delegatecalled code runs in the Safe’s storage context and can sstore directly to MODULE_GUARD_STORAGE_SLOT (libraries/SafeStorage.sol), thereby changing the module guard without calling setModuleGuard.","- Deploy a helper contract H with function attack(address newGuard) { bytes32 slot = 0xb104e0b93118902c651344349b610029d694cfdec91c589c91ebafbcd0289947; assembly { sstore(slot, newGuard) } }.\n- An owner of the Safe submits execTransaction with:\n  to = H, value = 0, data = abi.encodeWithSelector(H.attack.selector, someAddress), operation = Enum.Operation.DelegateCall, safeTxGas/baseGas/gasPrice as needed, and valid signatures.\n- Executor.execute performs a delegatecall into H (base/Executor.sol), which stores newGuard directly into MODULE_GUARD_STORAGE_SLOT.\n- The module guard is changed without invoking setModuleGuard. Alternatively, the same can be done during setup via setupModules(to=H, data=attack(...)) (base/ModuleManager.sol).","71.56658673286438","20000","ANSWER: FALSE\nEXPLANATION: Besides setModuleGuard (ModuleManager.setModuleGuard) writing to MODULE_GUARD_STORAGE_SLOT, the contract allows arbitrary delegatecalls that can modify storage. Specifically:\n- Safe.execTransaction forwards the chosen operation to Executor.execute, which performs a delegatecall when operation == Enum.Operation.DelegateCall (base/Executor.sol).\n- setupModules in ModuleManager does a delegatecall to an arbitrary initializer (base/ModuleManager.sol).\nAny delegatecalled code runs in the Safe’s storage context and can sstore directly to MODULE_GUARD_STORAGE_SLOT (libraries/SafeStorage.sol), thereby changing the module guard without calling setModuleGuard.\nCOUNTEREXAMPLE: \n- Deploy a helper contract H with function attack(address newGuard) { bytes32 slot = 0xb104e0b93118902c651344349b610029d694cfdec91c589c91ebafbcd0289947; assembly { sstore(slot, newGuard) } }.\n- An owner of the Safe submits execTransaction with:\n  to = H, value = 0, data = abi.encodeWithSelector(H.attack.selector, someAddress), operation = Enum.Operation.DelegateCall, safeTxGas/baseGas/gasPrice as needed, and valid signatures.\n- Executor.execute performs a delegatecall into H (base/Executor.sol), which stores newGuard directly into MODULE_GUARD_STORAGE_SLOT.\n- The module guard is changed without invoking setModuleGuard. Alternatively, the same can be done during setup via setupModules(to=H, data=attack(...)) (base/ModuleManager.sol)."
"1","setModuleGuardReentrant","True","TRUE","The function setModuleGuard in ModuleManager is marked with the authorized modifier (ModuleManager.setModuleGuard). The authorized modifier from SelfAuthorized enforces requireSelfCall(), which reverts unless msg.sender == address(this) (""""""""GS031""""""""). Thus, only the contract itself can successfully call setModuleGuard.","N/A","32.342562437057495","20000","ANSWER: TRUE\nEXPLANATION: The function setModuleGuard in ModuleManager is marked with the authorized modifier (ModuleManager.setModuleGuard). The authorized modifier from SelfAuthorized enforces requireSelfCall(), which reverts unless msg.sender == address(this) (""""""""GS031""""""""). Thus, only the contract itself can successfully call setModuleGuard.\nCOUNTEREXAMPLE: N/A"
"1","execTxnModulePermissions","True","TRUE","The function execTransactionFromModule calls preModuleExecution, which enforces that the caller must be an enabled module: it reverts if msg.sender == SENTINEL_MODULES or modules[msg.sender] == address(0) (see ModuleManager.preModuleExecution: “GS104”). Since this check happens before execution and revert aborts the call, any successful return from execTransactionFromModule implies the caller was an enabled module.","N/A","51.38721537590027","20000","ANSWER: TRUE\nEXPLANATION: The function execTransactionFromModule calls preModuleExecution, which enforces that the caller must be an enabled module: it reverts if msg.sender == SENTINEL_MODULES or modules[msg.sender] == address(0) (see ModuleManager.preModuleExecution: “GS104”). Since this check happens before execution and revert aborts the call, any successful return from execTransactionFromModule implies the caller was an enabled module.\nCOUNTEREXAMPLE: N/A"
"1","execTxnModuleReturnDataPermissions","True","TRUE","In ModuleManager.execTransactionFromModuleReturnData, the first action is preModuleExecution, which enforces that the caller must be an enabled module. Specifically, it reverts with """"""""GS104"""""""" if msg.sender == SENTINEL_MODULES or modules[msg.sender] == address(0) (preModuleExecution in ModuleManager). Thus, any call that does not revert (i.e., succeeds) must come from an enabled module.","N/A","75.8549325466156","20000","ANSWER: TRUE\nEXPLANATION: In ModuleManager.execTransactionFromModuleReturnData, the first action is preModuleExecution, which enforces that the caller must be an enabled module. Specifically, it reverts with """"""""GS104"""""""" if msg.sender == SENTINEL_MODULES or modules[msg.sender] == address(0) (preModuleExecution in ModuleManager). Thus, any call that does not revert (i.e., succeeds) must come from an enabled module.\nCOUNTEREXAMPLE: N/A"
"1","executePermissions","True","FALSE","The internal function execute(...) is invoked from multiple places beyond execTransaction and execTransactionFromModule. In particular:\n- ModuleManager.setupModules(...) calls execute with a DelegateCall when initializing modules (see setupModules in ModuleManager).\n- ModuleManager.execTransactionFromModuleReturnData(...) also calls execute.\nTherefore, execute is not limited to execTransaction or execTransactionFromModule.","Deploy a Safe and call setup with a non-zero initializer:\n1) Deploy any contract Dummy at address D (so isContract(D) is true).\n2) Call Safe.setup([owner], 1, D, 0x, address(0), address(0), 0, payable(0)).\nDuring setup, setupModules(to=D, data=0x) is executed, which calls execute(..., Enum.Operation.DelegateCall, ...), even though neither execTransaction nor execTransactionFromModule was invoked.","57.834028244018555","20000","ANSWER: FALSE\nEXPLANATION: The internal function execute(...) is invoked from multiple places beyond execTransaction and execTransactionFromModule. In particular:\n- ModuleManager.setupModules(...) calls execute with a DelegateCall when initializing modules (see setupModules in ModuleManager).\n- ModuleManager.execTransactionFromModuleReturnData(...) also calls execute.\nTherefore, execute is not limited to execTransaction or execTransactionFromModule.\nCOUNTEREXAMPLE: Deploy a Safe and call setup with a non-zero initializer:\n1) Deploy any contract Dummy at address D (so isContract(D) is true).\n2) Call Safe.setup([owner], 1, D, 0x, address(0), address(0), 0, payable(0)).\nDuring setup, setupModules(to=D, data=0x) is executed, which calls execute(..., Enum.Operation.DelegateCall, ...), even though neither execTransaction nor execTransactionFromModule was invoked."
"1","approvedHashesSet","True","FALSE","In Safe.approveHash(bytes32), the mapping is set only if msg.sender is an owner; otherwise the function reverts via revertWithError(""""""""GS030"""""""") and no state is updated. Therefore, it is not true that approvedHashes is set on every call to approveHash.","After setup with owners = [O1], an external user A (not an owner) calls approveHash(H). The function checks if owners[A] == address(0) and reverts with """"""""GS030"""""""", leaving approvedHashes[A][H] unset (0).","36.305097579956055","20000","ANSWER: FALSE\nEXPLANATION: In Safe.approveHash(bytes32), the mapping is set only if msg.sender is an owner; otherwise the function reverts via revertWithError(""""""""GS030"""""""") and no state is updated. Therefore, it is not true that approvedHashes is set on every call to approveHash.\nCOUNTEREXAMPLE: After setup with owners = [O1], an external user A (not an owner) calls approveHash(H). The function checks if owners[A] == address(0) and reverts with """"""""GS030"""""""", leaving approvedHashes[A][H] unset (0)."
"1","approvedHashesUpdate","True","FALSE","While approveHash() only sets approvedHashes[msg.sender][hash] (Safe.sol, approveHash), the contract supports arbitrary delegatecall execution via execTransaction/execTransactionFromModule (Safe.sol execTransaction; base/Executor.sol execute). A delegatecall lets external code run in the Safe’s storage context and write to approvedHashes at its storage slot directly, without going through approveHash() or requiring msg.sender == user.","- Setup a Safe with owner A (threshold = 1).\n- Deploy a contract Writer with a function that, via assembly, computes the storage slot for approvedHashes[user][hash] (slot p = 8 for approvedHashes in Safe) and SSTOREs 1 there.\n- Have A sign a Safe transaction with operation = DelegateCall, to = Writer, data = Writer.writeApproved(user = U, hash = H).\n- A relayer R submits execTransaction with the valid signature. Safe (Safe.execTransaction -> Executor.execute) delegatecalls Writer, which writes approvedHashes[U][H] = 1 in Safe’s storage. During this write, msg.sender is R (or the module if using execTransactionFromModule), not U. Thus approvedHashes[U][H] changed while msg.sender != U.","97.13116431236267","20000","ANSWER: FALSE\nEXPLANATION: While approveHash() only sets approvedHashes[msg.sender][hash] (Safe.sol, approveHash), the contract supports arbitrary delegatecall execution via execTransaction/execTransactionFromModule (Safe.sol execTransaction; base/Executor.sol execute). A delegatecall lets external code run in the Safe’s storage context and write to approvedHashes at its storage slot directly, without going through approveHash() or requiring msg.sender == user.\nCOUNTEREXAMPLE: \n- Setup a Safe with owner A (threshold = 1).\n- Deploy a contract Writer with a function that, via assembly, computes the storage slot for approvedHashes[user][hash] (slot p = 8 for approvedHashes in Safe) and SSTOREs 1 there.\n- Have A sign a Safe transaction with operation = DelegateCall, to = Writer, data = Writer.writeApproved(user = U, hash = H).\n- A relayer R submits execTransaction with the valid signature. Safe (Safe.execTransaction -> Executor.execute) delegatecalls Writer, which writes approvedHashes[U][H] = 1 in Safe’s storage. During this write, msg.sender is R (or the module if using execTransactionFromModule), not U. Thus approvedHashes[U][H] changed while msg.sender != U."
"1","transactionHashCantCollide","True","UNKNOWN","The transaction hash is computed by getTransactionHash using keccak256 over all transaction fields plus the domain separator (which depends on chainid and the Safe’s address) and the provided nonce. See Safe.getTransactionHash and Safe.domainSeparator. Given this, two distinct sets of parameters would hash to the same value only via a keccak256 collision. Since collision resistance of keccak256 is a cryptographic assumption not guaranteed by the code itself, we cannot prove the property always holds.","N/A","163.8373122215271","20000","ANSWER: UNKNOWN\nEXPLANATION: The transaction hash is computed by getTransactionHash using keccak256 over all transaction fields plus the domain separator (which depends on chainid and the Safe’s address) and the provided nonce. See Safe.getTransactionHash and Safe.domainSeparator. Given this, two distinct sets of parameters would hash to the same value only via a keccak256 collision. Since collision resistance of keccak256 is a cryptographic assumption not guaranteed by the code itself, we cannot prove the property always holds.\nCOUNTEREXAMPLE: N/A"
"1","fallbackHandlerNeverSelf","True","FALSE","Although FallbackManager.internalSetFallbackHandler forbids setting the handler to address(this) (reverts “GS400”), Safe.setup later executes setupModules(to, data), which performs an arbitrary delegatecall (ModuleManager.setupModules). Via this delegatecall, malicious initialization code can directly sstore to FALLBACK_HANDLER_STORAGE_SLOT and set it to the Safe’s own address, bypassing the check. Relevant code: Safe.setup (calls internalSetFallbackHandler then setupModules), ModuleManager.setupModules (delegatecall), FallbackManager.internalSetFallbackHandler (check), and FALLBACK_HANDLER_STORAGE_SLOT definition.","- Deploy a malicious init contract BadInit with a function poison() that, when delegatecalled, executes: sstore(FALLBACK_HANDLER_STORAGE_SLOT, address()).\n- Create a Safe proxy and call Safe.setup with parameters:\n  - _owners = [some EOA], _threshold = 1,\n  - to = address(BadInit), data = abi.encodeWithSelector(BadInit.poison.selector),\n  - fallbackHandler = address(0) (or any non-self address), paymentToken/payment/paymentReceiver arbitrary.\n- During setup: internalSetFallbackHandler enforces the non-self rule, but then setupModules(to, data) delegatecalls BadInit.poison, which writes the Safe’s own address into FALLBACK_HANDLER_STORAGE_SLOT.\n- Result: the fallback handler slot is set to the Safe contract address, violating the property.","82.79201602935791","20000","ANSWER: FALSE\nEXPLANATION: Although FallbackManager.internalSetFallbackHandler forbids setting the handler to address(this) (reverts “GS400”), Safe.setup later executes setupModules(to, data), which performs an arbitrary delegatecall (ModuleManager.setupModules). Via this delegatecall, malicious initialization code can directly sstore to FALLBACK_HANDLER_STORAGE_SLOT and set it to the Safe’s own address, bypassing the check. Relevant code: Safe.setup (calls internalSetFallbackHandler then setupModules), ModuleManager.setupModules (delegatecall), FallbackManager.internalSetFallbackHandler (check), and FALLBACK_HANDLER_STORAGE_SLOT definition.\nCOUNTEREXAMPLE: \n- Deploy a malicious init contract BadInit with a function poison() that, when delegatecalled, executes: sstore(FALLBACK_HANDLER_STORAGE_SLOT, address()).\n- Create a Safe proxy and call Safe.setup with parameters:\n  - _owners = [some EOA], _threshold = 1,\n  - to = address(BadInit), data = abi.encodeWithSelector(BadInit.poison.selector),\n  - fallbackHandler = address(0) (or any non-self address), paymentToken/payment/paymentReceiver arbitrary.\n- During setup: internalSetFallbackHandler enforces the non-self rule, but then setupModules(to, data) delegatecalls BadInit.poison, which writes the Safe’s own address into FALLBACK_HANDLER_STORAGE_SLOT.\n- Result: the fallback handler slot is set to the Safe contract address, violating the property."
"1","setFallbackIntegrity","True","FALSE","The fallback handler can be set without calling setFallbackHandler. In Safe.setup(), if a non-zero fallbackHandler is provided, the contract directly calls internalSetFallbackHandler(fallbackHandler) (Safe.sol: setup) which writes to the fallback handler storage slot (FallbackManager.sol: internalSetFallbackHandler). Thus, the handler is not always set via setFallbackHandler.","- Deploy a Safe and call setup with a non-zero fallbackHandler address H.\n- During setup, internalSetFallbackHandler(H) is executed, setting the fallback handler without invoking setFallbackHandler.","23.98369836807251","20000","ANSWER: FALSE\nEXPLANATION: The fallback handler can be set without calling setFallbackHandler. In Safe.setup(), if a non-zero fallbackHandler is provided, the contract directly calls internalSetFallbackHandler(fallbackHandler) (Safe.sol: setup) which writes to the fallback handler storage slot (FallbackManager.sol: internalSetFallbackHandler). Thus, the handler is not always set via setFallbackHandler.\nCOUNTEREXAMPLE: \n- Deploy a Safe and call setup with a non-zero fallbackHandler address H.\n- During setup, internalSetFallbackHandler(H) is executed, setting the fallback handler without invoking setFallbackHandler.\n"
"1","setupThresholdZeroAndSetsPositiveThreshold","True","TRUE","Safe.setup delegates owner/threshold initialization to OwnerManager.setupOwners. That function reverts if threshold > 0 (GS200), ensuring setup can only run when threshold == 0, and it requires _threshold > 0 (GS202) before assigning threshold = _threshold. Therefore, any successful setup call occurs only when the existing threshold is 0 and results in threshold > 0. Relevant: Safe.setup calls setupOwners; OwnerManager.setupOwners enforces GS200/GS202 and sets threshold.","N/A","33.1738166809082","20000","ANSWER: TRUE\nEXPLANATION: Safe.setup delegates owner/threshold initialization to OwnerManager.setupOwners. That function reverts if threshold > 0 (GS200), ensuring setup can only run when threshold == 0, and it requires _threshold > 0 (GS202) before assigning threshold = _threshold. Therefore, any successful setup call occurs only when the existing threshold is 0 and results in threshold > 0. Relevant: Safe.setup calls setupOwners; OwnerManager.setupOwners enforces GS200/GS202 and sets threshold.\nCOUNTEREXAMPLE: N/A"
"1","handlerCallableIfSet","True","FALSE","The extensible handler is invoked only via the Safe’s fallback (FallbackManager.fallback), which forwards unknown function selectors to the fallback handler. If you set a handler for a selector that collides with an existing Safe function, the call will be dispatched to the Safe’s native function instead of the fallback, making the handler unreachable. For example, Safe implements getOwners() (OwnerManager.getOwners). The fallback in Extensible FallbackHandler routes by msg.sig only when invoked via the Safe’s fallback (handler/extensible/FallbackHandler.sol fallback); however, the Safe’s fallback is not triggered for existing functions.","- Setup: Safe S uses ExtensibleFallbackHandler as fallback handler.\n- Owner sets a method: call S (via execTransaction to self) to invoke ExtensibleFallbackHandler.setSafeMethod with selector = ISafe.getOwners.selector and newMethod = MarshalLib.encode(false, H), where H is an IFallbackMethod handler.\n- Attempt to call: A user calls S with calldata getOwners(). Since getOwners() exists on Safe (OwnerManager.getOwners), the call goes to that function directly; the Safe’s fallback is not invoked, so the handler H is never called and is effectively uncallable for that selector.","115.32083368301392","20000","ANSWER: FALSE\nEXPLANATION: The extensible handler is invoked only via the Safe’s fallback (FallbackManager.fallback), which forwards unknown function selectors to the fallback handler. If you set a handler for a selector that collides with an existing Safe function, the call will be dispatched to the Safe’s native function instead of the fallback, making the handler unreachable. For example, Safe implements getOwners() (OwnerManager.getOwners). The fallback in Extensible FallbackHandler routes by msg.sig only when invoked via the Safe’s fallback (handler/extensible/FallbackHandler.sol fallback); however, the Safe’s fallback is not triggered for existing functions.\nCOUNTEREXAMPLE:\n- Setup: Safe S uses ExtensibleFallbackHandler as fallback handler.\n- Owner sets a method: call S (via execTransaction to self) to invoke ExtensibleFallbackHandler.setSafeMethod with selector = ISafe.getOwners.selector and newMethod = MarshalLib.encode(false, H), where H is an IFallbackMethod handler.\n- Attempt to call: A user calls S with calldata getOwners(). Since getOwners() exists on Safe (OwnerManager.getOwners), the call goes to that function directly; the Safe’s fallback is not invoked, so the handler H is never called and is effectively uncallable for that selector."
"1","simulateAndRevertReverts","True","TRUE","In StorageAccessible.simulateAndRevert (contracts/common/StorageAccessible.sol), after the delegatecall, the function unconditionally executes revert with the encoded success flag and return data: assembly block ends with revert(ptr, add(returndatasize(), 0x40)). No return path exists, so it always reverts. Safe inherits StorageAccessible and does not override this function.","N/A","23.26379919052124","20000","ANSWER: TRUE\nEXPLANATION: In StorageAccessible.simulateAndRevert (contracts/common/StorageAccessible.sol), after the delegatecall, the function unconditionally executes revert with the encoded success flag and return data: assembly block ends with revert(ptr, add(returndatasize(), 0x40)). No return path exists, so it always reverts. Safe inherits StorageAccessible and does not override this function.\nCOUNTEREXAMPLE: N/A"
"1","REFINED_guardAddressChange","True","FALSE","The guard is stored in GUARD_STORAGE_SLOT and is set in GuardManager.setGuard (which requires a self-call via SelfAuthorized), see GuardManager.setGuard and SafeStorage.GUARD_STORAGE_SLOT. However, an enabled module can change the guard without calling setGuard by using execTransactionFromModule with Enum.Operation.DelegateCall, which executes arbitrary code in the Safe’s storage context (ModuleManager.execTransactionFromModule -> Executor.execute with DelegateCall). That code can sstore the GUARD_STORAGE_SLOT directly, bypassing setGuard and any owner call.","- Precondition: A module M is enabled on the Safe.\n- Attacker deploys a contract OverwriteGuard with function attack(address newGuard) { assembly { sstore(0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8, newGuard) } } (the constant is GUARD_STORAGE_SLOT).\n- M calls Safe.execTransactionFromModule(OverwriteGuard, 0, abi.encodeWithSelector(attack(newGuard)), Enum.Operation.DelegateCall).\n- Because ModuleManager.execTransactionFromModule uses delegatecall (Executor.execute), OverwriteGuard.attack runs in the Safe’s context and writes directly to GUARD_STORAGE_SLOT, changing the transaction guard without invoking setGuard and without an owner-performed call.","69.9512996673584","20000","ANSWER: FALSE\nEXPLANATION: The guard is stored in GUARD_STORAGE_SLOT and is set in GuardManager.setGuard (which requires a self-call via SelfAuthorized), see GuardManager.setGuard and SafeStorage.GUARD_STORAGE_SLOT. However, an enabled module can change the guard without calling setGuard by using execTransactionFromModule with Enum.Operation.DelegateCall, which executes arbitrary code in the Safe’s storage context (ModuleManager.execTransactionFromModule -> Executor.execute with DelegateCall). That code can sstore the GUARD_STORAGE_SLOT directly, bypassing setGuard and any owner call.\nCOUNTEREXAMPLE: \n- Precondition: A module M is enabled on the Safe.\n- Attacker deploys a contract OverwriteGuard with function attack(address newGuard) { assembly { sstore(0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8, newGuard) } } (the constant is GUARD_STORAGE_SLOT).\n- M calls Safe.execTransactionFromModule(OverwriteGuard, 0, abi.encodeWithSelector(attack(newGuard)), Enum.Operation.DelegateCall).\n- Because ModuleManager.execTransactionFromModule uses delegatecall (Executor.execute), OverwriteGuard.attack runs in the Safe’s context and writes directly to GUARD_STORAGE_SLOT, changing the transaction guard without invoking setGuard and without an owner-performed call."
"1","REFINED2_guardAddressChange","True","FALSE","The guard is stored at a fixed storage slot and can be written via delegatecall during setup. In Safe.setup, setupModules(to, data) is invoked, and ModuleManager.setupModules executes an arbitrary delegatecall to the provided address “to” (if nonzero). See ModuleManager.setupModules: it performs execute(..., Enum.Operation.DelegateCall, ...) without restrictions. A malicious initializer target can sstore directly to GUARD_STORAGE_SLOT, changing the guard without calling setGuard (which is self-authorized) and without requiring a call by an owner or an enabled module. Therefore the guard can be changed outside setGuard/owner/module paths.","1) Deploy a malicious contract M with function:\n   - setGuardDirect(address g) { assembly { sstore(0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8, g) } }\n2) Create a new Safe proxy and call Safe.setup with:\n   - _owners = [some owner], _threshold = 1,\n   - to = M,\n   - data = abi.encodeWithSelector(M.setGuardDirect.selector, attackerChosenGuard),\n   - fallbackHandler/payment params arbitrary.\n3) In Safe.setup, after setupOwners, setupModules(to, data) performs a delegatecall to M (ModuleManager.setupModules). M’s code directly writes the GUARD_STORAGE_SLOT, changing the guard without using setGuard and without requiring the caller to be an owner or a module.","120.64181399345398","20000","ANSWER: FALSE\nEXPLANATION: The guard is stored at a fixed storage slot and can be written via delegatecall during setup. In Safe.setup, setupModules(to, data) is invoked, and ModuleManager.setupModules executes an arbitrary delegatecall to the provided address “to” (if nonzero). See ModuleManager.setupModules: it performs execute(..., Enum.Operation.DelegateCall, ...) without restrictions. A malicious initializer target can sstore directly to GUARD_STORAGE_SLOT, changing the guard without calling setGuard (which is self-authorized) and without requiring a call by an owner or an enabled module. Therefore the guard can be changed outside setGuard/owner/module paths.\nCOUNTEREXAMPLE:\n1) Deploy a malicious contract M with function:\n   - setGuardDirect(address g) { assembly { sstore(0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8, g) } }\n2) Create a new Safe proxy and call Safe.setup with:\n   - _owners = [some owner], _threshold = 1,\n   - to = M,\n   - data = abi.encodeWithSelector(M.setGuardDirect.selector, attackerChosenGuard),\n   - fallbackHandler/payment params arbitrary.\n3) In Safe.setup, after setupOwners, setupModules(to, data) performs a delegatecall to M (ModuleManager.setupModules). M’s code directly writes the GUARD_STORAGE_SLOT, changing the guard without using setGuard and without requiring the caller to be an owner or a module."
"1","REFINED3_guardAddressChange","True","TRUE","The transaction guard is stored at GUARD_STORAGE_SLOT and is only written in GuardManager.setGuard (sstore(GUARD_STORAGE_SLOT, guard)). That function is protected by the authorized modifier (SelfAuthorized.requireSelfCall), which requires msg.sender == address(this). The Safe can only invoke such self-authorized functions via:\n- owner-approved execTransaction (which executes calls from the Safe itself; see Executor.execute), or\n- enabled modules via execTransactionFromModule (also executes from the Safe).\nThere are no other functions that write to GUARD_STORAGE_SLOT, and external calls (including the fallback handler) do not use delegatecall into the Safe. Therefore, after setup, the guard can only be changed through setGuard via calls initiated by owners or enabled modules.","N/A","94.6358642578125","20000","ANSWER: TRUE\nEXPLANATION: The transaction guard is stored at GUARD_STORAGE_SLOT and is only written in GuardManager.setGuard (sstore(GUARD_STORAGE_SLOT, guard)). That function is protected by the authorized modifier (SelfAuthorized.requireSelfCall), which requires msg.sender == address(this). The Safe can only invoke such self-authorized functions via:\n- owner-approved execTransaction (which executes calls from the Safe itself; see Executor.execute), or\n- enabled modules via execTransactionFromModule (also executes from the Safe).\nThere are no other functions that write to GUARD_STORAGE_SLOT, and external calls (including the fallback handler) do not use delegatecall into the Safe. Therefore, after setup, the guard can only be changed through setGuard via calls initiated by owners or enabled modules.\nCOUNTEREXAMPLE: N/A"
"1","MYonlyOwnersAddModule","True","FALSE","Enabling/disabling modules is gated by the authorized modifier (SelfAuthorized.requireSelfCall), meaning these functions (ModuleManager.enableModule and disableModule) must be called via a Safe transaction. Safe.execTransaction only checks that the number of signatures meets the current threshold, not that all owners signed (see Safe.checkSignatures and OwnerManager.setupOwners/threshold). Therefore, adding/removing a module requires only threshold confirmations, not unanimous approval.","- Initialize a Safe with three owners A, B, C and threshold = 2.\n- Submit a Safe transaction to itself: to = Safe address, data = abi.encodeWithSelector(IModuleManager.enableModule.selector, M), operation = Call.\n- Provide signatures from only A and B.\n- The transaction succeeds and M is enabled, even though C did not sign.\n- Similarly, disableModule(prevModule, M) can be executed with only two signatures.","32.76015043258667","20000","ANSWER: FALSE\nEXPLANATION: Enabling/disabling modules is gated by the authorized modifier (SelfAuthorized.requireSelfCall), meaning these functions (ModuleManager.enableModule and disableModule) must be called via a Safe transaction. Safe.execTransaction only checks that the number of signatures meets the current threshold, not that all owners signed (see Safe.checkSignatures and OwnerManager.setupOwners/threshold). Therefore, adding/removing a module requires only threshold confirmations, not unanimous approval.\nCOUNTEREXAMPLE: \n- Initialize a Safe with three owners A, B, C and threshold = 2.\n- Submit a Safe transaction to itself: to = Safe address, data = abi.encodeWithSelector(IModuleManager.enableModule.selector, M), operation = Call.\n- Provide signatures from only A and B.\n- The transaction succeeds and M is enabled, even though C did not sign.\n- Similarly, disableModule(prevModule, M) can be executed with only two signatures.\n\n"
"1","MYonlyOwnersAddModule2","True","FALSE","The functions that add/remove modules (enableModule and disableModule in ModuleManager) are protected only by the authorized modifier (SelfAuthorized.requireSelfCall), which requires the call to originate from the Safe itself (msg.sender == address(this)). An already enabled module can call execTransactionFromModule to make the Safe call itself (to = address(this), operation = Call), thereby passing the authorized check and enabling/disabling modules without collecting owner signatures. See:\n- ModuleManager.enableModule / disableModule (authorized)\n- SelfAuthorized.requireSelfCall (msg.sender == address(this))\n- ModuleManager.execTransactionFromModule → Executor.execute (allows calling the Safe itself)\nThus, adding/removing a module does not always require threshold owner confirmations.","1) Assume a Safe is set up with at least one module M enabled.\n2) M calls execTransactionFromModule(to = address(Safe), value = 0, data = abi.encodeWithSignature(""""""""enableModule(address)"""""""", NewModule), operation = Enum.Operation.Call).\n3) execTransactionFromModule executes a call to the Safe itself; inside enableModule, msg.sender == address(this), so authorized passes and NewModule is enabled without any owner signatures.\n4) Similarly, M can remove a module by calling execTransactionFromModule(to = address(Safe), data = abi.encodeWithSignature(""""""""disableModule(address,address)"""""""", prev, target), operation = Call) and pass the authorized check, removing the target module without threshold confirmations.","56.60661172866821","20000","ANSWER: FALSE\nEXPLANATION: The functions that add/remove modules (enableModule and disableModule in ModuleManager) are protected only by the authorized modifier (SelfAuthorized.requireSelfCall), which requires the call to originate from the Safe itself (msg.sender == address(this)). An already enabled module can call execTransactionFromModule to make the Safe call itself (to = address(this), operation = Call), thereby passing the authorized check and enabling/disabling modules without collecting owner signatures. See:\n- ModuleManager.enableModule / disableModule (authorized)\n- SelfAuthorized.requireSelfCall (msg.sender == address(this))\n- ModuleManager.execTransactionFromModule → Executor.execute (allows calling the Safe itself)\nThus, adding/removing a module does not always require threshold owner confirmations.\nCOUNTEREXAMPLE: \n1) Assume a Safe is set up with at least one module M enabled.\n2) M calls execTransactionFromModule(to = address(Safe), value = 0, data = abi.encodeWithSignature(""""""""enableModule(address)"""""""", NewModule), operation = Enum.Operation.Call).\n3) execTransactionFromModule executes a call to the Safe itself; inside enableModule, msg.sender == address(this), so authorized passes and NewModule is enabled without any owner signatures.\n4) Similarly, M can remove a module by calling execTransactionFromModule(to = address(Safe), data = abi.encodeWithSignature(""""""""disableModule(address,address)"""""""", prev, target), operation = Call) and pass the authorized check, removing the target module without threshold confirmations."
"1","MYboundedowners","True","FALSE","The contract imposes no fixed upper bound on the number of owners. OwnerManager.setupOwners accepts an arbitrary-length owners array at initialization, and OwnerManager.addOwnerWithThreshold can be called repeatedly (it only checks for nonzero, non-sentinel, and uniqueness), without any cap. Since these functions are “authorized” (SelfAuthorized) but can be invoked via Safe.execTransaction by targeting the Safe itself, owners can keep adding new owners indefinitely. Relevant functions: Safe.execTransaction (enables self-calls), OwnerManager.setupOwners, OwnerManager.addOwnerWithThreshold, and SelfAuthorized.authorized.","- Deploy a SafeProxy pointing to Safe, then call Safe.setup with one owner A and threshold 1.\n- Owner A submits execTransaction with to = the Safe’s own address and data = abi.encodeWithSelector(addOwnerWithThreshold.selector, B, 1). This passes the authorized modifier because the call to addOwnerWithThreshold is executed by the Safe itself.\n- Repeat the above execTransaction to add C, D, E, … as many distinct owners as desired. There is no contract-level maximum, so the owner count grows without bound (aside from practical gas limits).","34.63802742958069","20000","ANSWER: FALSE\nEXPLANATION: The contract imposes no fixed upper bound on the number of owners. OwnerManager.setupOwners accepts an arbitrary-length owners array at initialization, and OwnerManager.addOwnerWithThreshold can be called repeatedly (it only checks for nonzero, non-sentinel, and uniqueness), without any cap. Since these functions are “authorized” (SelfAuthorized) but can be invoked via Safe.execTransaction by targeting the Safe itself, owners can keep adding new owners indefinitely. Relevant functions: Safe.execTransaction (enables self-calls), OwnerManager.setupOwners, OwnerManager.addOwnerWithThreshold, and SelfAuthorized.authorized.\nCOUNTEREXAMPLE: \n- Deploy a SafeProxy pointing to Safe, then call Safe.setup with one owner A and threshold 1.\n- Owner A submits execTransaction with to = the Safe’s own address and data = abi.encodeWithSelector(addOwnerWithThreshold.selector, B, 1). This passes the authorized modifier because the call to addOwnerWithThreshold is executed by the Safe itself.\n- Repeat the above execTransaction to add C, D, E, … as many distinct owners as desired. There is no contract-level maximum, so the owner count grows without bound (aside from practical gas limits)."
"1","MYboundedthreshold","True","FALSE","In OwnerManager, threshold is only constrained to be between 1 and ownerCount (setupOwners, changeThreshold), but ownerCount itself has no fixed upper bound. addOwnerWithThreshold increments ownerCount and can set threshold to the new value via changeThreshold, with no cap beyond ownerCount. Since owners can be added arbitrarily (via authorized self-calls through execTransaction), threshold is not globally bounded. Relevant functions: setupOwners (sets threshold ≤ owners.length), addOwnerWithThreshold (increments ownerCount and then calls changeThreshold), changeThreshold (requires _threshold ≤ ownerCount).","- Initialize the Safe with setup([O1], _threshold=1, ...).\n- O1 executes a Safe transaction calling addOwnerWithThreshold(O2, 2). Now ownerCount=2, threshold=2.\n- Then call addOwnerWithThreshold(O3, 3). Now ownerCount=3, threshold=3.\n- Repeat arbitrarily many times adding new owners and setting _threshold to the new ownerCount. threshold can thus become arbitrarily large, so it is not bounded.","34.80250597000122","20000","ANSWER: FALSE\nEXPLANATION: In OwnerManager, threshold is only constrained to be between 1 and ownerCount (setupOwners, changeThreshold), but ownerCount itself has no fixed upper bound. addOwnerWithThreshold increments ownerCount and can set threshold to the new value via changeThreshold, with no cap beyond ownerCount. Since owners can be added arbitrarily (via authorized self-calls through execTransaction), threshold is not globally bounded. Relevant functions: setupOwners (sets threshold ≤ owners.length), addOwnerWithThreshold (increments ownerCount and then calls changeThreshold), changeThreshold (requires _threshold ≤ ownerCount).\nCOUNTEREXAMPLE: \n- Initialize the Safe with setup([O1], _threshold=1, ...).\n- O1 executes a Safe transaction calling addOwnerWithThreshold(O2, 2). Now ownerCount=2, threshold=2.\n- Then call addOwnerWithThreshold(O3, 3). Now ownerCount=3, threshold=3.\n- Repeat arbitrarily many times adding new owners and setting _threshold to the new ownerCount. threshold can thus become arbitrarily large, so it is not bounded."
"1","MYaddowner","True","FALSE","OwnerManager.addOwnerWithThreshold is protected only by the SelfAuthorized """"""""authorized"""""""" modifier, which requires the call to originate from the Safe itself (SelfAuthorized.requireSelfCall), not that signatures are collected. A previously enabled module can call execTransactionFromModule (ModuleManager.execTransactionFromModule), which in turn can execute a call to the Safe itself (to = address(this)), satisfying the authorized check and adding an owner without collecting current threshold signatures. Enabling a module itself requires owner authorization, but once enabled, the module can add owners without additional owner approvals.","- Start with a Safe configured with owner A and threshold = 1.\n- Step 1 (with threshold consent): A executes a transaction via Safe.execTransaction to call enableModule(M) on the Safe, enabling module M.\n- Step 2 (no new owner signatures): Module M calls Safe.execTransactionFromModule(to = address(Safe), data = abi.encodeWithSelector(OwnerManager.addOwnerWithThreshold.selector, B, 1), operation = Call). ModuleManager.execTransactionFromModule executes this call from the Safe, so msg.sender == address(this) inside addOwnerWithThreshold, passing the authorized check (SelfAuthorized.requireSelfCall). Owner B is added without collecting the current threshold signatures for this action.","61.29386329650879","20000","ANSWER: FALSE\nEXPLANATION: OwnerManager.addOwnerWithThreshold is protected only by the SelfAuthorized """"""""authorized"""""""" modifier, which requires the call to originate from the Safe itself (SelfAuthorized.requireSelfCall), not that signatures are collected. A previously enabled module can call execTransactionFromModule (ModuleManager.execTransactionFromModule), which in turn can execute a call to the Safe itself (to = address(this)), satisfying the authorized check and adding an owner without collecting current threshold signatures. Enabling a module itself requires owner authorization, but once enabled, the module can add owners without additional owner approvals.\nCOUNTEREXAMPLE: \n- Start with a Safe configured with owner A and threshold = 1.\n- Step 1 (with threshold consent): A executes a transaction via Safe.execTransaction to call enableModule(M) on the Safe, enabling module M.\n- Step 2 (no new owner signatures): Module M calls Safe.execTransactionFromModule(to = address(Safe), data = abi.encodeWithSelector(OwnerManager.addOwnerWithThreshold.selector, B, 1), operation = Call). ModuleManager.execTransactionFromModule executes this call from the Safe, so msg.sender == address(this) inside addOwnerWithThreshold, passing the authorized check (SelfAuthorized.requireSelfCall). Owner B is added without collecting the current threshold signatures for this action."
"1","MYnoUnboundedLoops","False","FALSE","The code contains multiple loops whose iteration counts depend on unbounded user input or state:\n- StorageAccessible.getStorageAt(uint256 offset, uint256 length) iterates “length” times with no cap (for loop over length).\n- OwnerManager.setupOwners(address[] _owners, ...) loops over the unbounded _owners array.\n- OwnerManager.getOwners() traverses the owner list, which can be arbitrarily long.\n- ModuleManager.getModulesPaginated(address start, uint256 pageSize) loops up to user-supplied pageSize.\n- Safe.checkNSignatures(...) loops requiredSignatures times (dependent on threshold/ownerCount).\n- libraries/MultiSend.multiSend(bytes transactions) iterates over the transactions byte array.","A user calls getStorageAt(0, 1_000_000) on any deployed Safe instance (via the StorageAccessible interface). The function contains a for-loop that executes “length” iterations with no upper bound imposed by the code, violating the property.","20.215051412582397","20000","ANSWER: FALSE\nEXPLANATION: The code contains multiple loops whose iteration counts depend on unbounded user input or state:\n- StorageAccessible.getStorageAt(uint256 offset, uint256 length) iterates “length” times with no cap (for loop over length).\n- OwnerManager.setupOwners(address[] _owners, ...) loops over the unbounded _owners array.\n- OwnerManager.getOwners() traverses the owner list, which can be arbitrarily long.\n- ModuleManager.getModulesPaginated(address start, uint256 pageSize) loops up to user-supplied pageSize.\n- Safe.checkNSignatures(...) loops requiredSignatures times (dependent on threshold/ownerCount).\n- libraries/MultiSend.multiSend(bytes transactions) iterates over the transactions byte array.\n\nCOUNTEREXAMPLE: A user calls getStorageAt(0, 1_000_000) on any deployed Safe instance (via the StorageAccessible interface). The function contains a for-loop that executes “length” iterations with no upper bound imposed by the code, violating the property."
"1","executeThresholdMet","True","FALSE","While Safe.execTransaction enforces the signature threshold via checkSignatures (which calls checkNSignatures with requiredSignatures = threshold), the ModuleManager path allows execution without any signatures. Specifically, ModuleManager.execTransactionFromModule and execTransactionFromModuleReturnData execute transactions as long as msg.sender is an enabled module (preModuleExecution checks modules[msg.sender] != address(0)), with no call to checkSignatures or threshold enforcement.","1) Initialize Safe via setup with owner Alice and threshold = 1.\n2) Enable a module M by executing enableModule(M) through Safe.execTransaction (signed by Alice).\n3) Call M so that it invokes Safe.execTransactionFromModule(to=Bob, value>0, data="""""""", operation=Call). In ModuleManager.execTransactionFromModule, no signatures are checked; it only verifies M is enabled and then calls execute().\nResult: The Safe transfers funds to Bob with zero signatures provided for that execution, violating the stated property.","70.76461338996887","20000","ANSWER: FALSE\nEXPLANATION: While Safe.execTransaction enforces the signature threshold via checkSignatures (which calls checkNSignatures with requiredSignatures = threshold), the ModuleManager path allows execution without any signatures. Specifically, ModuleManager.execTransactionFromModule and execTransactionFromModuleReturnData execute transactions as long as msg.sender is an enabled module (preModuleExecution checks modules[msg.sender] != address(0)), with no call to checkSignatures or threshold enforcement.\nCOUNTEREXAMPLE:\n1) Initialize Safe via setup with owner Alice and threshold = 1.\n2) Enable a module M by executing enableModule(M) through Safe.execTransaction (signed by Alice).\n3) Call M so that it invokes Safe.execTransactionFromModule(to=Bob, value>0, data="""""""", operation=Call). In ModuleManager.execTransactionFromModule, no signatures are checked; it only verifies M is enabled and then calls execute().\nResult: The Safe transfers funds to Bob with zero signatures provided for that execution, violating the stated property."
"1","handlerCalledIfSet","True","FALSE","The Safe routes unknown function calls exclusively to its currently configured fallback handler (FallbackManager.fallback loads FALLBACK_HANDLER_STORAGE_SLOT and calls that address). The per-selector handler mapping set via setSafeMethod is stored in the ExtensibleFallbackHandler and is only consulted by ExtensibleFallbackHandler’s own fallback. If the Safe’s fallback handler is not ExtensibleFallbackHandler, then calls with the registered selector will never reach the mapping/handler you set. See:\n- FallbackManager.fallback: forwards to the address in FALLBACK_HANDLER_STORAGE_SLOT.\n- handler/extensible/FallbackHandler.sol: fallback dispatches to the handler using safeMethods.\n- setSafeMethod only updates ExtensibleFallbackHandler’s mapping; it does not set the Safe’s fallback handler.","1) Deploy a Safe and set its fallback handler to CompatibilityFallbackHandler (or leave it unset).\n2) From the Safe, execute a call to ExtensibleFallbackHandler.setSafeMethod(selector, MarshalLib.encode(false, targetHandler)), appending the Safe’s address as the last 20 bytes so onlySelf passes.\n3) Now call the Safe with calldata starting with selector. The Safe forwards to CompatibilityFallbackHandler (or no handler if unset), not to ExtensibleFallbackHandler. The registered targetHandler is not invoked, violating the property.","155.0861074924469","20000","ANSWER: FALSE\nEXPLANATION: The Safe routes unknown function calls exclusively to its currently configured fallback handler (FallbackManager.fallback loads FALLBACK_HANDLER_STORAGE_SLOT and calls that address). The per-selector handler mapping set via setSafeMethod is stored in the ExtensibleFallbackHandler and is only consulted by ExtensibleFallbackHandler’s own fallback. If the Safe’s fallback handler is not ExtensibleFallbackHandler, then calls with the registered selector will never reach the mapping/handler you set. See:\n- FallbackManager.fallback: forwards to the address in FALLBACK_HANDLER_STORAGE_SLOT.\n- handler/extensible/FallbackHandler.sol: fallback dispatches to the handler using safeMethods.\n- setSafeMethod only updates ExtensibleFallbackHandler’s mapping; it does not set the Safe’s fallback handler.\nCOUNTEREXAMPLE: \n1) Deploy a Safe and set its fallback handler to CompatibilityFallbackHandler (or leave it unset).\n2) From the Safe, execute a call to ExtensibleFallbackHandler.setSafeMethod(selector, MarshalLib.encode(false, targetHandler)), appending the Safe’s address as the last 20 bytes so onlySelf passes.\n3) Now call the Safe with calldata starting with selector. The Safe forwards to CompatibilityFallbackHandler (or no handler if unset), not to ExtensibleFallbackHandler. The registered targetHandler is not invoked, violating the property."
"1","moduleGuardCalled","True","FALSE","In ModuleManager.preModuleExecution and postModuleExecution, the guard is only invoked if getModuleGuard() returns a nonzero address. If no module guard is set (default), neither IModuleGuard.checkModuleTransaction nor IModuleGuard.checkAfterModuleExecution is called. See:\n- preModuleExecution: if (guard != address(0)) { IModuleGuard(guard).checkModuleTransaction(...) }\n- postModuleExecution: if (guard != address(0)) { IModuleGuard(guard).checkAfterModuleExecution(...) }\nThus, there exist execTransactionFromModule calls where the guard is not called pre or post.","- State: No module guard set (getModuleGuard() returns address(0)). An enabled module M exists.\n- Action: M calls execTransactionFromModule(to, value, data, operation).\n- Outcome: preModuleExecution sees guard == 0 and makes no guard call; postModuleExecution also sees guard == 0 and makes no guard call. The guard is not called either pre- or post-execution, violating the property.","48.81401443481445","20000","ANSWER: FALSE\nEXPLANATION: In ModuleManager.preModuleExecution and postModuleExecution, the guard is only invoked if getModuleGuard() returns a nonzero address. If no module guard is set (default), neither IModuleGuard.checkModuleTransaction nor IModuleGuard.checkAfterModuleExecution is called. See:\n- preModuleExecution: if (guard != address(0)) { IModuleGuard(guard).checkModuleTransaction(...) }\n- postModuleExecution: if (guard != address(0)) { IModuleGuard(guard).checkAfterModuleExecution(...) }\nThus, there exist execTransactionFromModule calls where the guard is not called pre or post.\nCOUNTEREXAMPLE: \n- State: No module guard set (getModuleGuard() returns address(0)). An enabled module M exists.\n- Action: M calls execTransactionFromModule(to, value, data, operation).\n- Outcome: preModuleExecution sees guard == 0 and makes no guard call; postModuleExecution also sees guard == 0 and makes no guard call. The guard is not called either pre- or post-execution, violating the property."
"1","moduleGuardCalledReturn","True","TRUE","In ModuleManager.execTransactionFromModuleReturnData, the module guard is invoked before and after the module execution if a guard is set. Specifically, preModuleExecution calls IModuleGuard.checkModuleTransaction when getModuleGuard() != address(0), and postModuleExecution later calls IModuleGuard.checkAfterModuleExecution with the guardHash and success result (ModuleManager.preModuleExecution and postModuleExecution). Thus, for any execTransactionFromModuleReturnData call with a configured module guard, both pre- and post-execution guard hooks are invoked.","N/A","78.43804597854614","20000","ANSWER: TRUE\nEXPLANATION: In ModuleManager.execTransactionFromModuleReturnData, the module guard is invoked before and after the module execution if a guard is set. Specifically, preModuleExecution calls IModuleGuard.checkModuleTransaction when getModuleGuard() != address(0), and postModuleExecution later calls IModuleGuard.checkAfterModuleExecution with the guardHash and success result (ModuleManager.preModuleExecution and postModuleExecution). Thus, for any execTransactionFromModuleReturnData call with a configured module guard, both pre- and post-execution guard hooks are invoked.\nCOUNTEREXAMPLE: N/A"
"1","setGetCorrespondenceGuard","True","TRUE","The transaction guard is set and retrieved consistently in GuardManager. setGuard writes the guard address to a dedicated storage slot (GUARD_STORAGE_SLOT) after interface verification and is restricted by the authorized modifier (SelfAuthorized) to be callable only via the Safe itself (GuardManager.setGuard). getGuard reads from the same storage slot via sload and is used by Safe.execTransaction to invoke the guard’s checks. Since both functions use the same dedicated slot and there are no other writes to that slot, set and get work as expected.","N/A","37.0705943107605","20000","ANSWER: TRUE\nEXPLANATION: The transaction guard is set and retrieved consistently in GuardManager. setGuard writes the guard address to a dedicated storage slot (GUARD_STORAGE_SLOT) after interface verification and is restricted by the authorized modifier (SelfAuthorized) to be callable only via the Safe itself (GuardManager.setGuard). getGuard reads from the same storage slot via sload and is used by Safe.execTransaction to invoke the guard’s checks. Since both functions use the same dedicated slot and there are no other writes to that slot, set and get work as expected.\nCOUNTEREXAMPLE: N/A"
"1","setGetCorrespondenceModuleGuard","True","TRUE","The transaction guard is set and retrieved consistently via the same dedicated storage slot. GuardManager.setGuard stores the guard address in GUARD_STORAGE_SLOT after verifying the interface (setGuard, authorized, writes with sstore) and emits ChangedGuard. Safe.execTransaction later retrieves it via GuardManager.getGuard (sload on the same GUARD_STORAGE_SLOT) and uses it for checkTransaction/checkAfterExecution. This ensures that after setting a guard (or clearing it by setting address(0)), the subsequent retrieval matches the set value.","N/A","29.68755865097046","20000","ANSWER: TRUE\nEXPLANATION: The transaction guard is set and retrieved consistently via the same dedicated storage slot. GuardManager.setGuard stores the guard address in GUARD_STORAGE_SLOT after verifying the interface (setGuard, authorized, writes with sstore) and emits ChangedGuard. Safe.execTransaction later retrieves it via GuardManager.getGuard (sload on the same GUARD_STORAGE_SLOT) and uses it for checkTransaction/checkAfterExecution. This ensures that after setting a guard (or clearing it by setting address(0)), the subsequent retrieval matches the set value.\nCOUNTEREXAMPLE: N/A"
"1","setSafeMethodChanges","True","FALSE","The function setSafeMethod (contracts/handler/extensible/FallbackHandler.sol) only writes to the per-safe mapping safeMethods via _setSafeMethod (contracts/handler/extensible/ExtensibleBase.sol). It does not change the Safe’s fallback handler address. Moreover, _setSafeMethod explicitly normalizes a zero handler to bytes32(0) and then stores it, which can leave the mapping unchanged if it was already zero.","- Setup: A Safe S with fallback handler H = ExtensibleFallbackHandler is configured (FALLBACK_HANDLER_STORAGE_SLOT points to H). For some selector sel, H.safeMethods[S][sel] == 0 initially.\n- Action: The owners execute a Safe transaction that calls S itself with calldata encoding IFallbackHandler.setSafeMethod(sel, bytes32(0)). This routes through FallbackManager to H.setSafeMethod and passes onlySelf.\n- Result: In _setSafeMethod, newMethod decodes to handler = address(0), so newMethod is set to bytes32(0) and written back. The mapping remains 0 (no change), and the Safe’s fallback handler address stays H. Therefore, setSafeMethod did not change the handler.","64.40808629989624","20000","ANSWER: FALSE\nEXPLANATION: The function setSafeMethod (contracts/handler/extensible/FallbackHandler.sol) only writes to the per-safe mapping safeMethods via _setSafeMethod (contracts/handler/extensible/ExtensibleBase.sol). It does not change the Safe’s fallback handler address. Moreover, _setSafeMethod explicitly normalizes a zero handler to bytes32(0) and then stores it, which can leave the mapping unchanged if it was already zero.\nCOUNTEREXAMPLE: \n- Setup: A Safe S with fallback handler H = ExtensibleFallbackHandler is configured (FALLBACK_HANDLER_STORAGE_SLOT points to H). For some selector sel, H.safeMethods[S][sel] == 0 initially.\n- Action: The owners execute a Safe transaction that calls S itself with calldata encoding IFallbackHandler.setSafeMethod(sel, bytes32(0)). This routes through FallbackManager to H.setSafeMethod and passes onlySelf.\n- Result: In _setSafeMethod, newMethod decodes to handler = address(0), so newMethod is set to bytes32(0) and written back. The mapping remains 0 (no change), and the Safe’s fallback handler address stays H. Therefore, setSafeMethod did not change the handler."
"1","setSafeMethodRemoves","True","FALSE","In handler/extensible/FallbackHandler.sol, setSafeMethod(selector, newMethod) forwards to ExtensibleBase._setSafeMethod, which sets safeMethods[safe][selector] = newMethod (handler/extensible/ExtensibleBase.sol). It only clears the entry if the decoded handler address in newMethod is zero. Therefore, calling setSafeMethod does not inherently remove the handler unless newMethod encodes a zero handler.","- Setup a Safe S with ExtensibleFallbackHandler as its fallback handler.\n- Choose a selector sel = 0x12345678 and a nonzero handler address H.\n- Compute newMethod = MarshalLib.encode(true, H) off-chain.\n- Have S.execTransaction call itself (to = address(S), operation = Call) with data = abi.encodeWithSelector(IFallbackHandler.setSafeMethod.selector, sel, newMethod), providing valid owner signatures so onlySelf passes.\n- After execution, safeMethods[S][sel] is set to newMethod (nonzero), i.e., the handler is not removed.","69.72415113449097","20000","ANSWER: FALSE\nEXPLANATION: In handler/extensible/FallbackHandler.sol, setSafeMethod(selector, newMethod) forwards to ExtensibleBase._setSafeMethod, which sets safeMethods[safe][selector] = newMethod (handler/extensible/ExtensibleBase.sol). It only clears the entry if the decoded handler address in newMethod is zero. Therefore, calling setSafeMethod does not inherently remove the handler unless newMethod encodes a zero handler.\nCOUNTEREXAMPLE: - Setup a Safe S with ExtensibleFallbackHandler as its fallback handler.\n- Choose a selector sel = 0x12345678 and a nonzero handler address H.\n- Compute newMethod = MarshalLib.encode(true, H) off-chain.\n- Have S.execTransaction call itself (to = address(S), operation = Call) with data = abi.encodeWithSelector(IFallbackHandler.setSafeMethod.selector, sel, newMethod), providing valid owner signatures so onlySelf passes.\n- After execution, safeMethods[S][sel] is set to newMethod (nonzero), i.e., the handler is not removed."
"1","setSafeMethodSets","True","TRUE","In ExtensibleFallbackHandler’s inheritance chain, FallbackHandler.setSafeMethod calls _setSafeMethod (onlySelf), which writes the handler encoding into the per-safe selector mapping. Specifically, FallbackHandler.setSafeMethod sets safeMethods[safe][selector] via ExtensibleBase._setSafeMethod, decoding the new handler (MarshalLib.decode) and storing newMethod (or zero if handler is address(0)), and emits ChangedSafeMethod. See handler/extensible/FallbackHandler.sol (setSafeMethod) and handler/extensible/ExtensibleBase.sol (_setSafeMethod).","N/A","23.761797666549683","20000","ANSWER: TRUE\nEXPLANATION: In ExtensibleFallbackHandler’s inheritance chain, FallbackHandler.setSafeMethod calls _setSafeMethod (onlySelf), which writes the handler encoding into the per-safe selector mapping. Specifically, FallbackHandler.setSafeMethod sets safeMethods[safe][selector] via ExtensibleBase._setSafeMethod, decoding the new handler (MarshalLib.decode) and storing newMethod (or zero if handler is address(0)), and emits ChangedSafeMethod. See handler/extensible/FallbackHandler.sol (setSafeMethod) and handler/extensible/ExtensibleBase.sol (_setSafeMethod).\nCOUNTEREXAMPLE: N/A"
"1","txnGuardCalledFIX","True","TRUE","In Safe.execTransaction, the guard is read once and, if non-zero, checkTransaction is invoked before execution (guard != 0 check) and checkAfterExecution is invoked after execution using the same guard reference:\n- Pre-call: ITransactionGuard(guard).checkTransaction(...) before the gas check and execution.\n- Post-call: ITransactionGuard(guard).checkAfterExecution(txHash, success) after execution and events.\nAny path skipping the post-call reverts (e.g., GS010 gas check or the special revert on !success && safeTxGas==0 && gasPrice==0), so for non-reverting execTransaction both pre and post are called. See Safe.execTransaction: pre-call block with getGuard()/checkTransaction and final block with checkAfterExecution.","N/A","103.93187284469604","20000","ANSWER: TRUE\nEXPLANATION: In Safe.execTransaction, the guard is read once and, if non-zero, checkTransaction is invoked before execution (guard != 0 check) and checkAfterExecution is invoked after execution using the same guard reference:\n- Pre-call: ITransactionGuard(guard).checkTransaction(...) before the gas check and execution.\n- Post-call: ITransactionGuard(guard).checkAfterExecution(txHash, success) after execution and events.\nAny path skipping the post-call reverts (e.g., GS010 gas check or the special revert on !success && safeTxGas==0 && gasPrice==0), so for non-reverting execTransaction both pre and post are called. See Safe.execTransaction: pre-call block with getGuard()/checkTransaction and final block with checkAfterExecution.\nCOUNTEREXAMPLE: N/A"
"1","moduleGuardCalledFIX","True","TRUE","In ModuleManager.execTransactionFromModule, preModuleExecution is called first, which fetches the guard via getModuleGuard() and, if non-zero, invokes IModuleGuard(guard).checkModuleTransaction(...). After execution, postModuleExecution is called unconditionally, and if the captured guard is non-zero, it calls IModuleGuard(guard).checkAfterModuleExecution(...). Since there are no early returns and any revert in guard calls would make the whole tx revert, any non-reverting call ensures both pre- and post- guard hooks are executed.","N/A","60.60458445549011","20000","ANSWER: TRUE\nEXPLANATION: In ModuleManager.execTransactionFromModule, preModuleExecution is called first, which fetches the guard via getModuleGuard() and, if non-zero, invokes IModuleGuard(guard).checkModuleTransaction(...). After execution, postModuleExecution is called unconditionally, and if the captured guard is non-zero, it calls IModuleGuard(guard).checkAfterModuleExecution(...). Since there are no early returns and any revert in guard calls would make the whole tx revert, any non-reverting call ensures both pre- and post- guard hooks are executed.\nCOUNTEREXAMPLE: N/A"
"1","approvedHashesSetFIX","True","TRUE","In Safe.sol, approveHash requires the caller to be an owner; if the call does not revert, it unconditionally sets approvedHashes[msg.sender][hashToApprove] = 1 and emits ApproveHash. There are no subsequent external calls that could revert after the write.","N/A","24.103612661361694","20000","ANSWER: TRUE\nEXPLANATION: In Safe.sol, approveHash requires the caller to be an owner; if the call does not revert, it unconditionally sets approvedHashes[msg.sender][hashToApprove] = 1 and emits ApproveHash. There are no subsequent external calls that could revert after the write.\nCOUNTEREXAMPLE: N/A"
"1","setFallbackIntegrityFIX","True","TRUE","In FallbackManager.setFallbackHandler, after passing the authorized modifier (SelfAuthorized.requireSelfCall) and the internal guard (handler != address(this)), internalSetFallbackHandler stores the handler in the dedicated storage slot FALLBACK_HANDLER_STORAGE_SLOT via sstore, and then emits ChangedFallbackHandler. Therefore, assuming the call does not revert, the fallback handler is set to the provided address (see FallbackManager.setFallbackHandler and internalSetFallbackHandler).","N/A","34.6402428150177","20000","ANSWER: TRUE\nEXPLANATION: In FallbackManager.setFallbackHandler, after passing the authorized modifier (SelfAuthorized.requireSelfCall) and the internal guard (handler != address(this)), internalSetFallbackHandler stores the handler in the dedicated storage slot FALLBACK_HANDLER_STORAGE_SLOT via sstore, and then emits ChangedFallbackHandler. Therefore, assuming the call does not revert, the fallback handler is set to the provided address (see FallbackManager.setFallbackHandler and internalSetFallbackHandler).\nCOUNTEREXAMPLE: N/A"
"1","executePermissionsFIX","True","FALSE","The internal function execute (base/Executor.sol) is also invoked by SimulateTxAccessor.simulate (accessors/SimulateTxAccessor.sol), which can be reached externally through Safe’s simulateAndRevert (common/StorageAccessible.sol), via a delegatecall to an arbitrary target. This path is not among execTransaction, execTransactionFromModule, execTransactionFromModuleReturnData, or setup.","- Deploy a Safe proxy instance S.\n- Deploy SimulateTxAccessor at address A.\n- Call S.simulateAndRevert(A, abi.encodeWithSelector(SimulateTxAccessor.simulate.selector, to, value, data, Enum.Operation.Call)).\nThis delegatecalls A.simulate into S’s context, and SimulateTxAccessor.simulate internally calls execute(...), violating the stated restriction.","70.53445410728455","20000","ANSWER: FALSE\nEXPLANATION: The internal function execute (base/Executor.sol) is also invoked by SimulateTxAccessor.simulate (accessors/SimulateTxAccessor.sol), which can be reached externally through Safe’s simulateAndRevert (common/StorageAccessible.sol), via a delegatecall to an arbitrary target. This path is not among execTransaction, execTransactionFromModule, execTransactionFromModuleReturnData, or setup.\nCOUNTEREXAMPLE: \n- Deploy a Safe proxy instance S.\n- Deploy SimulateTxAccessor at address A.\n- Call S.simulateAndRevert(A, abi.encodeWithSelector(SimulateTxAccessor.simulate.selector, to, value, data, Enum.Operation.Call)).\nThis delegatecalls A.simulate into S’s context, and SimulateTxAccessor.simulate internally calls execute(...), violating the stated restriction."
"1","executePermissionsFIX_nodelegatecalls","True","TRUE","The internal function execute (base/Executor.sol) is invoked only in:\n- Safe.execTransaction (contracts/Safe.sol) \n- ModuleManager.execTransactionFromModule and execTransactionFromModuleReturnData (contracts/base/ModuleManager.sol)\n- ModuleManager.setupModules (contracts/base/ModuleManager.sol), but that invocation is always with Enum.Operation.DelegateCall. Under the given assumption that delegate calls are never invoked, this path is excluded.\nThe only other occurrence is SimulateTxAccessor.simulate (contracts/accessors/SimulateTxAccessor.sol), which can only run via delegatecall (enforced by onlyDelegateCall), thus excluded under the assumption. Therefore, execute can only be called via execTransaction, execTransactionFromModule, execTransactionFromModuleReturnData, or during setup.","N/A","87.53533816337585","20000","ANSWER: TRUE\nEXPLANATION: The internal function execute (base/Executor.sol) is invoked only in:\n- Safe.execTransaction (contracts/Safe.sol) \n- ModuleManager.execTransactionFromModule and execTransactionFromModuleReturnData (contracts/base/ModuleManager.sol)\n- ModuleManager.setupModules (contracts/base/ModuleManager.sol), but that invocation is always with Enum.Operation.DelegateCall. Under the given assumption that delegate calls are never invoked, this path is excluded.\nThe only other occurrence is SimulateTxAccessor.simulate (contracts/accessors/SimulateTxAccessor.sol), which can only run via delegatecall (enforced by onlyDelegateCall), thus excluded under the assumption. Therefore, execute can only be called via execTransaction, execTransactionFromModule, execTransactionFromModuleReturnData, or during setup.\nCOUNTEREXAMPLE: N/A"
"1","setSafeMethodChangesFIX","True","FALSE","In FallbackHandler.setSafeMethod, the function delegates to ExtensibleBase._setSafeMethod, which does not always store the passed newMethod verbatim. Specifically, it decodes newMethod and if the decoded handler address is zero, it forces newMethod to bytes32(0) before storing it (see ExtensibleBase._setSafeMethod: it decodes via MarshalLib.decode and then sets newMethod = 0 when handler == address(0)). Thus the stored value may differ from the input newMethod.","- Setup a Safe with ExtensibleFallbackHandler as its fallback handler (e.g., via Safe.setup).\n- From the Safe, execute a transaction to itself that triggers the fallback path to call the handler’s setSafeMethod with:\n  - selector = 0x11223344,\n  - newMethod = MarshalLib.encode(false, address(0)) (non-zero bytes32 due to the top-bit flag, but zero handler).\n- The call succeeds (onlySelf passes because the Safe calls itself via fallback), but _setSafeMethod replaces newMethod with bytes32(0) and stores that, not the provided value. Hence, setSafeMethod does not set the handler to the provided newMethod.","93.98649334907532","20000","ANSWER: FALSE\nEXPLANATION: In FallbackHandler.setSafeMethod, the function delegates to ExtensibleBase._setSafeMethod, which does not always store the passed newMethod verbatim. Specifically, it decodes newMethod and if the decoded handler address is zero, it forces newMethod to bytes32(0) before storing it (see ExtensibleBase._setSafeMethod: it decodes via MarshalLib.decode and then sets newMethod = 0 when handler == address(0)). Thus the stored value may differ from the input newMethod.\nCOUNTEREXAMPLE: \n- Setup a Safe with ExtensibleFallbackHandler as its fallback handler (e.g., via Safe.setup).\n- From the Safe, execute a transaction to itself that triggers the fallback path to call the handler’s setSafeMethod with:\n  - selector = 0x11223344,\n  - newMethod = MarshalLib.encode(false, address(0)) (non-zero bytes32 due to the top-bit flag, but zero handler).\n- The call succeeds (onlySelf passes because the Safe calls itself via fallback), but _setSafeMethod replaces newMethod with bytes32(0) and stores that, not the provided value. Hence, setSafeMethod does not set the handler to the provided newMethod."
"1","setSafeMethodRemovesFIX","True","TRUE","In FallbackHandler.setSafeMethod, the call forwards to ExtensibleBase._setSafeMethod. There, newMethod is decoded to get the handler address, and if the decoded handler is address(0), newMethod is set to bytes32(0) before writing to the mapping, effectively removing the handler (ExtensibleBase._setSafeMethod lines: decode newMethod; if newHandler == address(0) set newMethod = 0; then safeMethod[selector] = newMethod).","N/A","49.74540948867798","20000","ANSWER: TRUE\nEXPLANATION: In FallbackHandler.setSafeMethod, the call forwards to ExtensibleBase._setSafeMethod. There, newMethod is decoded to get the handler address, and if the decoded handler is address(0), newMethod is set to bytes32(0) before writing to the mapping, effectively removing the handler (ExtensibleBase._setSafeMethod lines: decode newMethod; if newHandler == address(0) set newMethod = 0; then safeMethod[selector] = newMethod).\nCOUNTEREXAMPLE: N/A"
"1","transactionHashCantCollide_assumeNoKekkakCollision","True","TRUE","In Safe.getTransactionHash, the EIP-712 hash is computed over all transaction fields: to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, and nonce, then domain-separated with chainid and the Safe’s address (domainSeparator). See Safe.getTransactionHash and Safe.domainSeparator. Under the assumed collision resistance of keccak256, two distinct inputs (i.e., any differing field, Safe instance, or chain) cannot yield the same hash.","N/A","62.57795858383179","20000","ANSWER: TRUE\nEXPLANATION: In Safe.getTransactionHash, the EIP-712 hash is computed over all transaction fields: to, value, keccak256(data), operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, and nonce, then domain-separated with chainid and the Safe’s address (domainSeparator). See Safe.getTransactionHash and Safe.domainSeparator. Under the assumed collision resistance of keccak256, two distinct inputs (i.e., any differing field, Safe instance, or chain) cannot yield the same hash.\nCOUNTEREXAMPLE: N/A"
"1","guardAddressChange_nodelegatecalls","True","TRUE","The transaction guard is stored at GUARD_STORAGE_SLOT (libraries/SafeStorage.sol). The only function that writes to this slot is GuardManager.setGuard, which performs sstore(GUARD_STORAGE_SLOT, guard) (base/GuardManager.sol). All other references either read the slot (getGuard) or touch different slots (e.g., MODULE_GUARD_STORAGE_SLOT, FALLBACK_HANDLER_STORAGE_SLOT). Fallback calls go to external handlers via CALL, not DELEGATECALL, so they cannot modify the Safe’s storage. StorageAccessible.simulateAndRevert uses delegatecall but reverts, so no state persists. Under the assumption that delegate calls are never invoked, no other path can modify the guard.","N/A","57.789921045303345","20000","ANSWER: TRUE\nEXPLANATION: The transaction guard is stored at GUARD_STORAGE_SLOT (libraries/SafeStorage.sol). The only function that writes to this slot is GuardManager.setGuard, which performs sstore(GUARD_STORAGE_SLOT, guard) (base/GuardManager.sol). All other references either read the slot (getGuard) or touch different slots (e.g., MODULE_GUARD_STORAGE_SLOT, FALLBACK_HANDLER_STORAGE_SLOT). Fallback calls go to external handlers via CALL, not DELEGATECALL, so they cannot modify the Safe’s storage. StorageAccessible.simulateAndRevert uses delegatecall but reverts, so no state persists. Under the assumption that delegate calls are never invoked, no other path can modify the guard.\nCOUNTEREXAMPLE: N/A"
"1","approvedHashesUpdate_nodelegatecalls","True","TRUE","The only place that updates approvedHashes is approveHash(bytes32) in Safe.sol, which sets approvedHashes[msg.sender][hashToApprove] = 1 after requiring msg.sender to be an owner (GS030). No other function writes to this mapping; checkNSignatures only reads it. Given the assumption that delegatecalls are never invoked, there is no path for another caller to write to approvedHashes[user][hash] unless msg.sender == user.","N/A","108.65740203857422","20000","ANSWER: TRUE\nEXPLANATION: The only place that updates approvedHashes is approveHash(bytes32) in Safe.sol, which sets approvedHashes[msg.sender][hashToApprove] = 1 after requiring msg.sender to be an owner (GS030). No other function writes to this mapping; checkNSignatures only reads it. Given the assumption that delegatecalls are never invoked, there is no path for another caller to write to approvedHashes[user][hash] unless msg.sender == user.\nCOUNTEREXAMPLE: N/A"
"1","fallbackHandlerNeverSelf_nodelegatecalls","True","TRUE","The only place that writes to the fallback handler storage slot (FALLBACK_HANDLER_STORAGE_SLOT) is FallbackManager.internalSetFallbackHandler, which explicitly reverts if handler == address(this) (“GS400”) before writing the slot (see internalSetFallbackHandler). Both Safe.setup and FallbackManager.setFallbackHandler route through this function (Safe.setup calls internalSetFallbackHandler; setFallbackHandler calls internalSetFallbackHandler under the authorized modifier). No other code writes to that slot. Under the given assumption that delegate calls are never invoked, there is no alternate path to set the slot to the Safe’s own address.","N/A","40.044623136520386","20000","ANSWER: TRUE\nEXPLANATION: The only place that writes to the fallback handler storage slot (FALLBACK_HANDLER_STORAGE_SLOT) is FallbackManager.internalSetFallbackHandler, which explicitly reverts if handler == address(this) (“GS400”) before writing the slot (see internalSetFallbackHandler). Both Safe.setup and FallbackManager.setFallbackHandler route through this function (Safe.setup calls internalSetFallbackHandler; setFallbackHandler calls internalSetFallbackHandler under the authorized modifier). No other code writes to that slot. Under the given assumption that delegate calls are never invoked, there is no alternate path to set the slot to the Safe’s own address.\nCOUNTEREXAMPLE: N/A"
"1","moduleGuardAddressChange_nodelegatecalls","True","TRUE","The module guard is stored at MODULE_GUARD_STORAGE_SLOT (contracts/libraries/SafeStorage.sol). The only function that writes to this slot is ModuleManager.setModuleGuard, which performs sstore(MODULE_GUARD_STORAGE_SLOT, moduleGuard) (contracts/base/ModuleManager.sol). All other references use sload (getModuleGuard) or operate on different storage slots (e.g., GUARD_STORAGE_SLOT, FALLBACK_HANDLER_STORAGE_SLOT). Under the assumption that delegatecalls are never invoked, no other function can modify this storage slot.","N/A","32.30955934524536","20000","ANSWER: TRUE\nEXPLANATION: The module guard is stored at MODULE_GUARD_STORAGE_SLOT (contracts/libraries/SafeStorage.sol). The only function that writes to this slot is ModuleManager.setModuleGuard, which performs sstore(MODULE_GUARD_STORAGE_SLOT, moduleGuard) (contracts/base/ModuleManager.sol). All other references use sload (getModuleGuard) or operate on different storage slots (e.g., GUARD_STORAGE_SLOT, FALLBACK_HANDLER_STORAGE_SLOT). Under the assumption that delegatecalls are never invoked, no other function can modify this storage slot.\nCOUNTEREXAMPLE: N/A"
"1","executeThresholdMet_nodelegatecalls","True","FALSE","While Safe.execTransaction enforces the threshold via checkSignatures (see Safe.execTransaction -> checkSignatures -> checkNSignatures), ModuleManager.execTransactionFromModule executes transactions without any signature or threshold checks (see ModuleManager.execTransactionFromModule and preModuleExecution). Therefore, transactions can be executed by enabled modules with zero signatures, violating the property for “any executing transaction.”","- Initialize a Safe with owners O1 and O2 and threshold = 2 via setup.\n- Deploy a module M whose function calls safe.execTransactionFromModule(to=Attacker, value=1 ether, data="""""""", operation=Enum.Operation.Call).\n- Enable M on the Safe by calling enableModule(M) through a properly signed Safe.execTransaction (requiring 2 signatures this one time).\n- Now anyone can trigger M to call execTransactionFromModule, which succeeds without providing any signatures, transferring funds despite the threshold being 2.","59.718759536743164","20000","ANSWER: FALSE\nEXPLANATION: While Safe.execTransaction enforces the threshold via checkSignatures (see Safe.execTransaction -> checkSignatures -> checkNSignatures), ModuleManager.execTransactionFromModule executes transactions without any signature or threshold checks (see ModuleManager.execTransactionFromModule and preModuleExecution). Therefore, transactions can be executed by enabled modules with zero signatures, violating the property for “any executing transaction.”\nCOUNTEREXAMPLE: \n- Initialize a Safe with owners O1 and O2 and threshold = 2 via setup.\n- Deploy a module M whose function calls safe.execTransactionFromModule(to=Attacker, value=1 ether, data="""""""", operation=Enum.Operation.Call).\n- Enable M on the Safe by calling enableModule(M) through a properly signed Safe.execTransaction (requiring 2 signatures this one time).\n- Now anyone can trigger M to call execTransactionFromModule, which succeeds without providing any signatures, transferring funds despite the threshold being 2."
"1","executeThresholdMet_nodelegatecalls_noexecFromMod","True","TRUE","execTransaction enforces the signature threshold before any execution. It computes the tx hash and calls checkSignatures(msg.sender, txHash, signatures) which loads the current threshold and then calls checkNSignatures(..., requiredSignatures=threshold). checkNSignatures requires signatures.length >= threshold*65 and validates exactly threshold owner approvals (via EOA signatures, contract signatures, or on-chain approvals for v==1), ensuring uniqueness and owner membership, reverting otherwise (see Safe.execTransaction and Safe.checkNSignatures). Other execution paths either are explicitly excluded (ModuleManager.execTransactionFromModule) or are delegatecall-based (assumed not invoked).","N/A","67.8362922668457","20000","ANSWER: TRUE\nEXPLANATION: execTransaction enforces the signature threshold before any execution. It computes the tx hash and calls checkSignatures(msg.sender, txHash, signatures) which loads the current threshold and then calls checkNSignatures(..., requiredSignatures=threshold). checkNSignatures requires signatures.length >= threshold*65 and validates exactly threshold owner approvals (via EOA signatures, contract signatures, or on-chain approvals for v==1), ensuring uniqueness and owner membership, reverting otherwise (see Safe.execTransaction and Safe.checkNSignatures). Other execution paths either are explicitly excluded (ModuleManager.execTransactionFromModule) or are delegatecall-based (assumed not invoked).\nCOUNTEREXAMPLE: N/A"
"1","executeThresholdMet_noexecFromMod","True","FALSE","Safe.execTransaction enforces the signature threshold via checkSignatures and checkNSignatures. However, ModuleManager also exposes execTransactionFromModuleReturnData, which executes arbitrary calls from enabled modules without any signature checks. The property excludes only ModuleManager.execTransactionFromModule by name, but execTransactionFromModuleReturnData is a different entrypoint that performs execution with zero signatures.","- Deploy and setup a Safe with two owners [A, B] and threshold = 2.\n- Fund the Safe with 1 ether.\n- Using a properly signed transaction (meeting threshold), enable a module M via enableModule(M).\n- Now, module M calls safe.execTransactionFromModuleReturnData(recipient, 1 ether, """""""", Enum.Operation.Call).\n- The call succeeds (ModuleManager.execTransactionFromModuleReturnData checks only that msg.sender is an enabled module and performs execute; it does not validate any signatures).\n- This is an “executing transaction” different from ModuleManager.execTransactionFromModule, yet it proceeds with zero signatures, violating the stated property.","55.50802493095398","20000","ANSWER: FALSE\nEXPLANATION: Safe.execTransaction enforces the signature threshold via checkSignatures and checkNSignatures. However, ModuleManager also exposes execTransactionFromModuleReturnData, which executes arbitrary calls from enabled modules without any signature checks. The property excludes only ModuleManager.execTransactionFromModule by name, but execTransactionFromModuleReturnData is a different entrypoint that performs execution with zero signatures.\nCOUNTEREXAMPLE: \n- Deploy and setup a Safe with two owners [A, B] and threshold = 2.\n- Fund the Safe with 1 ether.\n- Using a properly signed transaction (meeting threshold), enable a module M via enableModule(M).\n- Now, module M calls safe.execTransactionFromModuleReturnData(recipient, 1 ether, """""""", Enum.Operation.Call).\n- The call succeeds (ModuleManager.execTransactionFromModuleReturnData checks only that msg.sender is an enabled module and performs execute; it does not validate any signatures).\n- This is an “executing transaction” different from ModuleManager.execTransactionFromModule, yet it proceeds with zero signatures, violating the stated property.\n"
"1","handlerCallableIfSet_assump2","True","FALSE","The ExtensibleFallbackHandler only dispatches to a configured handler via its fallback() (handler/extensible/FallbackHandler.sol). If the selector matches any function implemented by the handler itself (or its parents), the call will be handled by that function instead of the fallback, so the configured method is never reached. The property assumes no collision with Safe’s functions, but collisions with the handler’s own functions (e.g., isValidSignature in handler/extensible/SignatureVerifierMuxer.sol) still block dispatching through the fallback mapping.","1) Set Safe’s fallback handler to ExtensibleFallbackHandler.\n2) Via Safe.execTransaction, call into Safe (so onlySelf passes) to invoke ExtensibleFallbackHandler.setSafeMethod(0x1626ba7e, MarshalLib.encode(false, H)), where 0x1626ba7e is the EIP-1271 isValidSignature selector and H is an arbitrary handler.\n3) A user calls Safe with selector 0x1626ba7e and arguments. The call is forwarded to the handler, but since ExtensibleFallbackHandler implements isValidSignature (handler/extensible/SignatureVerifierMuxer.sol), the handler’s function is invoked directly, not its fallback (handler/extensible/FallbackHandler.sol). The configured handler H is never called, violating the property.","142.44863390922546","20000","ANSWER: FALSE\nEXPLANATION: The ExtensibleFallbackHandler only dispatches to a configured handler via its fallback() (handler/extensible/FallbackHandler.sol). If the selector matches any function implemented by the handler itself (or its parents), the call will be handled by that function instead of the fallback, so the configured method is never reached. The property assumes no collision with Safe’s functions, but collisions with the handler’s own functions (e.g., isValidSignature in handler/extensible/SignatureVerifierMuxer.sol) still block dispatching through the fallback mapping.\nCOUNTEREXAMPLE: \n1) Set Safe’s fallback handler to ExtensibleFallbackHandler.\n2) Via Safe.execTransaction, call into Safe (so onlySelf passes) to invoke ExtensibleFallbackHandler.setSafeMethod(0x1626ba7e, MarshalLib.encode(false, H)), where 0x1626ba7e is the EIP-1271 isValidSignature selector and H is an arbitrary handler.\n3) A user calls Safe with selector 0x1626ba7e and arguments. The call is forwarded to the handler, but since ExtensibleFallbackHandler implements isValidSignature (handler/extensible/SignatureVerifierMuxer.sol), the handler’s function is invoked directly, not its fallback (handler/extensible/FallbackHandler.sol). The configured handler H is never called, violating the property."
"1","handlerCalledIfSet_assump2","True","FALSE","The Safe forwards unknown function calls to its fallback handler (FallbackManager.fallback), and the extensible handler routes them to the configured per-method handler only via its own fallback (Extensible FallbackHandler.fallback). However, if the chosen selector collides with a function implemented on the handler contract itself (e.g., ERC165Handler.supportsInterface), Solidity dispatch will invoke that function directly and the handler’s fallback (and thus the safeMethods mapping set via setSafeMethod) is never consulted. This violates the property even though the selector does not collide with any Safe function.","- Setup: Safe uses ExtensibleFallbackHandler as fallback handler.\n- Configure: Using a Safe self-call (so onlySelf passes), call handler.setSafeMethod(bytes4(0x01ffc9a7), MarshalLib.encode(true, someHandler)) to set a per-method handler for selector 0x01ffc9a7 (the ERC165 supportsInterface selector).\n- Invoke: A user calls the Safe with calldata starting with 0x01ffc9a7.\n- Result: Safe’s fallback forwards the call to the handler (FallbackManager.fallback). On the handler, the selector 0x01ffc9a7 matches ERC165Handler.supportsInterface, so that function executes directly and FallbackHandler.fallback is not called; the configured per-method handler is never invoked.","166.5343153476715","20000","ANSWER: FALSE\nEXPLANATION: The Safe forwards unknown function calls to its fallback handler (FallbackManager.fallback), and the extensible handler routes them to the configured per-method handler only via its own fallback (Extensible FallbackHandler.fallback). However, if the chosen selector collides with a function implemented on the handler contract itself (e.g., ERC165Handler.supportsInterface), Solidity dispatch will invoke that function directly and the handler’s fallback (and thus the safeMethods mapping set via setSafeMethod) is never consulted. This violates the property even though the selector does not collide with any Safe function.\nCOUNTEREXAMPLE: \n- Setup: Safe uses ExtensibleFallbackHandler as fallback handler.\n- Configure: Using a Safe self-call (so onlySelf passes), call handler.setSafeMethod(bytes4(0x01ffc9a7), MarshalLib.encode(true, someHandler)) to set a per-method handler for selector 0x01ffc9a7 (the ERC165 supportsInterface selector).\n- Invoke: A user calls the Safe with calldata starting with 0x01ffc9a7.\n- Result: Safe’s fallback forwards the call to the handler (FallbackManager.fallback). On the handler, the selector 0x01ffc9a7 matches ERC165Handler.supportsInterface, so that function executes directly and FallbackHandler.fallback is not called; the configured per-method handler is never invoked."
"1","handlerCallableIfSet_assump","True","FALSE","In the extensible fallback system, setSafeMethod (handler/extensible/FallbackHandler.sol) does not validate that the configured “handler” address actually implements the expected handle function. The fallback (handler/extensible/FallbackHandler.sol, fallback()) later blindly calls IFallbackMethod(handler).handle(...) or IStaticFallbackMethod(handler).handle(...). Hence one can set a handler address that passes the onlySelf gate (ExtensibleBase.onlySelf using HandlerContext._msgSender and _manager), but that is not a valid handler, causing subsequent calls to revert, violating “once set, it is possible to call.”","- Let S be a Safe with its fallback handler set to ExtensibleFallbackHandler H.\n- Execute a Safe transaction (S.execTransaction) that calls H.setSafeMethod(sel, MarshalLib.encode(false, S)).\n  This succeeds because onlySelf requires _msgSender() == _manager(); here msg.sender is S and the last 20 bytes of calldata (low 160 bits of newMethod) are S, so the check passes. Mapping safeMethods[S][sel] is set to handler=S.\n- Now an external user calls S with function selector sel (no collision with existing functions).\n  FallbackManager forwards to H. In H.fallback(), _getContextAndHandler resolves handler=S and then tries to call IFallbackMethod(S).handle(...), but Safe does not implement handle, so the call reverts.\n- Thus, a handler set via setSafeMethod is not necessarily callable, disproving the property.","161.37456440925598","20000","ANSWER: FALSE\nEXPLANATION: In the extensible fallback system, setSafeMethod (handler/extensible/FallbackHandler.sol) does not validate that the configured “handler” address actually implements the expected handle function. The fallback (handler/extensible/FallbackHandler.sol, fallback()) later blindly calls IFallbackMethod(handler).handle(...) or IStaticFallbackMethod(handler).handle(...). Hence one can set a handler address that passes the onlySelf gate (ExtensibleBase.onlySelf using HandlerContext._msgSender and _manager), but that is not a valid handler, causing subsequent calls to revert, violating “once set, it is possible to call.”\nCOUNTEREXAMPLE: \n- Let S be a Safe with its fallback handler set to ExtensibleFallbackHandler H.\n- Execute a Safe transaction (S.execTransaction) that calls H.setSafeMethod(sel, MarshalLib.encode(false, S)).\n  This succeeds because onlySelf requires _msgSender() == _manager(); here msg.sender is S and the last 20 bytes of calldata (low 160 bits of newMethod) are S, so the check passes. Mapping safeMethods[S][sel] is set to handler=S.\n- Now an external user calls S with function selector sel (no collision with existing functions).\n  FallbackManager forwards to H. In H.fallback(), _getContextAndHandler resolves handler=S and then tries to call IFallbackMethod(S).handle(...), but Safe does not implement handle, so the call reverts.\n- Thus, a handler set via setSafeMethod is not necessarily callable, disproving the property."
"1","handlerCallableIfSet_assump_dummyhandler","True","TRUE","With ExtensibleFallbackHandler set as the Safe’s fallback handler, setSafeMethod (handler/extensible/FallbackHandler.sol) stores a method handler in safeMethods keyed by the Safe (ExtensibleBase._setSafeMethod). The onlySelf check (ExtensibleBase) is satisfied by calling setSafeMethod via the Safe’s own fallback (Safe’s FallbackManager.fallback appends the Safe as the caller), e.g., execTransaction to self with setSafeMethod calldata. Afterwards, any external call to the Safe using the chosen (non-colliding) selector hits Safe’s fallback (base/FallbackManager.fallback), which forwards the calldata (plus appended sender) to the handler. The handler’s fallback (handler/extensible/FallbackHandler.sol) looks up the selector in safeMethods and dispatches to the configured handler’s handle function, returning its bytes back to the caller. Thus the handler can be called and its return (“Hello world”) is propagated.","N/A","253.5114471912384","20000","ANSWER: TRUE\nEXPLANATION: With ExtensibleFallbackHandler set as the Safe’s fallback handler, setSafeMethod (handler/extensible/FallbackHandler.sol) stores a method handler in safeMethods keyed by the Safe (ExtensibleBase._setSafeMethod). The onlySelf check (ExtensibleBase) is satisfied by calling setSafeMethod via the Safe’s own fallback (Safe’s FallbackManager.fallback appends the Safe as the caller), e.g., execTransaction to self with setSafeMethod calldata. Afterwards, any external call to the Safe using the chosen (non-colliding) selector hits Safe’s fallback (base/FallbackManager.fallback), which forwards the calldata (plus appended sender) to the handler. The handler’s fallback (handler/extensible/FallbackHandler.sol) looks up the selector in safeMethods and dispatches to the configured handler’s handle function, returning its bytes back to the caller. Thus the handler can be called and its return (“Hello world”) is propagated.\nCOUNTEREXAMPLE: N/A"
"1","handlerCalledIfSet_assump_dummyhandler","True","FALSE","The configuration entry point setSafeMethod is guarded by onlySelf (handler/extensible/FallbackHandler.sol), which requires _msgSender() == _manager() (handler/extensible/ExtensibleBase.sol). Here, _msgSender() is taken as the last 20 bytes of calldata (handler/HandlerContext.sol), while _manager() is msg.sender. When a Safe calls through its fallback, the Safe appends the original external caller (EOA) to calldata (base/FallbackManager.sol), so _msgSender() becomes the EOA, not the Safe; thus onlySelf fails and setSafeMethod cannot be executed via the expected path. If setSafeMethod is called directly, onlySelf can be made to pass only by forcing the last 20 bytes of calldata (i.e., the lower 160 bits of newMethod) to equal the Safe’s address, which then causes the stored handler address to be the Safe itself (MarshalLib.decode uses the lower 160 bits), so the subsequent fallback dispatch does not invoke the intended dummy handler. Therefore, a handler set via setSafeMethod will not be reliably called under the expected conditions.","- Setup a Safe with ExtensibleFallbackHandler as its fallback handler.\n- Have the Safe execute a transaction to call ExtensibleFallbackHandler.setSafeMethod(sel, MarshalLib.encode(false, address(DummyHandler))).\n- The call reverts: onlySelf requires _msgSender() (the last 20 bytes of calldata = DummyHandler address) to equal _manager() (msg.sender = Safe), which is false.\n- Even if you instead choose newMethod so its last 20 bytes equal the Safe address to satisfy onlySelf, the handler stored becomes the Safe (MarshalLib.decode uses the lower 160 bits), so calling the method via the Safe’s fallback will not invoke DummyHandler and thus will not return “Hello world”.","161.05587124824524","20000","ANSWER: FALSE\nEXPLANATION: The configuration entry point setSafeMethod is guarded by onlySelf (handler/extensible/FallbackHandler.sol), which requires _msgSender() == _manager() (handler/extensible/ExtensibleBase.sol). Here, _msgSender() is taken as the last 20 bytes of calldata (handler/HandlerContext.sol), while _manager() is msg.sender. When a Safe calls through its fallback, the Safe appends the original external caller (EOA) to calldata (base/FallbackManager.sol), so _msgSender() becomes the EOA, not the Safe; thus onlySelf fails and setSafeMethod cannot be executed via the expected path. If setSafeMethod is called directly, onlySelf can be made to pass only by forcing the last 20 bytes of calldata (i.e., the lower 160 bits of newMethod) to equal the Safe’s address, which then causes the stored handler address to be the Safe itself (MarshalLib.decode uses the lower 160 bits), so the subsequent fallback dispatch does not invoke the intended dummy handler. Therefore, a handler set via setSafeMethod will not be reliably called under the expected conditions.\nCOUNTEREXAMPLE: \n- Setup a Safe with ExtensibleFallbackHandler as its fallback handler.\n- Have the Safe execute a transaction to call ExtensibleFallbackHandler.setSafeMethod(sel, MarshalLib.encode(false, address(DummyHandler))).\n- The call reverts: onlySelf requires _msgSender() (the last 20 bytes of calldata = DummyHandler address) to equal _manager() (msg.sender = Safe), which is false.\n- Even if you instead choose newMethod so its last 20 bytes equal the Safe address to satisfy onlySelf, the handler stored becomes the Safe (MarshalLib.decode uses the lower 160 bits), so calling the method via the Safe’s fallback will not invoke DummyHandler and thus will not return “Hello world”.\n"
