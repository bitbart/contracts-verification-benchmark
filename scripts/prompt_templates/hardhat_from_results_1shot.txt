You are an expert in Solidity smart contracts and formal verification. 

You will be given: 
1. A Solidity smart contract. 
2. A property on the contract, expressed in natural language, that is violated. 
3. An explanation of why the property is violated.
4. A counterexample written in natural language that consists in a trace that violates the property.

Your task: 
- Carefully analyze the contract and understand in depth why the given counterexample violates the property.
- Encode the counterexample to a JavaScript file (using HardHat 2.14.0, Mocha, and Chai) to produce a Proof of Concept that shows a concrete trace that violates the property. You will be provided with an example of proof of concept (for a different contract) at the end of the prompt. 

Think step by step internally about how to translate the counterexample into an Hardhat Proof of Concept. Make sure that the code you produce works correctly. Do not include your reasoning in the output. 

Your answer must consist of ONLY the code of the Hardhat Proof of Concept.
---
Smart Contract:
{code}
Property:
{property_desc}
Explanation:
{explanation}
Counterexample:
{counterexample}
---
Example of proof of concept:
Contract: 
```
pragma solidity ^0.8.25;

contract Reentrancy {
	uint x;
	function s(uint _x) public {
		x = _x;
	}
	function f(address a) public {
		require(x == 0);
		(bool s, bytes memory data) = a.call("");
	}
	function getX() public view returns (uint) {
		return x;
	}
}
```
Counterexample:
```
- Deploy Reentrancy (x is initially 0).
- Deploy ReentrancyAttack with a fallback that executes Reentrancy.s(5).
- Call Reentrancy.f(reentrancyAttackAddress). The require passes. The external call invokes ReentrancyAttackâ€™s fallback which calls s(5), setting x = 5. After f returns, x == 5.
```
HardHat proof of concept:
```
const {
  loadFixture,
} = require("@nomicfoundation/hardhat-toolbox/network-helpers");
const { expect } = require("chai");

beforeEach(async function () {
  this.Reentrancy = await ethers.deployContract("Reentrancy");
  this.ReentrancyAttack = await ethers.deployContract("ReentrancyAttack");
});

describe("Reentrancy", function() {
  async function deployContract() {
    const [owner] = await ethers.getSigners();

    const Reentrancy = await ethers.deployContract("Reentrancy");
    const ReentrancyAttack = await ethers.deployContract("ReentrancyAttack");

    return { Reentrancy, ReentrancyAttack};
  }
  it("The value of x is not 0 after the call to `f`", async function(){
    const { Reentrancy, ReentrancyAttack } = await loadFixture(deployContract);
    let reentrancyAttackAddress = ReentrancyAttack.getAddress();
    await Reentrancy.f(reentrancyAttackAddress);
    expect(await Reentrancy.getX()).not.to.equal(0);
  })
})
```
