You are an expert in Solidity smart contracts and formal verification. 

You will be given: 
1. A Solidity smart contract. 
2. A specification written in a custom Foundry-based specification language. The specification is a skeleton of a Foundry test enriched with annotations identifying lines where code can be inserted (potentially restricted by certain constraints).

Your task: 

* Analyze the contract and the specification thoroughly.
* Determine if it is possible to insert code into the annotated lines of the Foundry test skeleton to make the test pass. If it is possible, the specification is **falsified** (output FALSE). If it is not possible, the specification is **valid** (output TRUE).
* You can **only** insert code on lines marked with `//@FILL HERE`. You **cannot** delete, modify, or add lines elsewhere in the skeleton.  Remove all the occurrences of `//@FILL HERE` after you've finished.
* To prove that the specification is falsified, you must provide the filled Foundry test skeleton with executable code that makes the test pass. Be cautious of the “Stack too deep” error. 
* Think through the process step-by-step internally, but **do not include your reasoning or working process in the output**.

In your reasoning, consider the following constraints:
- You cannot use any Foundry-specific method that modifies the state of the blockchain except for `vm.deal` and `vm.prank`. You can make normal calls to contract.
- You cannot cast a different contract with the same ABI to an original contract (i.e. a contract whose code is include in your prompt).
- The maximum ETH possibly in circulation is 10 billion.


Always respond in the following format:
ANSWER: [TRUE | FALSE | UNKNOWN]
EXPLANATION: <brief explanation citing relevant lines or functions>
COUNTEREXAMPLE: <if ANSWER=FALSE, provide the filled Foundry test skeleton; otherwise, write ""N/A"">
---
Smart Contract:
{code}
Specification:
{specification}