{
    "name": "InfiniFi",
    "properties": {
        "no_withdraw_before_end_of_unwinding_epoch": "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. Given an arbitrary user and unwinding timestamp, if LockingController.withdraw is called with these parameters without reverting, it must always be that the position_before.toEpoch is greater than zero and the timestamp of the withdraw call is after toEpoch",
        "integrity_of_toEpoch_in_startUnwinding" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. If startUnwinding is called with arbitrary parameters and with an arbitrary EVM environment, the initialized position in the UnwindingModule will always have position_after.toEpoch == fromEpoch + unwindingEpochs",
        "unwinding_epoch_cannot_decrease" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. Given an arbitrary user and unwindingEpochs , assuming we: 1. save the corresponding position from UnwindingModule, 2. call an arbitrary public method of LockingController, except for startUnwinding, withdraw, cancelUnwinding, and emergencyAction, and 3. check the same position after, then the toEpoch after the call will always be greater or equal to the toEpoch from before the call",
        "reward_weight_monotonic_increasing_with_iUSD" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. If there are two arbitrary users and an arbitrarily chosen unwindingEpoch with nonzero balance of shareToken and userA has a greater balance than userB, the rewardWeightForUnwindingEpochs for userA will be greater or equal the reward weight for userB. We assume that the sum of the shareToken balance of the two users compared for the rule is less than the totalSupply() of the shareToken",
        "reward_weight_monotonic_increasing_with_multiplier" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. Assuming an arbitrarily chosen user has a position in two arbitrarily chosen unwindingEpoch buckets where the buckets have the same shareToken contract and the same totalReceiptTokens amount. If the multiplier for unwindingEpochA is greater than the multiplier for unwindingEpochB, then rewardWeightForUnwindingEpochs(userA,unwindingEpochA) > rewardWeightForUnwindingEpochs(user, unwindingEpochB)",
        "reward_weight_monotonic_increasing_with_multiplier_ge" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. Assuming an arbitrarily chosen user has a position in two arbitrarily chosen unwindingEpoch buckets where the buckets have the same shareToken contract and the same totalReceiptTokens amount. If the multiplier for unwindingEpochA is greater than the multiplier for unwindingEpochB, then rewardWeightForUnwindingEpochs(userA,unwindingEpochA) >= rewardWeightForUnwindingEpochs(user, unwindingEpochB)",
        "apply_losses_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. applyLosses can only be called by FinanceManager",
        "cancel_unwinding_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. cancelUnwinding can only be called by EntryPoint",
        "create_position_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. createPosition can only be called by EntryPoint or the UnwindingModule",
        "deposit_rewards_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. deposit can only be called by FinanceManager",
        "enable_bucket_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. enableBucket can only be called by Governor",
        "increase_unwinding_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. increaseUnwinding can only be called by EntryPoint",
        "set_bucket_multiplier_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. setBucketMultiplier can only be called by Governor",
        "start_unwinding_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. startUnwinding can only be called by EntryPoint",
        "withdraw_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. startUnwinding can only be called by EntryPoint",
        "no_immediate_redemption_from_non_empty_queue" : "We restrict our scope to RedeemController.sol. If RedeemController.queueLength() > 0 (i.e. it’s nonempty), if `redeem` is called with arbitrary parameters without reverting, it is not possible for the balance of the `to` address to increase by the full asset amount as calculated by `receiptToAsset`. (In other words, the already enqueued redemptions will be prioritized ahead of new ones)",
        "mintingNonzeroAssetAlwaysResultsInNonzeroReceipt" : "We restrict our scope to MintController.sol. If `MintController.mint` is called with a nonzero `assetAmountOut` the returned receipt amount will also be greater than zero. We make the following assumptions: 1. The value of USDC and iUSD are within 10% of their reference value. 2. We use the fact that ReceiptToken has more decimals than USDC to prove this.",
        "mintingNonzeroAssetAlwaysResultsInNonzeroReceipt_CAREFULARITH" : "We restrict our scope to MintController.sol. If `MintController.mint` is called with a nonzero `assetAmountOut` the returned receipt amount will also be greater than zero. We make the following assumptions: 1. The value of USDC and iUSD are within 10% of their reference value. 2. We use the fact that ReceiptToken has more decimals than USDC to prove this. Be careful: whenever you have to perform arithmetical computations, you MUST use a scientific calculator.",
        "mintingNonzeroAssetAlwaysResultsInNonzeroReceipt_CAREFULARITH2" : "We restrict our scope to MintController.sol. If `MintController.mint` is called with a nonzero `assetAmountOut` the returned receipt amount will also be greater than zero. We make the following assumptions: 1. The value of USDC and iUSD are within 10% of their reference value. 2. We use the fact that ReceiptToken has more decimals than USDC to prove this. Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations.",
        "mintingNonzeroAssetAlwaysResultsInNonzeroReceipt_CAREFULARITH2_cex" : "We restrict our scope to MintController.sol. If `MintController.mint` is called with a nonzero `assetAmountOut` the returned receipt amount will also be greater than zero. We make the following assumptions: 1. The value of USDC and iUSD are within 10% of their reference value. 2. We use the fact that ReceiptToken has more decimals than USDC to prove this. Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations. If you find a counterexample, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "mintingNonzeroAssetAlwaysResultsInNonzeroReceipt_CAREFULARITH2_cex_assumptions" : "We restrict our scope to MintController.sol. If `MintController.mint` is called with a nonzero `assetAmountOut` the returned receipt amount will also be greater than zero. We make the following assumptions: 1. The value of USDC and iUSD are within 10% of their reference value. 2. We use the fact that ReceiptToken has more decimals than USDC to prove this. Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations. If you find a counterexample, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible. Further assumption: whenever price(addr) is invoked, we have that, if addr is iUSDC, then price(addr) >= 9*10^17 && price(addr) <= 11*10^17, and, if addr is USDC, then price(addr) >= 9*10^29 && price(addr) <= 11*10^29",
        "mintingNonzeroAssetAlwaysResultsInNonzeroReceipt__Accounting_price_bounded_uint256" : "We restrict our scope to MintController.sol. If `MintController.mint` is called with a nonzero `assetAmountOut` the returned receipt amount will also be greater than zero. We make the following assumptions: 1. The value of USDC and iUSD are within 10% of their reference value. 2. We use the fact that ReceiptToken has more decimals than USDC to prove this. Assume that, for every X, the values of Accounting.price(X) can only be uint256 (when Accounting.price(X) does not revert).",
        "mintingNonzeroAssetAlwaysResultsInNonzeroReceipt__Accounting_price_bounded_uint256_OracleUSDC_bounded" : "We restrict our scope to MintController.sol. If `MintController.mint` is called with a nonzero `assetAmountOut` the returned receipt amount will also be greater than zero. We make the following assumptions: 1. The value of USDC and iUSD are within 10% of their reference value. 2. We use the fact that ReceiptToken has more decimals than USDC to prove this. You MUST consider that: Accounting.price(assetToken) cannot take value greater than uint256, Accounting.price(receiptToken) cannot take value greater than uint256, and in Accounting the Oracle price for USDC cannot take values greater than uint256.",
        "apply_losses_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol. applyLosses can only be called by LockedTokenManager",
        "cancel_unwinding_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol. cancelUnwinding can only be called by LockedTokenManager",
        "deposit_rewards_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol. deposit can only be called by LockedTokenManager",
        "start_unwinding_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol. startUnwinding can only be called by LockedTokenManager",
        "withdraw_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol.withdraw can only be called by LockedTokenManager",
        "start_and_cancel_unwinding_is_nop_rwBias" : "We restrict our scope to UnwindingModule.sol. Given an arbitrary user and an arbitrary unwinding epoch, calling startUnwinding followed by cancelUnwinding should not affect the value of rewardWeightBiasIncreases for the epoch. Note that we assume cancelUnwinding is called a full epoch after startUnwinding",
        "no_rewards_for_same_epoch" : "Given an arbitrary `user` and arbitrary startUnwindingTimestamp, let position = getPosition(user,startUnwindingTimestamp) if balanceOf(user, startUnwindingTimestamp) exceeds UnwindingModule.sharesToAmount(position.share s) then the epoch for the block timestamp of the balanceOf call must exceed position.fromEpoch - 1 (i.e. it must be a full epoch greater than when unwinding began to have a balance increase)",
        "cannotCallExitingMethodWithUnappliedLosses" : "If any “exiting function” is called without reverting, it must always be that YieldSharing.unaccruedYield() was greater or equal to zero at the time the exit call was made. Here exiting functions include: * for InfiniFiGatewayV1: withdraw, redeem * for StakedToken: redeem, withdraw, maxRedeem, maxWithdraw.  We make the following asusmptions: 1. For verification performance reasons we model YIeldSharing.unaccruedYield and _.withdraw as having no side effects and returning an arbitrary value (though we cover all return values) NOTE: this applies to the internal _withdraw method and not the externally callable method which is otherwise covering the full solidity implementation 2. We assume StakedToken is not paused (otherwise maxRedeem/maxWithdraw can be called even if there is an accrued loss though it will be a NOP that always returns zero)",
        "cannotCallExitingMethodWithUnappliedLosses_no0" : "If any “exiting function” is called without reverting and without returing 0, it must always be that YieldSharing.unaccruedYield() was greater or equal to zero at the time the exit call was made. Here exiting functions include: * for InfiniFiGatewayV1: withdraw, redeem * for StakedToken: redeem, withdraw, maxRedeem, maxWithdraw.  We make the following asusmptions: 1. For verification performance reasons we model YIeldSharing.unaccruedYield and _.withdraw as having no side effects and returning an arbitrary value (though we cover all return values) NOTE: this applies to the internal _withdraw method and not the externally callable method which is otherwise covering the full solidity implementation 2. We assume StakedToken is not paused (otherwise maxRedeem/maxWithdraw can be called even if there is an accrued loss though it will be a NOP that always returns zero)",
        "totalAssetsIsSumOfFarmAssets" : "Accounting.totalAssets(USDC) returns the sum over the assets() returned by (held by) the individual farms (here MintController and AaveV3Farm)  We make the following assumptions: 1. For this property we use a farm configuration where the enabled farms are exactly MintController and AaveV3Farm 2. For verification performance reasons we model applyLosses and depositRewards as having no side effect and returning an arbitrary number (note that neither of these affect the truth of the property) ",
        "uw_total_voting_exceeds_sum_user_voting" : "UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token.",
        "uw_total_voting_exceeds_sum_user_voting_applyLosses":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is only possible to call the method applyLosses.",
        "uw_total_voting_exceeds_sum_user_voting_applyLosses_inUnwindingModule":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is only possible to call the method applyLosses in UnwindingModule.sol.",
        "uw_total_voting_exceeds_sum_user_voting_applyLosses_inUnwindingModule_HintRounding":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is only possible to call the method applyLosses in UnwindingModule.sol. Be careful about rounding.",
        "uw_total_voting_exceeds_sum_user_voting_applyLosses_inUnwindingModule_HintRounding_hintReasoning": "UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is only possible to call the method applyLosses in UnwindingModule.sol.  The following reasoning might help you determine whether the property holds or not. Be careful, you cannot assume that the reasoning is correct. If it is not correct, include in your answer why it is not. START_REASONING. A precision loss caused by rounding during normalization in UnwindingModule results in an invariant violation: after calling applyLosses(uint256), the value returned by totalRewardWeight() can become less than the sum of all user reward weights, which should not be possible. Both totalRewardWeight() and rewardWeight() apply normalization by multiplying by slashIndex and dividing by 1e18 using mulWadDown, which rounds down. When applyLosses() updates slashIndex (via a mulDivDown operation) and burns a portion of receipt tokens, the updated slashIndex causes the individually rounded user reward weights to sum to more than the rounded-down total reward weight — violating consistency. Specifically, in applyLosses(): slashIndex = slashIndex.mulDivDown(_totalReceiptTokens - _amount, _totalReceiptTokens); And in both view functions: return point.totalRewardWeight.mulWadDown(slashIndex); // totalRewardWeight() ... return userRewardWeight.mulWadDown(slashIndex); // rewardWeight() 17 Since rounding is applied independently in both functions, precision loss accumulates across users, resulting in the sum of user weights exceeding the total. END_REASONING.",
        "uw_total_voting_exceeds_sum_user_voting_noapplyLosses":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is not possible to call the method applyLosses.",
        "uw_total_voting_exceeds_sum_user_voting_noapplyLosses_noassumptions":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is not possible to call the method applyLosses.",
        "uw_total_voting_exceeds_sum_user_voting_method_applyLosses" : "",
        "strict_solvency_mint_4626" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_mint_4626_HintHooks" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. Pay attention to hooks. We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_mint_4626_HintHooks2" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. Be particularly careful about hooks. We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_mint_4626_hint_totalSupply0" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only ERC4626 and MintController are enabled as farms. Hint: consider the case in which ReceiptToken.totalSupply() is equal to 0. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_mint_4626_hint_CertState" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only ERC4626 and MintController are enabled as farms. Hint: consider a state in which: ReceiptToken.totalSupply() is equal to 0, Accounting.totalAssetsValue() is equal to 3000000000000, supplyPrice is equal to 1000000000000000000, and InfiniFiGatewayV1.mint is called with `amount` equal to 7. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_mint_4626_hint_CertState_askCEX" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only ERC4626 and MintController are enabled as farms. Hint: consider a state in which: ReceiptToken.totalSupply() is equal to 0, Accounting.totalAssetsValue() is equal to 3000000000000, supplyPrice is equal to 1000000000000000000, and InfiniFiGatewayV1.mint is called with `amount` equal to 7. If you find a counterexample, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible. Further assumptions you should consider: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_mint_4626_hint_CertState_noafterMint" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only ERC4626 and MintController are enabled as farms. Hint: consider a state in which: ReceiptToken.totalSupply() is equal to 0, Accounting.totalAssetsValue() is equal to 3000000000000, supplyPrice is equal to 1000000000000000000, and InfiniFiGatewayV1.mint is called with `amount` equal to 7. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. Other assumption: afterMint has no effect.",
        "strict_solvency_mint_aave" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only AaveV3Farm and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_mint_aave_HintHooks" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. Pay attention to hooks. We assume that only AaveV3Farm and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_redeem_4626" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary redeem with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_redeem_4626_CAREFULARITH_askCEX" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary redeem with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. Hint: consider a state in which: Accounting.totalAssetsValue is equal to 4000000000000, ReceiptToken.totalSupply is equal to 3999999999996, and the price of ReceiptToken is equal to 1000000000000000000. Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations.  If you find a counterexample, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible. We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_redeem_4626_CAREFULARITH_askCEXfull" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary redeem with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. Hint: consider a state in which: Accounting.totalAssetsValue is equal to 4000000000000, ReceiptToken.totalSupply is equal to 3999999999996, the price of ReceiptToken is equal to 1000000000000000000, assetsValueAfter=0x0, ecrecover=0x1, sha256=0x2, RedeemController=0x271d, ERC4626Farm=0x271e, EpochLib=0x271f, FarmRegistry=0x2720, MintController=0x2721, YieldSharing=0x2725, AllocationVoting=0x2726, Accounting=0x2727, InfiniFiGatewayV1=0x2728, InfiniFiCore=0x272a, ReceiptToken=0x272b, FixedPriceOracle=0x272c, totalSupplyAfter=0x2ba7def2ffc, totalSupplyBefore=0x3a352943ffc, assetsValueBefore=0x3a352944000, identity=0x4, amount=0xe8d4a51000. Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations.  If you find a counterexample, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible. We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "WRONGstrict_solvency_redeem_4626_CAREFULARITH_askCEXReport" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary redeem with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. Hint: consider the following scenario. Assume a solvent state: iUSD price: 0.9e18, Total iUSD supply 1.000003333333333333e18, USDC balance: 0.900003e18 (protocol is solvent). A user redeems 1 wei of iUSD. The conversion ratio computes as: receiptPrice.divWadUp(assetPrice) = 1e18 / 0.9e18 ≈ 1.111. As a result the protocol transfers _assetTokenPrice / _receiptTokenPrice = 0.9e18 / 10e30 = 0.900001e6, that is 900001 USDC, slightly more than the underlying asset value. The remaining iUSD supply cannot be redeemed without loss, and the protocol becomes insolvent by ~0.000001 USDC. The following assumptions are made to attempt prove strict solvency: The price of USDC is fixed to the reference, The price of iUSD is slashed from the reference by +/- 10%, The RedeemController is the only enabled farm for the redeem call, The MintController is similarly the only enabled farm for the mint call. Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations.  If you find a counterexample, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible. We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_redeem_4626_CAREFULARITH" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary redeem with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards.  Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations.  We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_redeem_aave" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary redeem with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only AaveV3Farm and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_redeem_aave_CAREFULARITH" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary redeem with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations. We assume that only AaveV3Farm and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "global_reward_weight_le_user_reward_weight_strong" : "Beginning from an arbitrary initial state where the Locking Controller globalRewardWeight exceeds (or is equal to) the reward weight of the user If we execute an arbitrary non-view function in LockingController or UnwindingModule, the resulting state is proven to also be one where the LockingController.globalRewardWeight exceeds (or is equal to) the user reward weight. Assumptions: 1. We assume the total supply is greater or equal the user balances for the LockedPositionToken 2. We underapproximate the number of enabled buckets – we assume there are exactly 2 enabled buckets, each with distinct instances of the LockedPositionToken, and that these do not change 3. We underapproximate the users – we assume there is just one address that has a nonzero balance of LockedPositionToken 4. We assume here LockingController.globalRewardWeight is greater or equal the total iUSD value locked in the enabled buckets. (We verify this holds separately with P-20)",
        "global_reward_weight_le_user_reward_weight_strong_HintRounding" : "Beginning from an arbitrary initial state where the Locking Controller globalRewardWeight exceeds (or is equal to) the reward weight of the user If we execute an arbitrary non-view function in LockingController or UnwindingModule, the resulting state is proven to also be one where the LockingController.globalRewardWeight exceeds (or is equal to) the user reward weight. Pay attention to rounding. Assumptions: 1. We assume the total supply is greater or equal the user balances for the LockedPositionToken 2. We underapproximate the number of enabled buckets – we assume there are exactly 2 enabled buckets, each with distinct instances of the LockedPositionToken, and that these do not change 3. We underapproximate the users – we assume there is just one address that has a nonzero balance of LockedPositionToken 4. We assume here LockingController.globalRewardWeight is greater or equal the total iUSD value locked in the enabled buckets. (We verify this holds separately with P-20)",
        "global_reward_weight_le_user_reward_weight_strong_createPosition" : "Beginning from an arbitrary initial state where the Locking Controller globalRewardWeight exceeds (or is equal to) the reward weight of the user If we execute createPosition in LockingController, the resulting state is proven to also be one where the LockingController.globalRewardWeight exceeds (or is equal to) the user reward weight. Assumptions: 1. We assume the total supply is greater or equal the user balances for the LockedPositionToken 2. We underapproximate the number of enabled buckets – we assume there are exactly 2 enabled buckets, each with distinct instances of the LockedPositionToken, and that these do not change 3. We underapproximate the users – we assume there is just one address that has a nonzero balance of LockedPositionToken 4. We assume here LockingController.globalRewardWeight is greater or equal the total iUSD value locked in the enabled buckets.",
        "global_reward_weight_le_user_reward_weight_strongGT" : "Beginning from an arbitrary initial state where the Locking Controller globalRewardWeight exceeds the reward weight of the user If we execute an arbitrary non-view function in LockingController or UnwindingModule, the resulting state is proven to also be one where the LockingController.globalRewardWeight exceeds the user reward weight. Assumptions: 1. We assume the total supply is greater or equal the user balances for the LockedPositionToken 2. We underapproximate the number of enabled buckets – we assume there are exactly 2 enabled buckets, each with distinct instances of the LockedPositionToken, and that these do not change 3. We underapproximate the users – we assume there is just one address that has a nonzero balance of LockedPositionToken 4. We assume here LockingController.globalRewardWeight is greater or equal the total iUSD value locked in the enabled buckets. (We verify this holds separately with P-20)",
        "global_reward_weight_le_total_locked_iUSD_with_rewards_after" : "We assume to start from an arbitrary initial state where the LockingController.globalRewardWeight exceeds (or is equal to) the sum over value locked in buckets. If we execute an arbitrary non-view method in LockingController or UnwindingModule, then the resulting state is one where the globalRewardWeight still exceeds (or is equal to) the sum over value locked in buckets. By value locked in a bucket we mean bucket.totalReceiptTokens * bucket.multiplier / 10^18. Assumptions: 1. We assume the total supply is greater or equal the user balances for the LockedPositionToken 2. We underapproximate the number of enabled buckets – we assume there are exactly 2 enabled buckets, each with distinct instances of the LockedPositionToken 3. We assume non-enabled buckets are zeroed out and the multipliers in enabled buckets are in the valid range of (10^18 - 2*10^18) 4. We assume the enabled buckets are distinct 5. We underapproximate the number of users. We assume there are exactly 2 distinct users with nonzero balances in either bucket.",
        "global_reward_weight_le_total_locked_iUSD_with_rewards_afterGT" : "We assume to start from an arbitrary initial state where the LockingController.globalRewardWeight exceeds the sum over value locked in buckets. If we execute an arbitrary non-view method in LockingController or UnwindingModule, then the resulting state is one where the globalRewardWeight still exceeds the sum over value locked in buckets. By value locked in a bucket we mean bucket.totalReceiptTokens * bucket.multiplier / 10^18. Assumptions: 1. We assume the total supply is greater or equal the user balances for the LockedPositionToken 2. We underapproximate the number of enabled buckets – we assume there are exactly 2 enabled buckets, each with distinct instances of the LockedPositionToken 3. We assume non-enabled buckets are zeroed out and the multipliers in enabled buckets are in the valid range of (10^18 - 2*10^18) 4. We assume the enabled buckets are distinct 5. We underapproximate the number of users. We assume there are exactly 2 distinct users with nonzero balances in either bucket.",
        "solvency_YieldSharing": "We restrict our scope to YieldSharing.sol. Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state then the total asset value will still exceed the total receipt token value afterwards  We make the following assumptions:  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 37 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 5. For this property and set of contracts the AaveV3Farm and MintController are the (only) enabled farms 6. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 7. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset,addFarms, removeFarms",
        "solvency_AllocationVoting": "We restrict our scope to AllocationVoting.sol. Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state then the total asset value will still exceed the total receipt token value afterwards  We make the following assumptions:  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 37 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 5. For this property and set of contracts the AaveV3Farm and MintController are the (only) enabled farms 6. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 7. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset,addFarms, removeFarms",
        "PREVIOUSVERSION_solvency_only_redeem_deg": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call redeem with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController and MintController are the (only) enabled farms for redeem and mint respectively 7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_only_redeem_deg": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call redeem with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed (or be equal to) the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController and MintController are the (only) enabled farms for redeem and mint respectively 7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_only_redeem_degGT": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call redeem with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController and MintController are the (only) enabled farms for redeem and mint respectively 7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "PREVIOUSVERSION_solvency_only_redeem_deg_CAREFULARITH": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call redeem with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed (or be equal to) the total receipt token value afterwards.  Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations.  We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController and MintController are the (only) enabled farms for redeem and mint respectively 7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "PREVIOUSVERSION_solvency_only_redeem_deg_CAREFULARITHGT": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call redeem with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed the total receipt token value afterwards.  Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations.  We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController and MintController are the (only) enabled farms for redeem and mint respectively 7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_only_redeem_deg_CAREFULARITH": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call redeem with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed the total receipt token value afterwards.  Be careful: whenever you have to perform arithmetical computations concerning numbers in scientific notations (e.g. 1e10, 6.3e14, etc), you must FIRST convert them to decimal notation (e.g. 10000000000, 630000000000000), and only THEN perform arithmetical computations.  We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController and MintController are the (only) enabled farms for redeem and mint respectively 7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_only_mint_deg": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call mint with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the MintController is the (only) enabled farm for  mint  7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_depeg_redeem_controller_only": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call any RedeemController public method aside from `redeem`, with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed (or be equal to) the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController is the (only) enabled farm  7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_depeg_redeem_controller_onlyFIX": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call any RedeemController public method aside from `redeem` and `withdraw`, with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed (or be equal to) the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController is the (only) enabled farm  7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_depeg_mint_controller_only": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call any MintController public method aside from `redeem`, with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed (or be equal to) the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the MintController is the (only) enabled farm  7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_depeg_mint_controller_onlyFIX": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call any MintController public method aside from `mint` and `withdraw`, with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed (or be equal to) the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the MintController is the (only) enabled farm  7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "MYbuckets_multiplier_bounded" : "Given A, buckets[A].multiplier is bounded.",
        "MYAccounting_price_bounded" : "For every X, Accounting.price(X)  is bounded.",
        "MYAccounting_price_bounded_uint256" : "For every X, the values of Accounting.price(X) can only be uint256 when Accounting.price(X) does not revert.",
        "MYAccounting_Oracle_price_USDC_bounded_uint256" : "In Accounting, the Oracle price for USDC cannot take values greater than uint256",
        "MY_reachability_ReceiptTokentotalSupply0_AND_AccountingtotalAssetsValueGT0": "It is possible to reach a state in which ReceiptToken.totalSupply()=0 and Accounting.totalAssetsValue()>0.",
        "MY_InfiniFiGatewayV1mint_increases_AccountingtotalAssetsValue": "After a non-reverting call to InfiniFiGatewayV1.mint(to, amount), with `amount` > 0, it can happen that Accounting.totalAssetsValue() does not increase.   ",
        "MY_InfiniFiGatewayV1mint_increases_AccountingtotalAssetsValue_assumpweak": "After a non-reverting call to InfiniFiGatewayV1.mint(to, amount), with `amount` > 0, it can happen that Accounting.totalAssetsValue() does not increase.  For this property we assume AaveV3Farm or ERC4626Farm and MintController are the only enabled farms. ",
        "MY_InfiniFiGatewayV1mint_increases_AccountingtotalAssetsValue_Assump": "After a non-reverting call to InfiniFiGatewayV1.mint(to, amount), with `amount` > 0, it can happen that Accounting.totalAssetsValue() does not increase.         Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. ",
        "MY_reachCertState_strict_solvency_mint_4626" : "It is possible to reach  a state in which: ReceiptToken.totalSupply() is equal to 0, Accounting.totalAssetsValue() is equal to 3000000000000, supplyPrice is equal to 1000000000000000000, and InfiniFiGatewayV1.mint is called with `amount` equal to 7. Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "MY_reachCertState_strict_solvency_mint_aave" : "It is possible to reach  a state in which: ReceiptToken.totalSupply() is equal to 1000000000001, Accounting.totalAssetsValue() is equal to 7000000000000, supplyPrice is equal to 1000000000000000000. Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "solvency_mint_single_hop_growth" : "Assume we use Accounting.totalAssetValue() to determine the total value of underlying asset, and we use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Then, beginning from an arbitrary state where the total asset value is strictly greater than the total receipt token value, If we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state, Then, afterwards the total asset value cannot be less than the total receipt token value by more than the tolerated slippage amount. The tolerated slippage is amount * price(USDC) * (1e18 - maxSlippage), and maxSlippage is the constant value 0.999999e18 (which is set as maxSlippage in the constructor of Farm.sol) and amount is the amount parameter of the function call. Here, we only consider possible changes made by a mint call for InfiniFiGatewayV1.  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification. We also assume the prices of the asset and receipt tokens are fixed at their reference values of 1e30 and 1e18 respectively 2. For the underlying asset (USDC), ReceiptToken, and the ERC4626 used for the ERC4626Farm (all of which are ERC20s), we assume that the totalSupply is greater or equal to the total balance of users 3. The msgSender when calling any of the functions covered here is not any of: Accounting, InfiniFiGatewayV1, the enabled farms, or the MintController 4. For this property and set of contracts the ERC4626Farm and MintController are the (only) enabled farms 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 6. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms.",
        "solvency_mintAndLock_single_hop_growth" : "Assume we use Accounting.totalAssetValue() to determine the total value of underlying asset, and we use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Then, beginning from an arbitrary state where the total asset value is strictly greater than the total receipt token value, If we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state, Then, afterwards the total asset value cannot be less than the total receipt token value by more than the tolerated slippage amount. The tolerated slippage is amount * price(USDC) * (1e18 - maxSlippage), and maxSlippage is the constant value 0.999999e18 (which is set as maxSlippage in the constructor of Farm.sol) and amount is the amount parameter of the function call. Here, we only consider possible changes made by a mintAndLock call for InfiniFiGatewayV1.  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification. We also assume the prices of the asset and receipt tokens are fixed at their reference values of 1e30 and 1e18 respectively 2. For the underlying asset (USDC), ReceiptToken, and the ERC4626 used for the ERC4626Farm (all of which are ERC20s), we assume that the totalSupply is greater or equal to the total balance of users 3. The msgSender when calling any of the functions covered here is not any of: Accounting, InfiniFiGatewayV1, the enabled farms, or the MintController 4. For this property and set of contracts the ERC4626Farm and MintController are the (only) enabled farms 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 6. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms.",
        "solvency_mintAndStake_single_hop_growth" : "Assume we use Accounting.totalAssetValue() to determine the total value of underlying asset, and we use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Then, beginning from an arbitrary state where the total asset value is strictly greater than the total receipt token value, If we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state, Then, afterwards the total asset value cannot be less than the total receipt token value by more than the tolerated slippage amount. The tolerated slippage is amount * price(USDC) * (1e18 - maxSlippage), and maxSlippage is the constant value 0.999999e18 (which is set as maxSlippage in the constructor of Farm.sol) and amount is the amount parameter of the function call. Here, we only consider possible changes made by a mintAndStake call for InfiniFiGatewayV1.  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification. We also assume the prices of the asset and receipt tokens are fixed at their reference values of 1e30 and 1e18 respectively 2. For the underlying asset (USDC), ReceiptToken, and the ERC4626 used for the ERC4626Farm (all of which are ERC20s), we assume that the totalSupply is greater or equal to the total balance of users 3. The msgSender when calling any of the functions covered here is not any of: Accounting, InfiniFiGatewayV1, the enabled farms, or the MintController 4. For this property and set of contracts the ERC4626Farm and MintController are the (only) enabled farms 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 6. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms.",
        "solvency_redeem_single_hop_growth" : "Assume we use Accounting.totalAssetValue() to determine the total value of underlying asset, and we use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Then, beginning from an arbitrary state where the total asset value is strictly greater than the total receipt token value, If we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state, Then, afterwards the total asset value cannot be less than the total receipt token value by more than the tolerated slippage amount. The tolerated slippage is amount * price(USDC) * (1e18 - maxSlippage), and maxSlippage is the constant value 0.999999e18 (which is set as maxSlippage in the constructor of Farm.sol) and amount is the amount parameter of the function call. Here, we only consider possible changes made by a redeem call for InfiniFiGatewayV1.  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification. We also assume the prices of the asset and receipt tokens are fixed at their reference values of 1e30 and 1e18 respectively 2. For the underlying asset (USDC), ReceiptToken, and the ERC4626 used for the ERC4626Farm (all of which are ERC20s), we assume that the totalSupply is greater or equal to the total balance of users 3. The msgSender when calling any of the functions covered here is not any of: Accounting, InfiniFiGatewayV1, the enabled farms, or the MintController 4. For this property and set of contracts the ERC4626Farm and MintController are the (only) enabled farms 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 6. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms.",
        "solvency_mint_single_hop_growthAaveV3" : "Assume we use Accounting.totalAssetValue() to determine the total value of underlying asset, and we use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Then, beginning from an arbitrary state where the total asset value is strictly greater than the total receipt token value, If we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state, Then, afterwards the total asset value cannot be less than the total receipt token value by more than the tolerated slippage amount. The tolerated slippage is amount * price(USDC) * (1e18 - maxSlippage), and maxSlippage is the constant value 0.999999e18 (which is set as maxSlippage in the constructor of Farm.sol) and amount is the amount parameter of the function call. Here, we only consider possible changes made by a mint call for InfiniFiGatewayV1.  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification. We also assume the prices of the asset and receipt tokens are fixed at their reference values of 1e30 and 1e18 respectively 2. For the underlying asset (USDC), ReceiptToken, and the ERC4626 used for the ERC4626Farm (all of which are ERC20s), we assume that the totalSupply is greater or equal to the total balance of users 3. The msgSender when calling any of the functions covered here is not any of: Accounting, InfiniFiGatewayV1, the enabled farms, or the MintController 4. For this property and set of contracts the AaveV3 and MintController are the (only) enabled farms 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 6. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms.",
        "solvency_mintAndLock_single_hop_growthAaveV3" : "Assume we use Accounting.totalAssetValue() to determine the total value of underlying asset, and we use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Then, beginning from an arbitrary state where the total asset value is strictly greater than the total receipt token value, If we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state, Then, afterwards the total asset value cannot be less than the total receipt token value by more than the tolerated slippage amount. The tolerated slippage is amount * price(USDC) * (1e18 - maxSlippage), and maxSlippage is the constant value 0.999999e18 (which is set as maxSlippage in the constructor of Farm.sol) and amount is the amount parameter of the function call. Here, we only consider possible changes made by a mintAndLock call for InfiniFiGatewayV1.  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification. We also assume the prices of the asset and receipt tokens are fixed at their reference values of 1e30 and 1e18 respectively 2. For the underlying asset (USDC), ReceiptToken, and the ERC4626 used for the ERC4626Farm (all of which are ERC20s), we assume that the totalSupply is greater or equal to the total balance of users 3. The msgSender when calling any of the functions covered here is not any of: Accounting, InfiniFiGatewayV1, the enabled farms, or the MintController 4. For this property and set of contracts the AaveV3 and MintController are the (only) enabled farms 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 6. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms.",
        "solvency_mintAndStake_single_hop_growthAaveV3" : "Assume we use Accounting.totalAssetValue() to determine the total value of underlying asset, and we use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Then, beginning from an arbitrary state where the total asset value is strictly greater than the total receipt token value, If we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state, Then, afterwards the total asset value cannot be less than the total receipt token value by more than the tolerated slippage amount. The tolerated slippage is amount * price(USDC) * (1e18 - maxSlippage), and maxSlippage is the constant value 0.999999e18 (which is set as maxSlippage in the constructor of Farm.sol) and amount is the amount parameter of the function call. Here, we only consider possible changes made by a mintAndStake call for InfiniFiGatewayV1.  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification. We also assume the prices of the asset and receipt tokens are fixed at their reference values of 1e30 and 1e18 respectively 2. For the underlying asset (USDC), ReceiptToken, and the ERC4626 used for the ERC4626Farm (all of which are ERC20s), we assume that the totalSupply is greater or equal to the total balance of users 3. The msgSender when calling any of the functions covered here is not any of: Accounting, InfiniFiGatewayV1, the enabled farms, or the MintController 4. For this property and set of contracts the AaveV3 and MintController are the (only) enabled farms 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 6. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms.",
        "solvency_redeem_single_hop_growthAaveV3" : "Assume we use Accounting.totalAssetValue() to determine the total value of underlying asset, and we use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Then, beginning from an arbitrary state where the total asset value is strictly greater than the total receipt token value, If we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state, Then, afterwards the total asset value cannot be less than the total receipt token value by more than the tolerated slippage amount. The tolerated slippage is amount * price(USDC) * (1e18 - maxSlippage), and maxSlippage is the constant value 0.999999e18 (which is set as maxSlippage in the constructor of Farm.sol) and amount is the amount parameter of the function call. Here, we only consider possible changes made by a redeem call for InfiniFiGatewayV1.  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification. We also assume the prices of the asset and receipt tokens are fixed at their reference values of 1e30 and 1e18 respectively 2. For the underlying asset (USDC), ReceiptToken, and the ERC4626 used for the ERC4626Farm (all of which are ERC20s), we assume that the totalSupply is greater or equal to the total balance of users 3. The msgSender when calling any of the functions covered here is not any of: Accounting, InfiniFiGatewayV1, the enabled farms, or the MintController 4. For this property and set of contracts the AaveV3 and MintController are the (only) enabled farms 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 6. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms.",
        "MYreachability_strict_solvency_redeem_4626FULL" : "Is it possible to reach a state in which: assetsValueAfter=0x0, ecrecover=0x1, sha256=0x2, RedeemController=0x271d, ERC4626Farm=0x271e, EpochLib=0x271f, FarmRegistry=0x2720, MintController=0x2721, Mock4626=0x2722, Utilities=0x2723, BeforeRedeemHook=0x2724, YieldSharing=0x2725, AllocationVoting=0x2726, Accounting=0x2727, InfiniFiGatewayV1=0x2728, DummyERC20A=0x2729, InfiniFiCore=0x272a, ReceiptToken=0x272b, FixedPriceOracle=0x272c, totalSupplyAfter=0x2ba7def2ffc, totalSupplyBefore=0x3a352943ffc, assetsValueBefore=0x3a352944000, identity=0x4, amount=0xe8d4a51000, to=DummyERC20A? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "MYreachability_strict_solvency_redeem_4626" : "Is it possible to reach a state in which: Accounting.totalAssetsValue is equal to 4000000000000, ReceiptToken.totalSupply is equal to 3999999999996, and the price of ReceiptToken is equal to 1000000000000000000? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "MYreachability_strict_solvency_redeem_aave" : "Is it possible to reach a state in which:  Accounting.totalAssetsValue is equal to 115792089237316195423570985008687907853269984665640564039457584007000000000000, ReceiptToken.totalSupply is equal to 115792089237316195423570985008687907853269984665640564039457584007000000000000, and the price of ReceiptToken is equal to 1000000000000000000? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "MYreachability_uw_total_voting_exceeds_sum_user_voting" : "Is it possible to reach a state in which: a user A has UnwindingModule.rewardWeight(A)=1500000000000000000, and UnwindingModule.globalPoints[0x277c].totalRewardWeight=1333333333333333334 (where 0x277c is the last global point)? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "MYreachability_uw_total_voting_exceeds_sum_user_voting_assum_getLastGlobalPoint_weak" : "Is it possible to reach a state in which: getLastGlobalPoint() has just been called, a user A has UnwindingModule.rewardWeight(A)=1500000000000000000, and UnwindingModule.globalPoints[0x277c].totalRewardWeight=1333333333333333334 (where 0x277c is the last global point)? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "MYreachability_uw_total_voting_exceeds_sum_user_voting_assum_getLastGlobalPoint_weak2" : "Is it possible to reach a state immediately after getLastGlobalPoint() has been called (i.e. after the call nothing happened, including time increases), in which: a user A has UnwindingModule.rewardWeight(A)=1500000000000000000, and UnwindingModule.globalPoints[0x277c].totalRewardWeight=1333333333333333334 (where 0x277c is the last global point)? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "MYreachability_uw_total_voting_exceeds_sum_user_voting_assum_getLastGlobalPoint" : "Is it possible to reach a state immediately after getLastGlobalPoint() has been called (i.e. after the call nothing happened, including time increases), in which it holds that in the same epoch a user A has UnwindingModule.rewardWeight(A)=1500000000000000000, and UnwindingModule.globalPoints[0x277c].totalRewardWeight=1333333333333333334 (where 0x277c is the last global point)? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "MYreachability_global_reward_weight_le_user_reward_weight_strong_weak" : "Is it possible to reach a state in which: A state in which: uint32 b0 = LockingController.enabledBuckets[0], uint32 b1 = LockingController.enabledBuckets[1], b0 == 1, b1 == 2, LockingController.buckets[b0].shareToken == liUSD1w, LockingController.buckets[b1].shareToken == liUSD2w, liUSD1w.totalSupply() >= liUSD1w.balanceOf(userA), liUSD2w.totalSupply() >= liUSD2w.balanceOf(userA), liUSD1w.balanceOf(anyOtherAddress) == 0 || (anyOtherAddress == userA), liUSD2w.balanceOf(anyOtherAddress) == 0 || (anyOtherAddress == userA); sumOfUserRewardWeight_before = require_uint256(LockingController.rewardWeight(e, userA)), uint256 total_locked_iUSD_with_rewards = require_uint256((LockingController.buckets[b0].totalReceiptTokens * LockingController.buckets[b0].multiplier / 10^18) + (LockingController.buckets[b1].totalReceiptTokens * LockingController.buckets[b1].multiplier / 10^18)), LockingController.globalRewardWeight >= total_locked_iUSD_with_rewards, LockingController.globalRewardWeight >= sumOfUserRewardWeight_before? If this state is reachable, you MUST return a trace that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The trace must be as detailed as possible.",
        "MYreachability_global_reward_weight_le_user_reward_weight_strong" : "Is it possible to reach a state in which: A state in which: uint32 b0 = LockingController.enabledBuckets[0], uint32 b1 = LockingController.enabledBuckets[1], b0 == 1, b1 == 2, LockingController.buckets[b0].shareToken == liUSD1w, LockingController.buckets[b1].shareToken == liUSD2w, liUSD1w.totalSupply() >= liUSD1w.balanceOf(userA), liUSD2w.totalSupply() >= liUSD2w.balanceOf(userA), liUSD1w.balanceOf(anyOtherAddress) == 0 || (anyOtherAddress == userA), liUSD2w.balanceOf(anyOtherAddress) == 0 || (anyOtherAddress == userA); sumOfUserRewardWeight_before = require_uint256(LockingController.rewardWeight(e, userA)), uint256 total_locked_iUSD_with_rewards = require_uint256((LockingController.buckets[b0].totalReceiptTokens * LockingController.buckets[b0].multiplier / 10^18) + (LockingController.buckets[b1].totalReceiptTokens * LockingController.buckets[b1].multiplier / 10^18)), LockingController.globalRewardWeight >= total_locked_iUSD_with_rewards, LockingController.globalRewardWeight >= sumOfUserRewardWeight_before? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible.",
        "MYreachability_global_reward_weight_le_user_reward_weight3" : "Is it possible to reach a state in which: There are 2 enabled buckets b1 and b2 (which are distinct) and non-enabled buckets are zeroed out and the multipliers are in the valid range, \nglobal voting power is greater than or equal to sum of voting power over buckets, there is a userA such that LockedPositionToken.totalSupply() >= LockedPositionToken.balanceOf(userA), LockedPositionToken2.totalSupply() >= LockedPositionToken2.balanceOf(userA), and any other address has Locked positionToken balance of 0, LockingController.globalRewardWeight >= (LockingController.buckets[b0].totalReceiptTokens * LockingController.buckets[b0].multiplier / 10^18) +  (LockingController.buckets[b1].totalReceiptTokens * LockingController.buckets[b1].multiplier / 10^18), and LockingController.globalRewardWeight >= LockingController.rewardWeight(e, userA)? If yes, you MUST return a counterexample that starts from the deployment of the main contract, and which shows step-by-step all function calls that lead to a state in which the property does not hold. The counterexample must be as detailed as possible."
    }
}
