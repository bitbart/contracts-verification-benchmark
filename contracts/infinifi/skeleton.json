{
    "name": "InfiniFi",
    "properties": {
        "no_withdraw_before_end_of_unwinding_epoch": "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. Given an arbitrary user and unwinding timestamp, if LockingController.withdraw is called with these parameters without reverting, it must always be that the position_before.toEpoch is greater than zero and the timestamp of the withdraw call is after toEpoch",
        "integrity_of_toEpoch_in_startUnwinding" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. If startUnwinding is called with arbitrary parameters and with an arbitrary EVM environment, the initialized position in the UnwindingModule will always have position_after.toEpoch == fromEpoch + unwindingEpochs",
        "unwinding_epoch_cannot_decrease" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. Given an arbitrary user and unwindingEpochs , assuming we: 1. save the corresponding position from UnwindingModule, 2. call an arbitrary public method of LockingController, except for startUnwinding, withdraw, cancelUnwinding, and emergencyAction, and 3. check the same position after, then the toEpoch after the call will always be greater or equal to the toEpoch from before the call",
        "reward_weight_monotonic_increasing_with_iUSD" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. If there are two arbitrary users and an arbitrarily chosen unwindingEpoch with nonzero balance of shareToken and userA has a greater balance than userB, the rewardWeightForUnwindingEpochs for userA will be greater or equal the reward weight for userB. We assume that the sum of the shareToken balance of the two users compared for the rule is less than the totalSupply() of the shareToken",
        "reward_weight_monotonic_increasing_with_multiplier" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. Assuming an arbitrarily chosen user has a position in two arbitrarily chosen unwindingEpoch buckets where the buckets have the same shareToken contract and the same totalReceiptTokens amount. If the multiplier for unwindingEpochA is greater than the multiplier for unwindingEpochB, then rewardWeightForUnwindingEpochs(userA,unwindingEpochA) > rewardWeightForUnwindingEpochs(user, unwindingEpochB)",
        "apply_losses_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. applyLosses can only be called by FinanceManager",
        "cancel_unwinding_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. cancelUnwinding can only be called by EntryPoint",
        "create_position_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. createPosition can only be called by EntryPoint or the UnwindingModule",
        "deposit_rewards_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. deposit can only be called by FinanceManager",
        "enable_bucket_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. enableBucket can only be called by Governor",
        "increase_unwinding_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. increaseUnwinding can only be called by EntryPoint",
        "set_bucket_multiplier_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. setBucketMultiplier can only be called by Governor",
        "start_unwinding_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. startUnwinding can only be called by EntryPoint",
        "withdraw_access" : "We restrict our scope to LockingController.sol. We assume that the ShareToken for a bucket is either address(0) or an instance of the LockedPositionToken contract. startUnwinding can only be called by EntryPoint",
        "no_immediate_redemption_from_non_empty_queue" : "We restrict our scope to RedeemController.sol. If RedeemController.queueLength() > 0 (i.e. it’s nonempty), if `redeem` is called with arbitrary parameters without reverting, it is not possible for the balance of the `to` address to increase by the full asset amount as calculated by `receiptToAsset`. (In other words, the already enqueued redemptions will be prioritized ahead of new ones)",
        "mintingNonzeroAssetAlwaysResultsInNonzeroReceipt" : "We restrict our scope to MintController.sol. If `MintController.mint` is called with a nonzero `assetAmountOut` the returned receipt amount will also be greater than zero. We make the following assumptions: 1. The value of USDC and iUSD are within 10% of their reference value. 2. We use the fact that ReceiptToken has more decimals than USDC to prove this.",
        "apply_losses_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol. applyLosses can only be called by LockedTokenManager",
        "cancel_unwinding_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol. cancelUnwinding can only be called by LockedTokenManager",
        "deposit_rewards_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol. deposit can only be called by LockedTokenManager",
        "start_unwinding_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol. startUnwinding can only be called by LockedTokenManager",
        "withdraw_access_UnwindingModule" : "We restrict our scope to UnwindingModule.sol.withdraw can only be called by LockedTokenManager",
        "start_and_cancel_unwinding_is_nop_rwBias" : "We restrict our scope to UnwindingModule.sol. Given an arbitrary user and an arbitrary unwinding epoch, calling startUnwinding followed by cancelUnwinding should not affect the value of rewardWeightBiasIncreases for the epoch. Note that we assume cancelUnwinding is called a full epoch after startUnwinding",
        "no_rewards_for_same_epoch" : "Given an arbitrary `user` and arbitrary startUnwindingTimestamp, let position = getPosition(user,startUnwindingTimestamp) if balanceOf(user, startUnwindingTimestamp) exceeds UnwindingModule.sharesToAmount(position.share s) then the epoch for the block timestamp of the balanceOf call must exceed position.fromEpoch - 1 (i.e. it must be a full epoch greater than when unwinding began to have a balance increase)",

        "cannotCallExitingMethodWithUnappliedLosses" : "If any “exiting function” is called without reverting, it must always be that YieldSharing.unaccruedYield() was greater or equal to zero at the time the exit call was made. Here exiting functions include: * for InfiniFiGatewayV1: withdraw, redeem * for StakedToken: redeem, withdraw, maxRedeem, maxWithdraw.  We make the following asusmptions: 1. For verification performance reasons we model YIeldSharing.unaccruedYield and _.withdraw as having no side effects and returning an arbitrary value (though we cover all return values) NOTE: this applies to the internal _withdraw method and not the externally callable method which is otherwise covering the full solidity implementation 2. We assume StakedToken is not paused (otherwise maxRedeem/maxWithdraw can be called even if there is an accrued loss though it will be a NOP that always returns zero)",
        "totalAssetsIsSumOfFarmAssets" : "Accounting.totalAssets(USDC) returns the sum over the assets() returned by (held by) the individual farms (here MintController and AaveV3Farm)  We make the following assumptions: 1. For this property we use a farm configuration where the enabled farms are exactly MintController and AaveV3Farm 2. For verification performance reasons we model applyLosses and depositRewards as having no side effect and returning an arbitrary number (note that neither of these affect the truth of the property) ",
        "uw_total_voting_exceeds_sum_user_voting" : "UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token.",
        "uw_total_voting_exceeds_sum_user_voting_applyLosses":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is only possible to call the method applyLosses.",
        "uw_total_voting_exceeds_sum_user_voting_applyLosses_inUnwindingModule":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is only possible to call the method applyLosses in UnwindingModule.sol.",
        "uw_total_voting_exceeds_sum_user_voting_applyLosses_inUnwindingModule_HintRounding":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is only possible to call the method applyLosses in UnwindingModule.sol. Be careful about rounding.",
        "uw_total_voting_exceeds_sum_user_voting_applyLosses_inUnwindingModule_HintRounding_hintReasoning": "UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is only possible to call the method applyLosses in UnwindingModule.sol.  The following reasoning might help you determine whether the property holds or not. Be careful, you cannot assume that the reasoning is correct. If it is not correct, include in your answer why it is not. START_REASONING. A precision loss caused by rounding during normalization in UnwindingModule results in an invariant violation: after calling applyLosses(uint256), the value returned by totalRewardWeight() can become less than the sum of all user reward weights, which should not be possible. Both totalRewardWeight() and rewardWeight() apply normalization by multiplying by slashIndex and dividing by 1e18 using mulWadDown, which rounds down. When applyLosses() updates slashIndex (via a mulDivDown operation) and burns a portion of receipt tokens, the updated slashIndex causes the individually rounded user reward weights to sum to more than the rounded-down total reward weight — violating consistency. Specifically, in applyLosses(): slashIndex = slashIndex.mulDivDown(_totalReceiptTokens - _amount, _totalReceiptTokens); And in both view functions: return point.totalRewardWeight.mulWadDown(slashIndex); // totalRewardWeight() ... return userRewardWeight.mulWadDown(slashIndex); // rewardWeight() 17 Since rounding is applied independently in both functions, precision loss accumulates across users, resulting in the sum of user weights exceeding the total. END_REASONING.",
        "uw_total_voting_exceeds_sum_user_voting_noapplyLosses":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. We underapproximate: we assume there are at most 3 nonzero unwinding positions involving 2 distinct users and 2 distinct timestamps. 2. lastGlobalPoint and points[lastGlobalPoint] are updated immediately whenever needed 3. ReceiptToken.totalSupply() is greater or equal the sum over receipt tokens held in all buckets 4. LockedPositionToken.totalSupply() is equal to the sum of individual balances on this token. 5. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is not possible to call the method applyLosses.",
        "uw_total_voting_exceeds_sum_user_voting_noapplyLosses_noassumptions":"UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp). Assumptions: 1. Assume that we start in a state where it holds that UnwindingModule.totalRewardWeight is greater than or equal to the sum over individual position reward weights as calculated by rewardWeight(user, unwindingTimestamp), and that it is not possible to call the method applyLosses.",
        "uw_total_voting_exceeds_sum_user_voting_method_applyLosses" : "",
        "strict_solvency_mint_4626" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only ERC4626 and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "strict_solvency_mint_aave" : "We assume to use Accounting.totalAssetValue() to determine the total value of underlying asset, and use ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value. Beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary mint with arbitrary parameters, then the total asset value will still exceed the total receipt token value afterwards. We assume that only AaveV3Farm and MintController are enabled as farms. Further assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 3. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 4. For this property we assume AaveV3Farm or ERC4626Farm and either RedeemController / MintController (depending on whether redeem or mint is under verification) are the only enabled farms. The “rule names” below distinguish these. 5. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20.",
        "global_reward_weight_le_user_reward_weight_strong" : "Beginning from an arbitrary initial state where the Locking Controller globalRewardWeight exceeds the reward weight of the user If we execute an arbitrary non-view function in LockingController or UnwindingModule, the resulting state is proven to also be one where the LockingController.globalRewardWeight exceeds the user reward weight. Assumptions: 1. We assume the total supply is greater or equal the user balances for the LockedPositionToken 2. We underapproximate the number of enabled buckets – we assume there are exactly 2 enabled buckets, each with distinct instances of the LockedPositionToken, and that these do not change 3. We underapproximate the users – we assume there is just one address that has a nonzero balance of LockedPositionToken 4. We assume here LockingController.globalRewardWeight is greater or equal the total iUSD value locked in the enabled buckets. (We verify this holds separately with P-20)",
        "global_reward_weight_le_total_locked_iUSD_with_rewards_after" : "We assume to start from an arbitrary initial state where the LockingController.globalRewardWeight exceeds the sum over value locked in buckets. If we execute an arbitrary non-view method in LockingController or UnwindingModule, then the resulting state is one where the globalRewardWeight still exceeds the sum over value locked in buckets. By value locked in a bucket we mean bucket.totalReceiptTokens * bucket.multiplier / 10^18. Assumptions: 1. We assume the total supply is greater or equal the user balances for the LockedPositionToken 2. We underapproximate the number of enabled buckets – we assume there are exactly 2 enabled buckets, each with distinct instances of the LockedPositionToken 3. We assume non-enabled buckets are zeroed out and the multipliers in enabled buckets are in the valid range of (10^18 - 2*10^18) 4. We assume the enabled buckets are distinct 5. We underapproximate the number of users. We assume there are exactly 2 distinct users with nonzero balances in either bucket.",
        "solvency_YieldSharing": "We restrict our scope to YieldSharing.sol. Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state then the total asset value will still exceed the total receipt token value afterwards  We make the following assumptions:  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 37 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 5. For this property and set of contracts the AaveV3Farm and MintController are the (only) enabled farms 6. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 7. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset,addFarms, removeFarms",
        "solvency_AllocationVoting": "We restrict our scope to AllocationVoting.sol. Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, if we call an arbitrary AllocationVoting function with arbitrary parameters from an arbitrary state then the total asset value will still exceed the total receipt token value afterwards  We make the following assumptions:  Assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 37 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, AaveV3Farm 5. For this property and set of contracts the AaveV3Farm and MintController are the (only) enabled farms 6. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 7. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset,addFarms, removeFarms",
        "solvency_only_redeem_deg": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call redeem with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the RedeemController and MintController are the (only) enabled farms for redeem and mint respectively 7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "solvency_only_mint_deg": "Using Accounting.totalAssetValue() to determine the total value of underlying asset, and using ReceiptToken.totalSupply * Accounting.price(ReceiptToken) / 1e18 to determine total receipt token value, then, beginning from an arbitrary state where the total asset value is greater than the total receipt token value, If we call mint with arbitrary parameters from an arbitrary state, Then the total asset value will still exceed the total receipt token value afterwards.    We make the following assumptions: 1. Oracle prices do not change between the value calculation before and after the infiniFi protocol function under verification 2. We assume there are exactly two buckets in the LockingController, though we cover all possible configurations for them (aside from ones that would cause reverts) 3. For both the underlying asset (USDC) and ReceiptToken ERC20s, we assume: the totalSupply is greater or equal the total balance of users 4. The message sender when calling any of the functions covered here is not any of these contracts: Accounting, InfiniFiGatewayV1, MintController, RedeemController 5. We allow the price of ReceiptToken to deviate from the reference by +/-10% 6. For this property and set of contracts the MintController is the (only) enabled farm for  mint  7. getEnabledAsset returns just USDC and we model USDC as a relatively standard ERC20. 8. We assume the following governor actions are not called: emergencyAction, enableAsset, disableAsset, addFarms, removeFarms",
        "MYbuckets_multiplier_bounded" : "Given A, buckets[A].multiplier is bounded."
    }
}
