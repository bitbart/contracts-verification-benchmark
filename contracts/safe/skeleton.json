{
    "name": "Safe",
    "properties": {
        "guardAddressChange": "The only method that can change the transaction guard is setGuard",
        "guardAddressChange_nodelegatecalls": "The only method that can change the transaction guard is setGuard. Assume that delegate calls are never invoked",       
        "REFINED_guardAddressChange": "The transaction guard can be changed only via a call to the method setGuard or via a call performed by the owner",
        "REFINED2_guardAddressChange": "The transaction guard can be changed only via a call to the method setGuard or via a call performed by the owner or via a call performed by a module enabled on Safe",
        "REFINED3_guardAddressChange": "After the setup of Safe, the transaction guard can be changed only via a call to the method setGuard or via a call performed by the owner or via a call performed by a module enabled on Safe",
        "setGetCorrespondenceGuard" : "Making sure that set and get work as expected for the transaction guard.",
        "setGuardReentrant" : "setGuard can only be called by contract itself.",
        "txnGuardCalled" : "The transaction guard gets called both pre- and post- any execTransaction",
        "txnGuardCalledFIX" : "Assuming that the transaction guard is set to a non-zero address, then the transaction guard gets called both pre- and post- any non-reverting execTransaction",
        "moduleGuardAddressChange" : "The only method that can change the module guard is setModuleGuard.",
        "moduleGuardAddressChange_nodelegatecalls" : "The only method that can change the module guard is setModuleGuard. Assume that delegate calls are never invoked",
        "setGetCorrespondenceModuleGuard" : "Making sure that set and get work as expected for the transaction guard.",
        "setModuleGuardReentrant" : "setModuleGuard can only be called by contract itself.",
        "moduleGuardCalled" : "The module guard gets called both pre- and post- any execTransactionFromModule",
        "moduleGuardCalledFIX" : "Assuming that the module guard is set to a non-zero address, if a call to execTransactionFromModule does not revert, then the module guard gets called both pre- and post- the execution of execTransactionFromModule",
        "moduleGuardCalledReturn" : "The module guard gets called both pre- and post- any execTransactionFromModuleReturnData",
        "execTxnModulePermissions" : "A successful call to execTransactionFromModule must be from an enabled module",
        "execTxnModuleReturnDataPermissions" : "A call to execTransactionFromModuleReturnData that succeeds must be from an enabled module.",
        "executePermissions" : "Execute can only be called by execTransaction or execTransactionFromModule.",
        "executePermissionsFIX" : "Execute can only be called by execTransaction or execTransactionFromModule or execTransactionFromModuleReturnData or setup." , 
        "executePermissionsFIX_nodelegatecalls" : "Execute can only be called by execTransaction or execTransactionFromModule or execTransactionFromModuleReturnData or setup. Assume that delegate calls are never invoked"  ,
        "executeThresholdMet" : "The number of signatures provided for any executing transaction meets the correct threshold.",
        "executeThresholdMet_nodelegatecalls" : "The number of signatures provided for any executing transaction meets the correct threshold. Assume that delegate calls are never invoked",        
        "executeThresholdMet_nodelegatecalls_noexecFromMod" : "The number of signatures provided for any executing transaction different from ModuleManager.execTransactionFromModule meets the correct threshold. Assume that delegate calls are never invoked",        
        "executeThresholdMet_noexecFromMod" : "The number of signatures provided for any executing transaction different from ModuleManager.execTransactionFromModule meets the correct threshold.",        
        "approvedHashesUpdate" : "approvedHashes[user][hash] can only be changed by msg.sender==user.",
        "approvedHashesUpdate_nodelegatecalls" : "approvedHashes[user][hash] can only be changed by msg.sender==user. Assume that delegate calls are never invoked",
        "approvedHashesSet" : "approvedHashes is set when calling approveHash",
        "approvedHashesSetFIX" : "approvedHashes is set when calling approveHash (assume that the call does not revert)",
        "transactionHashCantCollide" : "The hash of two distinct transactions cannot be the same.",
        "transactionHashCantCollide_assumeNoKekkakCollision" : "The hash of two distinct transactions cannot be the same. Assume collision resistance of keccak256, i.e. that two different inputs cannot be mapped to the same output",
        "setupThresholdZeroAndSetsPositiveThreshold" : "setup can only be called if threshold = 0 and setup sets threshold > 0",
        "setFallbackIntegrity" : "The fallback handler gets set by setFallbackHandler.",
        "setFallbackIntegrityFIX" : "The fallback handler gets set by setFallbackHandler (assume that the call does not revert)",
        "fallbackHandlerNeverSelf" : "The address for the fallback handler slot is never set to the Safe contract.",
        "fallbackHandlerNeverSelf_nodelegatecalls" : "The address for the fallback handler slot is never set to the Safe contract. Assume that delegate calls are never invoked",
        "simulateAndRevertReverts" : "simulateAndRevert always reverts.",
        "setSafeMethodSets" : "setSafeMethod sets the handler.",
        "setSafeMethodRemoves" : "setSafeMethod removes the handler.",
        "setSafeMethodRemovesFIX" : "setSafeMethod removes the handler, assuming that `newMethod` is the zero address",
        "setSafeMethodChanges" : "setSafeMethod changes the handler.",
        "setSafeMethodChangesFIX" : "setSafeMethod sets the handler to `newMethod`.",
        "handlerCallableIfSet" : "A handler, once set via setSafeMethod, is possible to call.",
        "handlerCalledIfSet" : "A handler, once set visa setSafeMethod, gets called under the expected conditions.",
        "MYonlyOwnersAddModule" : "Adding and removing a module requires confirmation from all owners.",
        "MYonlyOwnersAddModule2" : "Adding and removing a module requires confirmation from at least `threshold` number of owners.",
        "MYboundedowners" : "The number of owners is bounded.",
        "MYboundedthreshold" : "The value of `threshold` is bounded.",
        "MYaddowner" : "An owner can be added only if at least a `threshold` number of owner agree.",
        "MYnoUnboundedLoops" : "The code of the contract does not contain unbounded loops"
    }
}
